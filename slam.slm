{
The Slam Compiler, written in Slam

Started by:
  Preston Precourt (prestosilver) 2022

TODO: super class
TODO: Merge the getasm functions
TODO: Clean magic nums
TODO: Track stack loop
TODO: Macros / Inlines
TODO: Stripping?
TODO: Check for no return
TODO: String consts
TODO: Set stack size
TODO: Make string buffer a string instead of cstring
FIX: class inheritance issue with oper procs
FIX: cmdexec dosent check for command
FIX: cmdexec $PATH
FIX: \ on boundry
} 
inc "stdlib.slm"
inc "stdlib/log.slm"
inc "stdlib/os.slm"
inc "stdlib/mem.slm"
inc "stdlib/maps.slm"
inc "stdlib/arrays.slm"

{inc compiler/sim.slm}

proc version 0 1
  "0.4.3" ret
end

{
This is a enum of all the operations
and identifiers in slam
}
enum
0   OP_BAD
    OP_NOP
    OP_PUSH
    OP_SUB
    OP_MUL
    OP_DIV
    OP_PLUS
    OP_SWAP
    OP_DUMP
    OP_COPY
    OP_COVR
    OP_READ
    OP_READC
    OP_PUT
    OP_PUTC
    OP_DISC
    OP_ARGV
    OP_ARGC
    OP_ENVP
    OP_PUSHP
    OP_CALLS
    OP_RET
    OP_QUIT
    OP_IF
    OP_NQ
    OP_EQ
    OP_LT
    OP_GT
    OP_AND
    OP_XOR
    OP_OR
    OP_NOT
    OP_SYS0
    OP_SYS1
    OP_SYS2
    OP_SYS3
    OP_SYS4
    OP_SYS5
    OP_SYS6

    IDENT_INC
    IDENT_LNK
    IDENT_GVAR
    IDENT_CLASS
    IDENT_CONST
    IDENT_ENUM
    IDENT_PROP
    IDENT_PROC
    IDENT_OPER
    IDENT_CPROC
    IDENT_DO
    IDENT_VAR
    IDENT_END
    IDENT_OF
    IDENT_ASM
end

{
some parsing flags for context
}
enum
0   CF_NONE
    CF_PROC_OUT
    CF_PROC_IN
    CF_PROC_NAME
    CF_CPROC_OUT
    CF_CPROC_IN
    CF_CPROC_NAME
    CF_CONST_VALUE
    CF_CONST_NAME
    CF_PROP_VALUE
    CF_PROP_NAME
    CF_INC
    CF_LNK
    CF_VAR
    CF_GVAR_VALUE
    CF_GVAR_NAME
    CF_ENUM_CONTENT
    CF_ENUM_START
    CF_CLASS
    CF_OF
    CF_ASM
end

{
help message modes
}
enum
1   HELP_VERSION
    HELP_SHOW
    HELP_ARGS
    HELP_OUTPUT
end

{
kinds of procs
}
enum
0   PROC_DEFAULT
    PROC_OPER
    PROC_INLINE
end

{
this stores information about a proc
}
class procdata
  prop in 1
  prop out 1
  prop addr int.SIZE
  prop kind int.SIZE
end

{
stores the current line and file info
}
class linedata
  prop line int.SIZE
  prop column int.SIZE
  prop file 20
end

{
this stores data for a class
}
class classdata
  prop inherits 64
end

{the size of a key for the proc, const table}
const TAB_KEY_SIZE   20
{The maximum size of the string data at the end of the asm}
const STRING_BUF_CAP 300000
{The size of a segment the file reads}
const READSIZE       2048
{the maximum identifer stack size * 8}
const IDENT_CAP      1024

{A table of consts and values}
var consttab int.SIZE
{A table of gloval variables and addresses}
var gvartab int.SIZE
{A table of procs}
var proctab int.SIZE
{A table of classes}
var classtab int.SIZE
{A table of included files}
{TODO: Make list}
var includedtab int.SIZE
{A table of c procs}
var cproctab int.SIZE

{Temp vars for putting values into maps}
var maptemp int.SIZE
var maptempstr TAB_KEY_SIZE

{stores the current command}
var cmdbuffer READSIZE
{stores ld flags}
var linkbuffer READSIZE
var linkcount int.SIZE
var _ 1 {add 1 char for reading}
{stores the current command in a block}
var blockbuffer READSIZE
var _ 1 {add 1 char for reading}
{stores the current data last read from the file}
var readbuffer int.SIZE
{A string storing the string data for end of asm}
var stringbuffer int.SIZE
{The size of the string buffer}
var stringbufferlen int.SIZE
{The last string id in the string buffer}
var parsestringidx int.SIZE

{the current input file descriptor}
var inputfd int.SIZE
{the current output file descriptor}
var outputfd int.SIZE
{Stores cmd line data}
var cmdlineflags int.SIZE
{Pointer to the identifier stack, used for IDENT_END}
var identstack int.SIZE

{some buffers for stats}
{TODO: Make pointers}
var classname 64
var outputbuffer 64
var inputbuffer 64
var cmdtmpbuffer 64
var tmpprocbuffer 64
var procname 64
var constname 64
var parseaddr int.SIZE
var parsesubaddr int.SIZE

{stores a file to be queued to include}
var includebuffer 256
{stores the path to include files from}
var includepath 256

{Stores a parser flag for idents}
var parseflags int.SIZE

{the size of all gvars}
var parsememory int.SIZE

{the offset of the stack in the current proc}
var parsestack int.SIZE
{the offset of the stack in a block in the current proc}
var parsestackblock int.SIZE
{the value of the next enum entry}
var enumvalue int.SIZE
{the size of the current object so far}
var propsize int.SIZE
{stats for the current proc}
var procstats procdata.SIZE
{stats for the current class}
var classstats classdata.SIZE
{the current files line stats}
var linestats int.SIZE

var tmpbuffer 64
{if the block returned}
var blockret 1

{
args: int[char]
returns: int[char]

gets the char for the escape code
}
proc getescape 1 1
  copy 'e' == if [ disc 27 ret ]
  copy 'r' == if [ disc 13 ret ]
  copy 'n' == if [ disc 10 ret ]
  copy 't' == if [ disc 9  ret ]
  copy '0' == if [ disc 0  ret ]

  ret
end

{
args:
returns:

Setup a var for adding
}
proc setupvar 0 0
  parseflags
  CF_VAR
  put disc
  
  procname readc 0 == if [
    parseflags
    CF_GVAR_NAME
    put disc
  ]

  ret
end

{
args:
returns:

appends the current line to the log
}
proc lineappend 0 0
  " <" (log.cat)
  linestats read
  linedata.file .
  (log.cat)
  "@" (log.cat)
  linestats read
  linedata.line . read
  (int.cstr) (log.cat)
  ":" (log.cat)
  linestats read
  linedata.column . read
  (int.cstr) (log.cat)
  ">" (log.cat)

  ret
end

{
args: ptr[input]
returns: int[success]

opens a file for writing
}
proc openinput 1 1
  linestats linedata.SIZE (heap.zalloc) put disc
  linestats read linedata.file . covr (cstr.copy) disc disc

  inputfd read
  copy NULL != if [(os.close) 0]
  disc
  inputfd NULL put disc
  
  includedtab read covr (map.in) if [
    disc disc bool.false ret
  ]
  disc
  maptemp 1 put disc
  includedtab read covr maptemp (map.put)
  disc

  cmdlineflags read ! if [
    0 1 (log.level)
    "SLM" "Compile: " (log.msg)
    copy (log.cat)
    (log.log)
  ]

  {open input}
  0 swap
  fm.READ swap
  0
  covr readc '/' != if [
    disc -100
  ]
  (os.open)
  inputfd swap put disc

  bool.true

  ret
end

{
args: int[success]
returns: ptr[input]

gets a operation from a string name
}
proc getopfromname 1 1
  OP_BAD
  covr "proc"  (cstr.eq) if [disc IDENT_PROC]
  covr "oper"  (cstr.eq) if [disc IDENT_OPER]
  covr "cproc" (cstr.eq) if [disc IDENT_CPROC]
  covr "do"    (cstr.eq) if [disc IDENT_DO]
  covr "end"   (cstr.eq) if [disc IDENT_END]
  covr "inc"   (cstr.eq) if [disc IDENT_INC]
  covr "lnk"   (cstr.eq) if [disc IDENT_LNK]
  covr "enum"  (cstr.eq) if [disc IDENT_ENUM]
  covr "var"   (cstr.eq) if [disc IDENT_VAR]
  covr "gvar"  (cstr.eq) if [disc IDENT_GVAR]
  covr "const" (cstr.eq) if [disc IDENT_CONST]
  covr "class" (cstr.eq) if [disc IDENT_CLASS]
  covr "of"    (cstr.eq) if [disc IDENT_OF]
  covr "asm"   (cstr.eq) if [disc IDENT_ASM]
  covr "prop"  (cstr.eq) if [disc IDENT_PROP]
  
  covr "nop"   (cstr.eq) if [disc OP_NOP]
  covr "-"     (cstr.eq) if [disc OP_SUB]
  covr "*"     (cstr.eq) if [disc OP_MUL]
  covr "/%"    (cstr.eq) if [disc OP_DIV]
  covr "+"     (cstr.eq) if [disc OP_PLUS]
  covr "^"     (cstr.eq) if [disc OP_XOR]
  covr "."     (cstr.eq) if [disc OP_PLUS]
  covr "swap"  (cstr.eq) if [disc OP_SWAP]
  covr "dump"  (cstr.eq) if [disc OP_DUMP]
  covr "copy"  (cstr.eq) if [disc OP_COPY]
  covr "covr"  (cstr.eq) if [disc OP_COVR]
  covr "readc" (cstr.eq) if [disc OP_READC]
  covr "read"  (cstr.eq) if [disc OP_READ]
  covr "@"     (cstr.eq) if [disc OP_READ]
  covr "putc"  (cstr.eq) if [disc OP_PUTC]
  covr "put"   (cstr.eq) if [disc OP_PUT]
  covr "="     (cstr.eq) if [disc OP_PUT]
  covr "disc"  (cstr.eq) if [disc OP_DISC]
  covr "argv"  (cstr.eq) if [disc OP_ARGV]
  covr "argc"  (cstr.eq) if [disc OP_ARGC]
  covr "envp"  (cstr.eq) if [disc OP_ENVP]
  covr "()"    (cstr.eq) if [disc OP_CALLS]
  covr "ret"   (cstr.eq) if [disc OP_RET]
  covr "quit"  (cstr.eq) if [disc OP_QUIT]
  covr "if"    (cstr.eq) if [disc OP_IF]
  covr "!="    (cstr.eq) if [disc OP_NQ]
  covr "=="    (cstr.eq) if [disc OP_EQ]
  covr "<"     (cstr.eq) if [disc OP_LT]
  covr ">"     (cstr.eq) if [disc OP_GT]
  covr "&&"    (cstr.eq) if [disc OP_AND]
  covr "||"    (cstr.eq) if [disc OP_OR]
  covr "!"     (cstr.eq) if [disc OP_NOT]
  covr "sys0"  (cstr.eq) if [disc OP_SYS0]
  covr "sys1"  (cstr.eq) if [disc OP_SYS1]
  covr "sys2"  (cstr.eq) if [disc OP_SYS2]
  covr "sys3"  (cstr.eq) if [disc OP_SYS3]
  covr "sys4"  (cstr.eq) if [disc OP_SYS4]
  covr "sys5"  (cstr.eq) if [disc OP_SYS5]
  covr "sys6"  (cstr.eq) if [disc OP_SYS6]
  swap disc
  
  ret
end

{
args: ptr[name]
returns: int[value]

gets a operation name from a enum
}
proc getopname 1 1
  (int.cstr)
  {TODO: reimplement}

  ret
end

{
args:
returns:

cleans the heap
}  
proc clean 0 0
  {close output}
  outputfd read
  copy NULL != if [(os.close) 0]
  disc

  {close input}
  inputfd read
  copy NULL != if [(os.close) 0]
  disc

  gvartab      read (map.free)
  consttab     read (map.free)
  proctab      read (map.free)
  cproctab     read (map.free)
  classtab     read (map.free)
  includedtab  read (map.free)

  identstack   read (seq.free)

  stringbuffer read (heap.free)
  
  ret
end

{
args:
returns:

quits the program with an error
}  
proc exit 0 0
  (clean)

  -1 quit
  ret
end

{
args: str[name] int[pops]
returns

checks for a stack underflow in a block
}
proc checkpopb 2 0
  parsestackblock read swap -
  parsestackblock swap put disc
  parsestackblock read
  0 < if [
    "ERR" "Stack underflow with `" (log.msg)
    copy (log.cat)
    "`" (log.cat)
    (lineappend)
    (log.log)
    (exit)
  ]
  disc
  ret
end

{
args: int[value]
returns:

adds the value to the virtual stack in a block
}
proc addstackb 1 0
  parsestackblock read swap +
  parsestackblock swap put disc

  ret
end

{
args: str[name] int[pops]
returns

checks for a stack underflow
}
proc checkpop 2 0
  parsestack read swap -
  parsestack swap put disc
  parsestack read
  0 < if [
    "ERR" "Stack underflow with `" (log.msg)
    copy (log.cat)
    "`" (log.cat)
    (lineappend)
    (log.log)
    (exit)
  ]
  disc
  ret
end

{
args: int[value]
returns:

adds the value to the virtual stack
}
proc addstack 1 0
  parsestack read swap +
  parsestack swap put disc

  ret
end

{
args: int[push]
returns:

pushes an ident to the ident stack
}
proc identstackpush 1 0
  identstack read swap (seq.pushint)
  disc

  ret
end

{
args:
returns: int[push]

pop from the ident stack
}
proc identstackpop 0 1
  identstack read (seq.popaddr) read swap disc

  ret
end

{
args: ptr[cstr]
returns: ptr[cstr]


removes the first and last char from a string
}
proc inner 1 1
  1 + copy
  copy (cstr.len) 1 - + 0 putc disc
  ret
end

{
args:
returns: int[value]

gets the next string index
}
proc getstringidx 0 1
  parsestringidx read
  copy 1 +
  parsestringidx swap put disc
  ret
end

{
args:
returns: int[value]

gets the next address
}
proc getaddr 0 1
  parsesubaddr
  0 put disc

  parseaddr read
  copy 1 +
  parseaddr swap put disc
  ret
end

{
args:
returns: int[value]

gets the next sub address
}
proc getsubaddr 0 1
  parsesubaddr read
  copy 1 +
  parsesubaddr swap put disc
  ret
end

{
args:
returns:

helper function for errors
}
proc noprocblock 0 0
  0 1 (log.level)
  "ERR"
  "Proc not found: " (log.msg)
  blockbuffer 1 + (log.cat)
  (lineappend)
  (log.log)
  (exit)

  ret
end

{
args:
returns:

helper function for errors
}
proc noproc 0 0
  0 1 (log.level)
  "ERR"
  "Proc not found: " (log.msg)
  cmdbuffer 1 + (log.cat)
  (lineappend)
  (log.log)
  (exit)
  
  ret
end

{
args:
returns:

helper function for errors
}
proc badblockop 0 0
  "ERR" "BAD OPERATION: `" (log.msg)
  blockbuffer (log.cat) "`" (log.cat)
  (lineappend)
  (log.log)
  (exit)

  ret
end

{
args:
returns:

helper function for errors
}
proc badop 0 0
  "ERR" "BAD OPERATION: `" (log.msg)
  cmdbuffer (log.cat) "`" (log.cat)
  (lineappend)
  (log.log)
  (exit)

  ret
end

{
args: ptr[str] int[len]
returns:

helper func to write to the current output buffer
}
proc writeout 2 0
  outputfd read (os.write)
  ret
end

{
args:
returns:

helper func to write a new line to the output
}
proc writeoutln 0 0
  `\n` (writeout)
  ret
end

{
args:
returns:

sets the current class name
}
proc setclassname 0 0
  classstats (cstr.clear) disc
  cmdbuffer classname swap (cstr.copy) disc disc

  IDENT_CLASS (identstackpush)

  parseflags
  CF_NONE
  put disc

  classtab read
  classname 
  (map.in) if [
    1 1 (log.level)
    "ERR" "Attempt to redefine class `" (log.msg)
    classname (log.cat) "`" (log.cat)
    (lineappend)
    (log.log)
    (exit)
  ]


  classname
  classstats
  (map.put)
  disc

  propsize
  0
  put disc

  ret
end

proc setclassinherits 0 0
  classstats
  cmdbuffer (cstr.copy) disc disc

  classtab read
  classname
  classstats
  (map.put)
  disc

  parseflags
  CF_NONE
  put disc

  ret
end

{
args: ptr[name]
returns: ptr[expanded]

gets the class proc name of a proc
}
proc getexpandedname 1 1
  tmpprocbuffer 64 (mem.zero)
  classname (cstr.len) 0 != if [
    tmpprocbuffer copy (cstr.len) +
    classname (cstr.copy) disc disc
    tmpprocbuffer copy (cstr.len) +
    "." (cstr.copy) disc disc
  ]
  tmpprocbuffer copy (cstr.len) +
  swap (cstr.copy) disc disc
  tmpprocbuffer

  ret
end

{
args:
returns: ptr[value]

gets the value of a const in the cmd buffer or returns the input
}
proc getconst 0 1
  NULL
  consttab read cmdbuffer (map.in) swap disc ! if [ disc cmdbuffer (cstr.tonum) ret ]
  disc
  consttab read cmdbuffer (map.get) read
  swap disc
  
  ret
end

{
args:
returns:

adds a proc thats linked to a c function
}
proc addcproc 0 0
  ` ` (writeout)
  parseflags copy read
  copy CF_CPROC_NAME == if [
    procstats
    procdata.addr .
    0
    put disc
    procname (cstr.clear) cmdbuffer (cstr.copy) disc disc
    `extrn ` (writeout)
    procname copy (cstr.len) swap (writeout)
    `;` (writeout)
  ] copy CF_CPROC_IN == if [
    cmdbuffer copy (cstr.len) swap (writeout)
    procstats
    procdata.in .
    cmdbuffer (cstr.tonum) 255 &&
    putc disc
    parsestack
    cmdbuffer (cstr.tonum) 255 &&
    put disc
  ] copy CF_CPROC_OUT == if [
    cmdbuffer copy (cstr.len) swap (writeout)
    procstats
    procdata.out .
    cmdbuffer (cstr.tonum) 255 &&
    putc disc
    cproctab read
    procname (getexpandedname) procstats (map.put) disc
    (writeoutln)
    disc CF_NONE 1 +
  ]
  1 -
  putc disc

  ret
end

proc redeferr 0 0
  1 1 (log.level)
  "ERR" "Attempt to redefine proc `" (log.msg)
  procname (getexpandedname) (log.cat) "`" (log.cat)
  (lineappend)
  (log.log)
  (exit)

  ret
end

{
args:
returns:

adds a proc
}
proc addproc 0 0
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  parseflags copy read
  copy CF_PROC_NAME == if [
    procname (cstr.clear) cmdbuffer (cstr.copy) disc disc
    procstats procdata.addr .
    parseaddr read
    put disc
  ] copy CF_PROC_IN == if [
    procstats procdata.in .
    cmdbuffer (cstr.tonum) 255 &&
    putc disc
    parsestack
    cmdbuffer (cstr.tonum) 255 &&
    put disc
  ] copy CF_PROC_OUT == if [
    procstats procdata.out .
    cmdbuffer (cstr.tonum) 255 &&
    putc disc
    proctab read
    procname (getexpandedname)
    (map.in) if (redeferr)
    procname (getexpandedname)
    procstats
    (map.put) disc
    (writeoutln)
    procstats procdata.kind . 0 put disc
  ]
  1 -
  putc disc

  ret
end

{
args:
returns:

adds a class property
}
proc addprop 0 0
  parseflags
  copy read 1 - copy
  CF_PROP_VALUE 1 - == if [      
    consttab read constname (getexpandedname) propsize (map.put) disc

    propsize
    copy read
    (getconst) +
    put disc

    disc CF_NONE
  ] copy CF_PROP_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

{
args:
returns:

adds a const
}
proc addconst 0 0
  parseflags
  copy read 1 - copy
  CF_CONST_VALUE 1 - == if [
    maptemp (getconst) put disc
    consttab read constname (getexpandedname) maptemp (map.put) disc
    disc CF_NONE
  ] copy CF_CONST_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

{
args:
returns:

adds a global variable
}
proc addgvar 0 0
  parseflags
  copy read 1 -
  copy CF_GVAR_VALUE 1 - == if [
    gvartab read constname (getexpandedname) parsememory (map.put) disc
    (getconst)
    parsememory read +
    parsememory swap put disc
    disc CF_NONE
  ] copy CF_GVAR_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

{
args:
returns:

inits the enum value 
}
proc addenumstart 0 0
  enumvalue
  cmdbuffer (cstr.tonum)
  put disc

  parseflags
  CF_ENUM_CONTENT
  put disc

  ret
end

{
args:
returns:

adds a enum value 
}
proc addenum 0 0 
  cmdbuffer (cstr.isnum) if [
    enumvalue
    cmdbuffer (cstr.tonum)
    put disc

    ret
  ]

  cmdbuffer "end" (cstr.eq) if [
    parseflags
    CF_NONE
    put disc
    ret
  ]

  consttab read cmdbuffer (getexpandedname) enumvalue (map.put) disc

  enumvalue read
  1 +
  enumvalue swap put disc

  ret
end

{
args:
returns:

include a file
}
proc addinc 0 0 
  includebuffer
  includepath (cstr.copy) disc
  "/" (cstr.cat)
  cmdbuffer copy readc '"' == if [
    (inner)
  ] (cstr.cat)
  disc

  parseflags
  CF_NONE
  put disc

  ret
end

{
args:
returns:

add a linker flag
}
proc addlnk 0 0 
  linkbuffer 
  linkcount read int.SIZE * 2 *
  +
  "-l" put
  int.SIZE +
  cmdbuffer
  copy (cstr.len) (heap.zalloc)
  swap (cstr.copy) disc
  put disc
  
  linkcount
  copy read 1 +
  put disc

  parseflags
  CF_NONE
  put disc

  ret
end

{
args:
returns:

adds a variable, static and bad
}
proc addvar 0 0
  1 (addstack)
  `    push mem+` (writeout)
  parsememory read (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)

  cmdbuffer (cstr.tonum)
  parsememory read +
  parsememory swap put
  disc

  parseflags
  CF_NONE
  put disc

  ret
end

{
args:
returns:

adds the header to the current output
}
proc asmheader 0 0
    stringbufferlen 1 put disc
    `format ELF64\n` (writeout)
    `section '.text' executable\n` (writeout)
    `public _start\n\n` (writeout)
    `print:\n` (writeout)
    `    mov r10, rsp\n` (writeout)
    `    sub rsp, 8\n` (writeout)
    `    mov [rsp], al\n` (writeout)
    `    mov edi, 1\n` (writeout)
    `    mov rsi, rsp\n` (writeout)
    `    mov edx, 1\n` (writeout)
    `    mov eax, 1\n` (writeout)
    `    syscall\n` (writeout)
    `    mov rsp, r10\n` (writeout)
    `    ret\n` (writeout)
    ret
end

{
args:
returns:

adds the footer to the current output
}
proc asmfooter 0 0
  `addr_` (writeout)
  (getaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:\n` (writeout)
  `    ret\n` (writeout)
  `_start:\n` (writeout)
  `    mov qword [args_ptr], rsp\n` (writeout)
  `    mov qword [ret_stack_rsp], ret_stack\n` (writeout)
  `    mov rax, [ret_stack_rsp] \n` (writeout)
  `    mov qword [rax], quit\n` (writeout)
  `    jmp addr_` (writeout)
  proctab read
  maptempstr "main" (cstr.copy) disc disc
  maptempstr (map.in) ! if [
    0 1 (log.level)
    "ERR" "no main proc defined" (log.msg)
    blockbuffer 1 + (log.cat)
    (lineappend)
    (log.log)
    (exit)
  ]
  maptempstr (map.get) procdata.addr . read 1 - (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)
  `quit:\n` (writeout)
  `    mov rax, 60\n` (writeout)
  `    mov rdi, 0\n` (writeout)
  `    syscall\n` (writeout)
  `section '.data'\n` (writeout)
  stringbuffer read 1 + stringbufferlen read 1 - swap (writeout)
  `section '.bss'\n` (writeout)
  `args_ptr: rq 1\n` (writeout)
  `ret_stack_rsp: rq 1\n` (writeout)
  `ret_stack: rb 65536` (writeout) (writeoutln)
  `mem: rb ` (writeout)
  parsememory read (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)
  disc
  
  {debug logging}
  3 1 (log.level)
  "INF" "Total procs: " (log.msg)
  proctab read (map.len) (int.cstr) (log.cat) disc
  (log.log)
  "INF" "Global memory footprint: " (log.msg)
  parsememory read (int.cstr) (log.cat)
  " bytes" (log.cat)
  (log.log)
  ret
end

{
args: int[kind]
returns:

ends a operation
}
proc endopasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpop)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    (identstackpop) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  copy IDENT_CLASS == if [
    consttab read
    "SIZE" (getexpandedname) propsize (map.put)
    disc
    classname (cstr.clear) disc
  ]
  copy IDENT_PROC == if [
    procname (cstr.clear) disc
  ]
  disc
  ret
end

{
args: int[kind]
returns:

ends a operation in a block
}
proc endopblockasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpopb)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    (identstackpop) (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    (identstackpop) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

{
args:
returns:

writes the current address to the output
}
proc writeaddr 0 0
  `addr_` (writeout)
  (getaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  ret
end

{
args:
returns:

writes the current sub address to the output
}
proc writesubaddr 0 0
  `addr_` (writeout)
  parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
  `_` (writeout)
  (getsubaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  ret
end

proc addpushblock 1 1
  disc OP_PUSHP    
  
  proctab read blockbuffer (map.in) ! if [disc ret]
  blockbuffer (map.get)
  procdata.kind . read
  swap disc
  1 == if [
    (writeaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    proctab read
    blockbuffer (map.get)
    procdata.addr .
    read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    blockbuffer (map.get)
    procdata.in . readc
    blockbuffer swap (checkpopb)
    blockbuffer (map.get)
    procdata.out . readc
    (addstackb)
    disc
    disc
    OP_NOP
  ]
  ret
end


proc checkbadblock 1 1
  blockbuffer (cstr.len) 3 ==
  blockbuffer readc ''' == &&
  blockbuffer (cstr.last) ''' == && if [
    blockbuffer 1 + readc
    (int.cstr)

    blockbuffer (cstr.clear) swap (cstr.copy) disc disc

    disc OP_PUSH
    ret
  ]
  proctab read blockbuffer (map.in) if [
    disc
    (addpushblock)
    ret
  ] disc
  consttab read blockbuffer (map.in) if [
    blockbuffer (map.get) read swap disc
    (int.cstr)
    blockbuffer (cstr.clear) swap (cstr.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvartab read blockbuffer (map.in) if [
    1 (addstackb)
    `    push mem+` (writeout)
    gvartab read blockbuffer (map.get) read swap disc (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badblockop)
  ret
end

proc badret 0 0
  "ERR" "proc dosent return correct ammount `" (log.msg)

  procname (getexpandedname) (log.cat)
  "`" (log.cat)
  (lineappend)
  (log.log)
  (exit)

  ret
end

proc getblockasm 1 1
  blockbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writesubaddr)
  
  blockret 0 putc disc

  copy OP_BAD == if (checkbadblock)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    "push" 0 (checkpopb)
    1 (addstackb)
    `    mov qword rax, ` (writeout)
    blockbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push rax\n` (writeout)
    ret
  ] copy OP_CALLS == if [
    "call" 1 (checkpopb)
    0 (addstackb)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    pop rax\n` (writeout)
    `    jmp rax\n` (writeout)
    ret
  ] copy OP_PUSHP == if [
    "pushp" 0 (checkpopb)
    1 (addstackb)
    `    push addr_` (writeout)
    proctab read blockbuffer (map.get) procdata.addr . read (int.cstr) copy (cstr.len) swap (writeout)
    {TODO: assert return is same}
    (writeoutln)
    disc
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpopb)
    2 (addstackb)
    `    pop rax\n` (writeout)
    `    push rax\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpopb)
    2 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    sub rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    add rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    and rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    xor rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    or rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    xor rax, 1\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    imul rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "divmod" 2 (checkpopb)
    2 (addstackb)
    `    xor rdx, rdx\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    idiv rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rdx\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpopb)
    3 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_ARGC == if [
    "argc" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ARGV == if [
    "argv" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ENVP == if [
    "envp" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    add rax, 2\n` (writeout)
    `    shl rax, 3\n` (writeout)
    `    mov rbx, [args_ptr]\n` (writeout)
    `    add rbx, rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 1 (checkpopb)
    0 (addstackb)
    blockret 1 putc disc
    `    mov rax, 60\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpopb)
    0 (addstackb)
    blockret 1 putc disc
    procstats
    procdata.out . readc
    parsestackblock read != if (badret)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    sub rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    jmp qword [rax]\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpopb)
    0 (addstackb)
    `    pop rax\n` (writeout)
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov bl, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpopb)
    1 (addstackb)
    `   pop rax\n` (writeout)
    `   xor rbx, rbx\n` (writeout)
    `   mov rbx, [rax]\n` (writeout)
    `   push rbx\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov byte [rax], bl\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov qword [rax], rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovne rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmove rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovl rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpopb)
    0 (addstackb)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read 1 + (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpopb)
    0 (addstackb)
    3 0 (log.level)
    "WRN" "dump is depricated" (log.msg)
    (lineappend)
    (log.log)

    `    pop rax\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpopb)
    0 (addstackb)
    (identstackpop)
    (endopblockasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpopb)
    0 (addstackb)
    parsesubaddr read 1 - (identstackpush)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpopb)
    0 (addstackb)
    3 0 (log.level)
    "WRN" "gvar is depricated use var instead" (log.msg)
    (lineappend)
    (log.log)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpopb)
    0 (addstackb)
    (setupvar)
    ret
  ]
  2 0 (log.level)
  "WRN" "Unimplemented op: " (log.msg)
  copy (getopname) (log.cat)
  (log.log)

  `; unimp ` (writeout)
  copy (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc parsestring 0 0

  { add code }
  1 (addstackb)
  `    push str_` (writeout)
  (getstringidx) (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (int.cstr)
  copy (cstr.len) swap
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  blockbuffer 1 +

  { put the first char }
  copy readc
  (int.cstr)
  copy (cstr.len) swap
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer read stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (int.cstr)
    copy (cstr.len) swap
    stringbuffer read stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  `\n`
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  disc

  blockbuffer (cstr.clear) disc
  ret
end

proc cprocbuff 1 0
  copy 0 == if [
    disc ret
  ]
  disc
  ret
end

proc addcallblock 0 0
  proctab read blockbuffer 1 + (map.in) if [
    (writesubaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    blockbuffer 1 + (map.get)
    procdata.addr .
    read (int.cstr)
    copy (cstr.len) swap
    (writeout)
    (writeoutln)
    
    proctab read
    blockbuffer 1 + (map.get)
    procdata.kind . read
    1 == if (noprocblock)
    blockbuffer 1 + (map.get)
    procdata.in . readc
    blockbuffer 1 + swap (checkpopb)
    blockbuffer 1 + (map.get)
    procdata.out . readc
    (addstackb)
    disc

    blockbuffer (cstr.clear) disc

    disc ret
  ] disc
  cproctab read blockbuffer 1 + (map.in) if [
    `    push ebp\n` (writeout)
    `    sub ebp, 8 * ` (writeout)
    cproctab read
    cmdbuffer 1 + (map.get)
    readc
    cmdbuffer 1 + swap (int.cstr) (writeout)
    (writeoutln)
    disc
    `    call ` (writeout)
    cmdbuffer 1 + copy (cstr.len) swap (writeout)
    (writeoutln)
    `    add esp, 8 *` (writeout)
    cproctab read
    cmdbuffer 1 + (map.get)
    readc
    cmdbuffer 1 + swap (int.cstr) (writeout)
    (writeoutln)
    `    mov esp, ebp\n` (writeout)
    `    pop ebp\n` (writeout)
    `    push rax\n` (writeout)

    cmdbuffer 1 + (map.get)
    readc
    cmdbuffer 1 + swap (checkpop)
    cmdbuffer 1 + (map.get)
    1 + readc
    (addstack)
    disc
  ] disc

  blockbuffer 1 + '.' tmpbuffer (cstr.split)

  copy "" (cstr.eq) !
  covr classtab read swap (map.in) swap disc
  &&
  if [
    classtab read swap (map.get)
    swap disc
    tmpbuffer (cstr.clear)
    "(" (cstr.cat) 
    swap (cstr.cat)
    "." (cstr.cat)
    swap (cstr.cat)
    disc
    blockbuffer (cstr.clear)
    tmpbuffer (cstr.copy) disc disc
    (addcallblock)
    ret
  ]
  disc
  disc
  
  (noprocblock)

  ret
end

proc parseblockcmd 0 0
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' == && if [
    {comment}

    nop

    blockbuffer (cstr.clear) disc
  ] blockbuffer readc '"' == blockbuffer (cstr.last) '"' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner)
    (parsestring)

    disc ret
  ] blockbuffer readc '`' == blockbuffer (cstr.last) '`' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner) disc
    1 (addstackb)
    `    push ` (writeout)
    blockbuffer 1 + (cstr.len) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestring)
    ret
  ] blockbuffer readc '(' == blockbuffer (cstr.last) ')' == && blockbuffer (cstr.len) 2 != && if [
    {call}

    blockbuffer (inner) disc
    (addcallblock)
    ret
  ] blockbuffer readc 0 != if [
    parseflags read
    blockbuffer (getopfromname)
    covr CF_NONE == if (getblockasm)
    covr CF_VAR == if (addvar)
    disc disc
  ]
  blockbuffer (cstr.clear) disc

  ret
end

proc addpush 1 1
  disc OP_PUSHP    
  
  proctab read cmdbuffer (map.in) ! if [disc ret]
  cmdbuffer (map.get)
  procdata.kind . read
  swap disc
  1 == if [
    (writeaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    proctab read
    cmdbuffer (map.get)
    procdata.addr .
    read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    cmdbuffer (map.get)
    procdata.in . readc
    cmdbuffer swap (checkpop)
    cmdbuffer (map.get)
    procdata.out . readc
    (addstack)
    disc
    disc
    OP_NOP
  ]
  ret
end


proc checkbad 1 1
  cmdbuffer (cstr.len) 3 ==
  cmdbuffer readc ''' == &&
  cmdbuffer (cstr.last) ''' == && if [
    cmdbuffer 1 + readc
    (int.cstr)

    cmdbuffer (cstr.clear) swap (cstr.copy) disc disc

    disc OP_PUSH
    ret
  ]
  proctab read cmdbuffer (map.in) if [
    disc
    (addpush)
    
    ret
  ] disc
  consttab read cmdbuffer (map.in) if [
    cmdbuffer (map.get) read swap disc
    (int.cstr)
    cmdbuffer (cstr.clear) swap (cstr.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvartab read cmdbuffer (map.in) if [
    1 (addstack)
    `    push mem+` (writeout)
    gvartab read cmdbuffer (map.get) read swap disc (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badop)
  ret
end

proc getcmdasm 1 1
  cmdbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if (checkbad)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    1 (addstack)
    `    mov qword rax, ` (writeout)
    cmdbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push rax\n` (writeout)
    ret
  ] copy OP_CALLS == if [
    "call" 1 (checkpop)
    0 (addstack)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    pop rax\n` (writeout)
    `    jmp rax\n` (writeout)
    ret
  ] copy OP_PUSHP == if [
    "pushp" 0 (checkpop)
    1 (addstack)
    `    push addr_` (writeout)
    proctab read cmdbuffer (map.get) procdata.addr . read (int.cstr) copy (cstr.len) swap (writeout)
    {TODO: assert return is same}
    (writeoutln)
    disc
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpop)
    2 (addstack)
    `    pop rax\n` (writeout)
    `    push rax\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpop)
    2 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    sub rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    add rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    and rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    xor rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    or rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rax, 1\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    imul rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "div" 2 (checkpop)
    2 (addstack)
    `    xor rdx, rdx\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    idiv rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rdx\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpop)
    3 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy IDENT_CLASS == if [
    "class" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CLASS
    put disc
    ret
  ] copy IDENT_OF == if [
    "class" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_OF
    put disc
    ret
  ] copy IDENT_ASM == if [
    "asm" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_ASM
    put disc
    ret
  ] copy IDENT_CPROC == if [
    "cproc" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CPROC_NAME
    put disc
    ret
  ] copy IDENT_PROC == if [
    "proc" 0 (checkpop)
    0 (addstack)
    IDENT_PROC (identstackpush)
    `    ; - proc` (writeout)
    parseflags
    CF_PROC_NAME
    put disc
    ret
  ] copy IDENT_OPER == if [
    "oper" 0 (checkpop)
    0 (addstack)
    procstats
    procdata.kind .
    PROC_OPER put disc
    ret
  ] copy IDENT_ENUM == if [
    "enum" 0 (checkpop)
    0 (addstack)
    `    ; - enum\n` (writeout)
    parseflags
    CF_ENUM_START
    put disc
    ret
  ] copy OP_ARGC == if [
    "argc" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ARGV == if [
    "argv" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ENVP == if [
    "envp" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    add rax, 2\n` (writeout)
    `    shl rax, 3\n` (writeout)
    `    mov rbx, [args_ptr]\n` (writeout)
    `    add rbx, rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 1 (checkpop)
    0 (addstack)
    `    mov rax, 60\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpop)
    0 (addstack)
    proctab read
    procstats
    procdata.out . readc
    parsestack read != if (badret)
    disc
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    sub rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    jmp qword [rax]\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpop)
    0 (addstack)
    `    pop rax\n` (writeout)
    ret
  ] copy IDENT_PROP == if [
    "prop" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_PROP_NAME
    put disc
    ret
  ] copy IDENT_CONST == if [
    "const" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CONST_NAME
    put disc
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov bl, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov rbx, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov byte [rax], bl\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov qword [rax], rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovne rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmove rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovl rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpop)
    0 (addstack)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 + (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpop)
    0 (addstack)
    3 0 (log.level)
    "WRN" "dump is depricated" (log.msg)
    (lineappend)
    (log.log)

    `    pop rax\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_INC == if [
    "inc" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_INC
    put disc
    ret
  ] copy IDENT_LNK == if [
    "lnk" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_LNK
    put disc
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpop)
    0 (addstack)
    (identstackpop)
    (endopasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpop)
    0 (addstack)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpop)
    0 (addstack)
    3 0 (log.level)
    "WRN" "gvar is depricated use var instead" (log.msg)
    (lineappend)
    (log.log)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpop)
    0 (addstack)
    (setupvar)
    ret
  ]
  2 0 (log.level)
  "WRN" "Unimplemented op: " (log.msg)
  copy (getopname) (log.cat)
  (log.log)

  `; unimp ` (writeout)
  copy (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' != &&
  cmdbuffer readc ''' == cmdbuffer (cstr.last) ''' != && ||
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' != && ||
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' != && ||
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' != && ||
  cmdbuffer "`" (cstr.eq) ||
  cmdbuffer """ (cstr.eq) ||
  cmdbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkblockcmd 0 1
  blockbuffer readc '"' == blockbuffer (cstr.last) '"' != &&
  blockbuffer readc ''' == blockbuffer (cstr.last) ''' != && ||
  blockbuffer readc '`' == blockbuffer (cstr.last) '`' != && ||
  blockbuffer readc '[' == blockbuffer (cstr.last) ']' != && ||
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' != && ||
  blockbuffer "`" (cstr.eq) ||
  blockbuffer """ (cstr.eq) ||
  blockbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc blockbuffer 0 ret]

  { if the command is not complete, append a space }
  disc ' '

  ret
end

proc parseblock 0 0
  parsestackblock
  parsestack read
  put disc

  cmdbuffer
  blockbuffer
  do
    covr readc
    copy 9 {tab} ==
    covr 10 {lf} == ||
    covr 13 {cr} == ||
    covr 32 {spc} == ||
    if (checkbufferblock)

    blockbuffer readc

    copy '"' ==
    swap '`' == ||
    covr '\' == &&
    if [
      disc
      swap 1 +
      swap

      covr readc (getescape)
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc

  blockbuffer
  ' '
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  blockret readc 0 ==
  parsestackblock read parsestack read != &&
  if [
    cmdbuffer (cstr.print)
    " Bad Block" (cstr.println)
    parsestackblock read (int.print)
    parsestack read (int.print)
    -1 quit
  ]
  blockret 0 putc disc
  ret
end

proc parsestringblock 0 0 

  { add code }
  1 (addstack)
  `    push str_` (writeout)
  (getstringidx) (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (int.cstr)
  copy (cstr.len) swap
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer 1 +

  { put the first char }
  copy readc
  (int.cstr)
  copy (cstr.len) swap
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer read stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (int.cstr)
    copy (cstr.len) swap
    stringbuffer read stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  disc
  `\n`
  stringbuffer read stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer READSIZE (mem.zero)
  ret
end

proc addccall 0 0
  (writeaddr)
  cproctab read
  cmdbuffer 1 + (map.get)
  procdata.in .
  readc
  copy 0 == if [
    `    call ` (writeout)
    cmdbuffer 1 + copy (cstr.len) swap (writeout)
    (writeoutln)
    disc
    disc
    cproctab read
    cmdbuffer 1 + (map.get)
    procdata.out .
    readc (addstack)
    disc
    {`    push rax\n` (writeout)}
    ret
  ]
  (cprocbuff)
  disc
  `    call ` (writeout)
  cmdbuffer 1 + copy (cstr.len) swap (writeout)
  (writeoutln)

  cproctab read
  cmdbuffer 1 + (map.get)
  procdata.in .
  readc
  cmdbuffer 1 + swap (checkpop)
  cmdbuffer 1 + (map.get)
  procdata.out .
  readc
  (addstack)
  disc
  ret
end

proc addcall 0 0
  proctab read cmdbuffer 1 + (map.in) if [
    (writeaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    cmdbuffer 1 + (map.get)
    procdata.addr . 
    read (int.cstr)
    
    proctab read
    cmdbuffer 1 + (map.get)
    procdata.kind . read
    1 == if (noproc)
    cmdbuffer 1 + (map.get)
    procdata.in . readc
    cmdbuffer 1 + swap (checkpop)
    cmdbuffer 1 + (map.get)
    procdata.out . readc
    (addstack)
    disc

    copy (cstr.len) swap
    (writeout)
    cmdbuffer (cstr.clear) disc
    (writeoutln)

    disc ret
  ] disc
  cproctab read cmdbuffer 1 + (map.in) if [
  (addccall)
  cmdbuffer (cstr.clear) disc
  disc ret
  ]
  disc

  cmdbuffer 1 + '.' tmpbuffer (cstr.split)

  copy "" (cstr.eq) !
  covr classtab read swap (map.in) swap disc
  &&
  if [
    classtab read swap (map.get)
    swap disc
    tmpbuffer (cstr.clear)
    "(" (cstr.cat) 
    swap (cstr.cat)
    "." (cstr.cat)
    swap (cstr.cat)
    disc
    cmdbuffer (cstr.clear)
    tmpbuffer (cstr.copy) disc disc
    (addcall)
    ret
  ]
  disc
  disc
  
  (noproc)

  ret
end

proc addasm 0 0
  cmdbuffer (inner) copy (cstr.len) swap (writeout)
  (writeoutln)
  
  parseflags
  CF_NONE
  put disc

  ret
end

proc parsecmd 0 0
  cmdbuffer copy (cstr.len) +
  READSIZE cmdbuffer (cstr.len) -
  (mem.zero)
  parseflags read CF_ASM == if [
    (addasm)
    cmdbuffer (cstr.clear) disc

    ret
  ]
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' == && if [

    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' == &&
  parseflags read CF_NONE == &&
  if [
    (writeaddr)

    cmdbuffer (inner)
    (parsestringblock)
    disc ret
  ]
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' == && if [
    {string}
    (writeaddr)

    cmdbuffer (inner) disc
    1 (addstack)
    `    push ` (writeout)
    cmdbuffer 1 + (cstr.len) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestringblock)
    ret
  ]
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' == && if [
    (writeaddr)
    cmdbuffer (inner)
    cmdbuffer swap (cstr.copy) disc disc
    cmdbuffer copy (cstr.len) 1 - + 0 putc disc
    (parseblock)
    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '(' == cmdbuffer (cstr.last) ')' == && cmdbuffer (cstr.len) 2 != && if [
    {call}
    cmdbuffer (inner) disc
    (addcall)
    ret
  ]
  cmdbuffer readc 0 != if [
    parseflags read
    cmdbuffer (getopfromname)
    covr CF_NONE == if (getcmdasm)
    covr CF_PROC_OUT == if (addproc)
    covr CF_PROC_IN == if (addproc)
    covr CF_PROC_NAME == if (addproc)
    covr CF_CPROC_OUT == if (addcproc)
    covr CF_CPROC_IN == if (addcproc)
    covr CF_CPROC_NAME == if (addcproc)
    covr CF_CONST_VALUE == if (addconst)
    covr CF_CONST_NAME == if (addconst)
    covr CF_PROP_VALUE == if (addprop)
    covr CF_PROP_NAME == if (addprop)
    covr CF_INC == if (addinc)
    covr CF_LNK == if (addlnk)
    covr CF_VAR == if (addvar)
    covr CF_GVAR_NAME == if (addgvar)
    covr CF_GVAR_VALUE == if (addgvar)
    covr CF_ENUM_CONTENT == if (addenum)
    covr CF_ENUM_START == if (addenumstart)
    covr CF_CLASS == if (setclassname)
    covr CF_OF == if (setclassinherits)
    disc disc
  ]
  cmdbuffer (cstr.clear) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc cmdbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  inputfd read 0 == if ret
  READSIZE READSIZE (heap.zalloc)
  readbuffer swap put read
  inputfd read (os.read) disc
  inputfd read 74 sys1 disc
  do
    readbuffer read
    copy
    cmdbuffer
    do
      covr readc

      linestats read linedata.column .
      copy read 1 + put disc

      copy 10 == if [
        linestats read linedata.column .
        0 put disc
        
        linestats read linedata.line .
        copy read 1 + put disc
      ]

      copy 9 {tab} ==
      covr 10 {lf} == ||
      covr 13 {cr} == ||
      covr 32 {spc} == ||
      if (checkbuffer)
      
      includebuffer readc 0 != if [
        linestats read
        linestats NULL put disc
        inputfd read
        inputfd NULL put disc
        includebuffer (openinput) disc
        includebuffer (cstr.clear) disc
        (parsefile)
        inputfd swap put disc
        linestats swap put disc
      ]

      cmdbuffer readc

      copy '"' ==
      swap '`' == ||
      covr '\' == &&
      if [

        disc
        swap 1 +
        swap

        covr readc (getescape)
      ]

      covr
      swap
      putc disc

      swap
      1 +
      swap
      copy readc 0 != if [
        1 +
      ]

      covr readc 0 !=
    end
    disc
    disc
    readbuffer swap put disc

    readbuffer read (cstr.clear)

    cmdbuffer (cstr.copy) disc disc

    READSIZE cmdbuffer (cstr.len) -
    readbuffer read cmdbuffer (cstr.len) +
    inputfd read (os.read) copy
    readbuffer read + cmdbuffer (cstr.len) + 1 + copy readc 0 != if (cstr.clear) disc

    cmdbuffer READSIZE (mem.zero)
  end

  readbuffer read
  (heap.free)

  linestats read
  (heap.free)

  ret
end

{
args: int
result:

prints a help string
}
proc help 1 0
  copy HELP_VERSION == if [
    "slam compiler v" (cstr.print) (version) (cstr.println)
    disc 0 quit
  ]
  copy HELP_ARGS == if [
    "ERROR: You must compile exactly 1 file"
    (cstr.println)
  ]
  copy HELP_OUTPUT == if [
    "ERROR: Last argument supplied requires a parameter"
    (cstr.println)
  ]
  "slam compiler v" (cstr.print) (version) (cstr.print) " usage:" (cstr.println)
  (cstr.cr)
  "slam [-h]\ [-a]\ [-s]\ [-i include]\ [-o output]\ file" (cstr.println)
  (cstr.cr)
  "-v            shows the version and exits." (cstr.println)
  "-h, --help    shows this help message."     (cstr.println)
  "-i, --include includes a library."          (cstr.println)
  "-s, --silent  disables output text."        (cstr.println)
  "-a, --asm     keeps the assembly code."     (cstr.println)
  "-o, --output  selects the output file."     (cstr.println)
  disc
  
  0 quit

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  cmdlineflags
  cmdlineflags read 1 ||
  put
  disc
  ret
end

proc setasm 0 0
  cmdlineflags
  cmdlineflags read 2 ||
  put
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    outputbuffer
    covr (os.args)
    (cstr.copy)

    disc
    disc
    ret
end

proc setinclude 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    includepath
    covr (os.args)
    (cstr.copy)

    disc
    disc
    ret
end

proc setinput 1 0
  inputbuffer
  readc 0 != if [HELP_ARGS (help)]

  { set input to argument if its not a flag }
  inputbuffer
  covr (os.args)
  (cstr.copy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "--help" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "-v" (cstr.eq)
  if [disc HELP_VERSION (help) 0 ret]
  copy "-i" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--include" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "-o" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "-a" (cstr.eq)
  if [disc (setasm) 0 ret]
  copy "--asm" (cstr.eq)
  if [disc (setasm) 0 ret]
  disc
  1 ret
end

proc nasm 0 0
  cmdtmpbuffer
  "/usr/bin/fasm" put int.SIZE +
  "-m" put int.SIZE +
  "524288" put int.SIZE +
  "temp.fasm" put int.SIZE +
  "temp.o" put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc ld 0 0
  cmdtmpbuffer
  "/usr/bin/ld" put int.SIZE +
  "-dynamic-linker" put int.SIZE +
  "/lib64/ld-linux-x86-64.so.2" put int.SIZE +
  "-o" put int.SIZE +
  outputbuffer put  int.SIZE +
  "-lc" put int.SIZE +
  "-melf_x86_64" put int.SIZE +
  "temp.o" put int.SIZE +
  linkbuffer
  linkcount read 1 + 2 * int.SIZE *
  (mem.copy)

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc
  
  linkcount read 0 != if [
    0
    do
      linkbuffer covr
      2 * 1 + int.SIZE * + read
      (heap.free)
      
      1 + 

      copy linkcount read 1 - <
    end
    disc
  ]

  cmdlineflags read 2 && 0 != if [
    (clean)
    0 quit
    ret
  ]

  cmdtmpbuffer
  "/usr/bin/rm" put int.SIZE +
  "temp.o" put int.SIZE +
  "temp.fasm" put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc initobjs 0 0
  gvartab      256 int.SIZE       TAB_KEY_SIZE (map.new) put disc
  consttab     256 int.SIZE       TAB_KEY_SIZE (map.new) put disc
  proctab      256 procdata.SIZE  TAB_KEY_SIZE (map.new) put disc
  cproctab     256 int.SIZE       TAB_KEY_SIZE (map.new) put disc
  classtab     256 classdata.SIZE TAB_KEY_SIZE (map.new) put disc
  includedtab  256 int.SIZE       256          (map.new) put disc

  identstack   int.SIZE IDENT_CAP (seq.new) put disc

  stringbuffer STRING_BUF_CAP (heap.zalloc) put disc
  
  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [HELP_ARGS (help)]

  (initobjs)
  
  includepath "HOME" (os.env) (cstr.copy) disc
  "/.local/slam/lib" (cstr.cat)
  disc

  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (os.args)

    {try to apply the argument}
    (applyarg) if [copy (setinput)]

    {loop if more args}
    copy argc 1 - <
  end
  disc

  {if no output, put default}
  outputbuffer
  readc 0 ==
  if [outputbuffer "output" (cstr.copy) disc disc]

  {if no input, write help message}
  inputbuffer
  readc 0 ==
  if [HELP_ARGS (help)]

  {open output}
  511
  65
  "temp.fasm"
  -100
  (os.open)
  outputfd swap put disc

  {put the header}
  (asmheader)
  
  {open input} 
  inputbuffer (openinput) disc

  {parse input}
  (parsefile)

  {put the footer}
  (asmfooter)
  
  {assemble}
  (nasm)

  {link}
  (ld)

  (clean)

  0 quit

  ret
end
