{
TABLES:
data structure

tables are a list of sets of data,
each entry is a 15 char terminated string and then a number

TODO: removeTab
TODO: defragTab
}

const TABENTRYLEN 20
const TAB_SIZE 300000

proc gettabetemp 0 1
  var 8

  ret
end

proc gettabtemp 0 1
  var 8

  ret
end

{
args: int[data] ptr[value] ptr[table]
result: ptr[table]

puts data into a table
}
proc putTab 3 1
  (gettabtemp) swap put disc

  copy (strlen) TABENTRYLEN > if [
    "STRING TOO LONG FOR TABLE" (println)
    copy (println)
    disc disc
    quit
  ]

  (gettabetemp) swap put disc

  0 1 -
  do
    1 +
    covr
    covr TABENTRYLEN 8 + * +
    copy read 0 ==
    swap (gettabetemp) read (streq) +
    0 ==
  end
   
  TABENTRYLEN 8 + * covr +
  (gettabetemp) read (strcpy) disc
  TABENTRYLEN +
  (gettabtemp) read put disc
  
  ret
end

{
args: ptr[table]
result:

prints a table
}
proc printTab 1 0
  0
  do
    covr
    covr TABENTRYLEN 8 + * +
    copy (print) ":" (print)
    TABENTRYLEN + read (printint)

    1 +
    covr
    covr TABENTRYLEN 8 + * +
    read
  end
  disc
  disc
  ret
end

{
args: ptr[key] ptr[table]
result: ptr[table]

gets a key from the table
}
proc getTab 2 2
  copy (strlen) TABENTRYLEN > if [
    "STRING TOO LONG FOR TABLE" (println)
    copy (println)
    disc disc
    quit
  ]

  (gettabetemp) swap put disc

  0 1 -
  do
    1 +
    covr
    covr TABENTRYLEN 8 + * copy TAB_SIZE < "TABLE_OVERFLOW" (assert)
    +

    (gettabetemp) read (streq) 0 ==
  end
  TABENTRYLEN 8 + * covr + TABENTRYLEN +
  read
  ret
end

{
args: size ptr[value] ptr[table]
result: int

checks if a value is in a table
}
proc inTab 2 2
  copy (strlen) TABENTRYLEN > if [
    disc
    0
    ret
  ]

  (gettabetemp) swap put disc

  0 1 -
  do
    1 +
    covr
    covr TABENTRYLEN 8 + * copy TAB_SIZE > if [disc disc disc 0 ret]
    +

    (gettabetemp) read (streq) 0 ==
  end
  disc

  1
  ret
end

{
args: ptr[table]
result: ptr[table]

defragments a table
}
{TODO}
