const NULL 0

proc tmpidx 0 1
  var 8

  ret
end

proc inctmpidx 0 0
  (tmpidx) 
  (tmpidx) read
  1 +
  putc disc

  ret
end

proc gettmp 0 1
  var 32 30 +
  (tmpidx) read -

  ret
end

proc strint 1 1
  do
    10 /
    48 +
    (gettmp)
    swap
    putc disc
    (inctmpidx)
    
    copy 0 !=
  end
  disc
  (gettmp) 1 +
  
  (tmpidx) 0 putc disc
  ret
end


{
args: pointer
result: 

prints a string
}
proc print 1 0 
  copy 
  read
  0 == if [disc ret]
  do
    { read the current char }
    copy
    read
    dump
    
    { increase the address }
    1 +

    { read the next address }
    copy
    read
    
    { convert to a byte }
    255 &&
    0 !=
  end
  disc
  ret
end

{
args:
result:

prints a new line
}
proc endl 0 0
  { print new line }
  10
  dump
  ret
end

{
prints
}
proc println 1 0
  (print)
  (endl)
  ret
end

{
args: ptr int
result: ptr

converts a int to a string
}
proc printint 1 0
  do
    10 /
    48 +
    (gettmp)
    swap
    putc disc
    (inctmpidx)
    
    copy 0 !=
  end
  disc
  (gettmp) 1 + (print) (endl)
  
  (tmpidx) 0 putc disc
  ret
end

{
args: pointer int
result:

if int is 0 quit and print message
}
proc assert 2 0
  swap
  if [disc ret]
  (println)
  quit
  ret
end

{
args: int
result: pointer

gets the nth arguent from the command line
}
proc args 1 1
  copy argc - 0 < 0 == if [copy (strint) (print)]
  copy argc - 0 < "Bad arg" (assert)
  8 * 
  argv +

  read
  ret
end

{
args: pointer pointer
result: 

copy a string from a pointer to another
}
proc strcpy 2 2
  covr
  covr
  do
    covr
    covr
    read 255 &&

    putc
    disc

    swap 1 +
    swap 1 +
    copy read 255 && 0 !=
  end
  0
  putc
  disc
  disc
  ret
end

{
args: pointer pointer
result: int

compares strings, returns 1 if they are not equal
}
proc streq 2 1
  covr read 255 &&
  covr read 255 &&
  != if [disc disc 0 ret]
  1 -
  swap
  1 -
  do
    1 +
    swap
    1 +
    covr read 255 && 
    covr read 255 &&
    covr 0 ==
    covr 0 ==
    &&
    if [
      disc
      disc
      disc
      disc
      1
      ret
      ]
    covr 0 ==
    covr 0 ==
    !=
    if [
      disc
      disc
      disc
      disc
      0
      ret
    ]
    ==
  end
  disc
  disc
  0
  ret
end

{
args: pointer int int
result: int

opens a file
}
proc open 4 1
  257
  sys4

  copy 0 < 1 != "Error opening file" (assert)
  ret
end

{
args: int
result:

closes a file
}
proc close 1 0
  3
  sys1

  0 < 1 != "Error closing file" (assert)
  ret
end

{
args: int ptr
result: int

writes data to a file
}
proc write 3 0
  1
  sys3

  0 < 1 != "Error writing file" (assert)
  ret
end

{
args: int ptr
result: int

writes data to a file
}
proc read 3 1
  0
  sys3
  
  copy 0 < 1 != "Error reading file" (assert)
  ret
end


{
args: ptr int
result: ptr

converts a int to a hex string
}
proc printinthex 1 0
  do
    16 /
    copy 9 > if [64 +]
    copy 10 < if [48 +]
    (gettmp)
    swap
    putc disc
    (inctmpidx)
    
    copy 0 !=
  end
  disc

  (gettmp)
  120 {x}
  putc disc
  (inctmpidx)

  (gettmp)
  48 {0}
  putc disc
  (inctmpidx)

  (gettmp) 1 + (print)
  (tmpidx) 0 putc disc
  (endl)
  ret
end

proc strlen 1 1
  copy
  do
    1 +

    copy read 255 &&
  end
  covr -
  swap disc
  ret
end

{
}
proc last 1 1
  1 -
  do
    1 +
    copy read 255 &&
    0 !=
  end
  1 -
  read 255 &&

  ret
end

proc clearbuf 1 1
  copy read 255 && 0 == if [ret]
  copy
  do
    copy
    0
    putc
    disc

    1 +
    copy read 255 &&
  end
  disc

  ret
end

{
args: ptr[string]
returns: int[val]

returns 1 if the string is a number
}
proc alphanum 1 1
  do
    copy read 255 &&
    copy 48 <
    covr 58 >
    + 0 != if [disc disc 0 ret]
    disc

    1 +
    copy read 255 &&
    0 !=
  end
  disc
  1
  ret
end

{
args: ptr[string]
returns: int[value]

returns the value of a int
}
proc tonum 1 1
  copy (alphanum) 0 == if [copy (println)]
  copy (alphanum) "String is not a number" (assert)
  
  0
  do
    10 *
    covr read 255 &&
    48 - +
    
    swap 1 +
    swap

    covr read 255 &&
  end
  swap disc

  ret
end

proc fork 0 1
  57 sys0

  ret
end

proc deverr 0 0
  "ERROR: cant open /dev/null" (println)

  quit
  ret
end

proc waitsig 0 1
  var 8

  ret
end

{
args: ptr[stringList]
returns:

runs a command
}
proc execcmd 1 0
  (fork)
  copy 0 == if [
    {child}

    1

    0
    0
    "/dev/null"
    0 100 -
    257 sys4
    
    copy 0 < if (deverr)
   
    33 sys2 0 < if (deverr)

    covr envp swap copy read
  
    59 sys3 disc
    disc disc
    quit
  ]
  copy 0 != if [
    {parent}

    NULL
    0

    (waitsig)

    0 1 -
    61
    sys4 disc
  ]
  disc
  disc
  ret
end

{
args: ptr[stringList]
returns: 

prints a command then runs it
}
proc execcmdecho 1 0
  "[CMD] " (print)
  copy
  do
    copy read (print)
    8 +
     
    copy read NULL !=
    copy if [" " (print)]
  end
  disc
  (endl)

  (execcmd)

  ret
end
