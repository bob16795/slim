class arr
  prop Size int.SIZE
  prop Elem int.SIZE
  prop pData int.SIZE

end

class seq
  prop Size int.SIZE
  prop Max  int.SIZE
  prop Elem int.SIZE
  prop Data 0

  gvar curtemp int.SIZE
  gvar elemtemp 32
  
  {
  args: int[maxSize] int[elemSize] ptr[seqay]
  returns: ptr[seqay]

  Creates an seqay
  }
  proc new 2 1
    copy (heap.alloc) seq.curtemp swap put disc
    seq.elemtemp swap put disc

    seq.curtemp read
    seq.Elem .
    swap put disc
    
    seq.curtemp read
    seq.Max .

    seq.elemtemp read
    seq.Data -

    put disc
    
    seq.curtemp read
    seq.Size .
    0
    put disc
  
    seq.curtemp read
    ret
  end
  
  {
  args: int[size] ptr[seqay]
  returns: ptr[seqay]
  }
  proc setlen 2 1
    swap seq.curtemp swap put disc

    seq.curtemp read
    seq.Size .

    swap put disc
    
    seq.curtemp read
    ret
  end
  
  {
  args: ptr[seqay]
  returns: int[size] ptr[seqay]
  }
  proc len 1 2
    copy
    seq.Size . read
  
    ret
  end
  
  {
  args: ptr[data] ptr[seqay]
  returs: ptr[seqay]
  }
  proc pushint 2 1
    seq.elemtemp swap put disc
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
  
    1 + *
    
    seq.curtemp read
    seq.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
    *
    
    seq.curtemp read
    seq.Data .
    +
    
    seq.elemtemp read
    put disc
    
    seq.curtemp read
    seq.Size .

    copy read
    1 +
    put
  
    ret
  end
  
  {
  args: ptr[data] ptr[seqay]
  returs: ptr[seqay]
  }
  proc push 2 1
    seq.elemtemp swap put disc
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
  
    1 + *
    
    seq.curtemp read
    seq.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    seq.curtemp read
    seq.Elem . read
    
    seq.curtemp read
    seq.Size . read
    *
    
    seq.curtemp read
    seq.Data .
    +
    
    seq.elemtemp read
    
    seq.curtemp read
    seq.Elem . read
    (mem.copy)
    
    seq.curtemp read
    seq.Size .

    copy read
    1 +
    put
  
    ret
  end

  proc extend 2 1
    swap seq.curtemp swap put disc

    seq.curtemp read
    seq.Size . read +
    
    seq.curtemp read
    seq.Size . swap

    put disc
  
    seq.curtemp read

    ret
  end
  
  proc getaddr 2 2 
    swap seq.curtemp swap put disc
  
    copy
    seq.curtemp read
    seq.Size . read
    > if [ "INDEX ERROR" (cstr.println) disc -1 quit ]
    
    seq.curtemp read
    seq.Elem . read
    *

    seq.curtemp read
    seq.Data .
    +

    seq.curtemp read
    swap

    ret
  end
  
  proc print 1 0
    seq.curtemp swap put disc
    "[" (cstr.print)
    seq.curtemp read
    seq.Data . (cstr.print)
    
    seq.curtemp read
    seq.Size . read

    1 == if [
      "]" (cstr.println)
      ret
    ]

    0
    do
      ", " (cstr.print)

      1 +
      copy
      seq.curtemp read
      seq.Elem . read
      *
    
      seq.curtemp read
      seq.Data .
      + (cstr.print)
 
      copy
      seq.curtemp read
      seq.Size . read
      1 - <
    end
    disc

    "]" (cstr.println)
    
    ret
  end

  proc popaddr 1 2
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Size . read

    1 -

    seq.curtemp read
    seq.Elem . read
    *
    
    seq.curtemp read
    seq.Data . +

    seq.elemtemp
    
    swap put disc

    seq.curtemp read
    seq.Size .

    copy read
    1 -
    put disc

    seq.curtemp read
    seq.elemtemp read
    ret
  end

  proc pop 1 2
    seq.curtemp swap put disc
    
    seq.curtemp read
    seq.Size . read

    1 -

    seq.curtemp read
    seq.Elem . read
    *
    
    seq.curtemp read
    seq.Data . + copy

    seq.elemtemp

    swap

    seq.curtemp read
    seq.Elem . read
    (mem.copy) 

    
    seq.curtemp read
    seq.Elem . read
    (mem.zero)

    seq.curtemp read
    seq.Size .

    copy read
    1 -
    put disc

    seq.curtemp read
    seq.elemtemp
    ret
  end

  proc free 1 0
    (heap.free)
  
    ret
  end

  {TODO: proc in 2 2}
end
