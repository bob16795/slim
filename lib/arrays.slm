class arr
  prop Size int.SIZE
  prop Max  int.SIZE
  prop Elem int.SIZE
  prop Data 0

  gvar curtemp int.SIZE
  gvar elemtemp 32
  
  {
  args: int[maxSize] int[elemSize] ptr[array]
  returns: ptr[array]

  Creates an array
  }
  proc new 3 1
    arr.elemtemp swap put disc
    swap arr.curtemp swap put disc
   
    arr.curtemp read
    arr.Elem .
    swap
    put disc
    
    arr.curtemp read
    arr.Max .

    arr.elemtemp read
    arr.Data -

    put disc
    
    arr.curtemp read
    arr.Size .
    0
    put disc
  
    arr.curtemp read
    ret
  end
  
  {
  args: int[size] ptr[array]
  returns: ptr[array]
  }
  proc setlen 2 1
    swap arr.curtemp swap put disc

    arr.curtemp read
    arr.Size .

    swap put disc
    
    arr.curtemp read
    ret
  end
  
  {
  args: ptr[array]
  returns: int[size] ptr[array]
  }
  proc len 1 2
    copy
    arr.Size . read
  
    ret
  end
  
  {
  args: ptr[data] ptr[array]
  returs: ptr[array]
  }
  proc pushint 2 1
    arr.elemtemp swap put disc
    arr.curtemp swap put disc
    
    arr.curtemp read
    arr.Elem . read
    
    arr.curtemp read
    arr.Size . read
  
    1 + *
    
    arr.curtemp read
    arr.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    arr.curtemp read
    arr.Elem . read
    
    arr.curtemp read
    arr.Size . read
    *
    
    arr.curtemp read
    arr.Data .
    +
    
    arr.elemtemp read
    put disc
    
    arr.curtemp read
    arr.Size .

    copy read
    1 +
    put
  
    ret
  end
  
  {
  args: ptr[data] ptr[array]
  returs: ptr[array]
  }
  proc push 2 1
    arr.elemtemp swap put disc
    arr.curtemp swap put disc
    
    arr.curtemp read
    arr.Elem . read
    
    arr.curtemp read
    arr.Size . read
  
    1 + *
    
    arr.curtemp read
    arr.Max . read
    > if ["ARRAY OVERFLOW" (cstr.println) -1 quit]
    
    arr.curtemp read
    arr.Elem . read
    
    arr.curtemp read
    arr.Size . read
    *
    
    arr.curtemp read
    arr.Data .
    +
    
    arr.elemtemp read
    
    arr.curtemp read
    arr.Elem . read
    (mem.copy)
    
    arr.curtemp read
    arr.Size .

    copy read
    1 +
    put
  
    ret
  end

  proc extend 2 1
    swap arr.curtemp swap put disc

    arr.curtemp read
    arr.Size . read +
    
    arr.curtemp read
    arr.Size . swap

    put disc
  
    arr.curtemp read

    ret
  end
  
  proc getaddr 2 2 
    swap arr.curtemp swap put disc
  
    copy
    arr.curtemp read
    arr.Size . read
    > if [ "INDEX ERROR" (cstr.println) disc -1 quit ]
    
    arr.curtemp read
    arr.Elem . read
    *

    arr.curtemp read
    arr.Data .
    +

    arr.curtemp read
    swap

    ret
  end
  
  proc print 1 0
    arr.curtemp swap put disc
    "[" (cstr.print)
    arr.curtemp read
    arr.Data . (cstr.print)
    
    arr.curtemp read
    arr.Size . read

    1 == if [
      "]" (cstr.println)
      ret
    ]

    0
    do
      ", " (cstr.print)

      1 +
      copy
      arr.curtemp read
      arr.Elem . read
      *
    
      arr.curtemp read
      arr.Data .
      + (cstr.print)
 
      copy
      arr.curtemp read
      arr.Size . read
      1 - <
    end
    disc

    "]" (cstr.println)
    
    ret
  end

  proc popaddr 1 2
    arr.curtemp swap put disc
    
    arr.curtemp read
    arr.Size . read

    1 -

    arr.curtemp read
    arr.Elem . read
    *
    
    arr.curtemp read
    arr.Data . +

    arr.elemtemp
    
    swap put disc

    arr.curtemp read
    arr.Size .

    copy read
    1 -
    put disc

    arr.curtemp read
    arr.elemtemp read
    ret
  end

  proc pop 1 2
    arr.curtemp swap put disc
    
    arr.curtemp read
    arr.Size . read

    1 -

    arr.curtemp read
    arr.Elem . read
    *
    
    arr.curtemp read
    arr.Data . + copy

    arr.elemtemp

    swap

    arr.curtemp read
    arr.Elem . read
    (mem.copy) 

    
    arr.curtemp read
    arr.Elem . read
    (mem.zero)

    arr.curtemp read
    arr.Size .

    copy read
    1 -
    put disc

    arr.curtemp read
    arr.elemtemp
    ret
  end

  {TODO: proc in 2 2}
end
