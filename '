inc lib/stdlib.slm

{The Slim Compiler, written in Slim}

const OP_BAD   255
const OP_NOP   0
const OP_PUSH  1
const OP_SUB   2
const OP_MUL   3
const OP_PLUS  4
const OP_SWAP  5
const OP_DUMP  6
const OP_COPY  7 
const OP_COVR  8
const OP_GPTR  9 
const OP_READ  10
const OP_PUTC  11
const OP_DISC  12
const OP_ARGV  13
const OP_ARGC  14
const OP_PUSHP 15
const OP_CALLS 16
const OP_MULTI 17
const OP_CONST 18
const OP_CALL  19
const OP_PROC  20
const OP_RET   21
const OP_QUIT  22
const OP_LOCX  23
const OP_JUMPX 24
const OP_JUMP  25
const OP_IF    26
const OP_JNZ   27
const OP_GETP  28
const OP_CYCL  29
const OP_NQ    30
const OP_EQ    31
const OP_LT    32
const OP_GT    33
const OP_AND   34
const OP_SYS0  35
const OP_SYS1  36
const OP_SYS2  37
const OP_SYS3  38
const OP_SYS4  39
const OP_SYS5  40
const OP_SYS6  41

proc getnameop 1 1
  copy "nop"   (streq) if [disc OP_NOP]
  copy "-"     (streq) if [disc OP_SUB]  
  copy "*"     (streq) if [disc OP_MUL]  
  copy "+"     (streq) if [disc OP_PLUS]
  copy "swap"  (streq) if [disc OP_SWAP]
  copy "dump"  (streq) if [disc OP_DUMP] 
  copy "copy"  (streq) if [disc OP_COPY] 
  copy "covr"  (streq) if [disc OP_COVR] 
  copy "var"   (streq) if [disc OP_GPTR] 
  copy "read"  (streq) if [disc OP_READ] 
  copy "putc"  (streq) if [disc OP_PUTC] 
  copy "disc"  (streq) if [disc OP_DISC] 
  copy "argv"  (streq) if [disc OP_ARGV] 
  copy "argc"  (streq) if [disc OP_ARGC] 
  copy "()"    (streq) if [disc OP_CALLS] 
  copy "const" (streq) if [disc OP_CONST]
  copy "proc"  (streq) if [disc OP_PROC]
  copy "ret"   (streq) if [disc OP_RET] 
  copy "quit"  (streq) if [disc OP_QUIT]  
  copy "if"    (streq) if [disc OP_IF] 
  copy "cycl"  (streq) if [disc OP_CYCL] 
  copy "!="    (streq) if [disc OP_NQ] 
  copy "=="    (streq) if [disc OP_EQ]   
  copy "<"     (streq) if [disc OP_LT]   
  copy ">"     (streq) if [disc OP_GT]   
  copy "&&"    (streq) if [disc OP_AND]  
  copy "sys0"  (streq) if [disc OP_SYS0]
  copy "sys1"  (streq) if [disc OP_SYS1]  
  copy "sys2"  (streq) if [disc OP_SYS2]  
  copy "sys3"  (streq) if [disc OP_SYS3]  
  copy "sys4"  (streq) if [disc OP_SYS4]  
  copy "sys5"  (streq) if [disc OP_SYS5]  
  copy "sys6"  (streq) if [disc OP_SYS6]  

  ret
end

proc getopname 1 1
  "bad"
  copy OP_NOP   == if [disc "nop"]
  copy OP_PUSH  == if []
  copy OP_SUB   == if []
  copy OP_MUL   == if []
  copy OP_PLUS  == if []
  copy OP_SWAP  == if []
  copy OP_DUMP  == if []
  copy OP_COPY  == if []
  copy OP_COVR  == if []
  copy OP_GPTR  == if []
  copy OP_READ  == if []
  copy OP_PUTC  == if []
  copy OP_DISC  == if []
  copy OP_ARGV  == if []
  copy OP_ARGC  == if []
  copy OP_PUSHP == if []
  copy OP_CALLS == if []
  copy OP_MULTI == if []
  copy OP_CONST == if []
  copy OP_CALL  == if []
  copy OP_PROC  == if []
  copy OP_RET   == if []
  copy OP_QUIT  == if []
  copy OP_LOCX  == if []
  copy OP_JUMPX == if []
  copy OP_JUMP  == if []
  copy OP_IF    == if []
  copy OP_JNZ   == if []
  copy OP_GETP  == if []
  copy OP_CYCL  == if []
  copy OP_NQ    == if []
  copy OP_EQ    == if []
  copy OP_LT    == if []
  copy OP_GT    == if []
  copy OP_AND   == if []
  copy OP_SYS0  == if []
  copy OP_SYS1  == if []
  copy OP_SYS2  == if []
  copy OP_SYS3  == if []
  copy OP_SYS4  == if []
  copy OP_SYS5  == if []
  copy OP_SYS6  == if []
  swap disc
  ret
end

proc getoutput 0 1
  var 128
  ret
end

proc getoutputfd 0 1
  var 8
  ret
end

proc getinputfd 0 1
  var 8
  ret
end

proc getinput 0 1
  var 128
  ret
end

proc getsilent 0 1
  var 8
  ret
end

proc getreadbuffer 0 1
  var 128
  ret
end

proc getcmdbuffer 0 1
  var 128
  ret
end

proc clearbuf 1 1
  copy "" (streq) if [ret]
  copy
  do
    copy
    0
    putc
    disc

    1 +
    copy read
  end
  disc

  ret
end

proc parsecmd 0 0
  (getcmdbuffer) "" (streq) 0 == if [
    (getcmdbuffer) (println)
  ]
  (getcmdbuffer) (clearbuf) disc
  ret
end


proc last 1 1
  do
    1 +
    copy read 255 &&
    0 !=
  end
  1 -
  read 255 &&

  ret
end

proc checkcmd 0 1
  {""}
  (getcmdbuffer) read 255 && 34 == (getcmdbuffer) (last) 34 != && 0 ==
  {[]}
  (getcmdbuffer) read 255 && 91 == (getcmdbuffer) (last) 93 != && 0 == &&
  {{}}
  (getcmdbuffer) read 255 && 123 == (getcmdbuffer) (last) 125 != && 0 == &&
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 1
  30 (getreadbuffer)
  (getinputfd) read (read) disc
  (getreadbuffer)
  (getcmdbuffer)
  do
    do
      covr
      read 255 &&
      copy 9 {tab} ==
      covr 10 {newline} == +
      covr 13 {newline} == +
      covr 32 {space} == +
      0 !=
      if [
          { if the command is complete, get the buffer }
          (checkcmd) if [(parsecmd) disc disc (getcmdbuffer) 1 - 0]\
          
          { if the command is not complete, append a space }
          (checkcmd) 0 == if [disc 32]\

          { if there are 2 spaces, dont add a space }
          copy 32 ==
          (getcmdbuffer) (last) 32 ==
          && if [disc 1 - 0]\
      ]
      covr
      swap
      copy 0 != if [putc copy]
      disc
      disc

      swap 1 +
      swap 1 +

      covr read 255 && 0 !=
    end
    swap
    disc
    (getreadbuffer) (clearbuf)
    swap
    31 (getreadbuffer)
    (getinputfd) read (read)
  end
  disc
  disc
  0
  ret
end

{
args: int 
result: 

prints a help string
}
proc help 1 0
  "INVALID HELP ID"
  covr 1 == if [
    disc 
    "Help"
  ] covr 2 == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr 3 == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (println)
  "slim compiler usage:"                       (println)
  (endl)
  "slim [-h]\ [-s]\ [-o output]\ file"     (println)
  (endl)
  "-h, --help\t\tshows this help message." (println)
  "-s, --silent\tdisables output text."    (println)
  "-o, --output\tselects the output file." (println)
  (endl)
  disc
  quit

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  (getsilent)
  1
  putc
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [3 (help)]
    
    (getoutput)
    covr (args)
    (strcpy)

    disc
    disc
    ret
end

{
args: ptr int 
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (streq)
  if [disc 1 (help) 0 ret]
  copy "--help" (streq)
  if [disc 1 (help) 0 ret]
  copy "-o" (streq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (streq) 
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (streq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (streq)
  if [disc (setsilent) 0 ret]
  disc
  1 ret
end

proc writeout 2 0
  (getoutputfd) read (write)

  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [2 (help)]
  
  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (args)

    (applyarg) if [
      (getinput)
      read 255 && 0 != if [2 (help)]\

      { set input to argument if its not a flag }
      (getinput)
      covr (args)
      (strcpy)

      { clean that }
      disc
      disc
    ]
    copy argc 1 - <
  end
  disc

  (getoutput) 
  read 255 && 0 ==
  if [(getoutput) "output" (strcpy)]

  (getinput)
  read 255 && 0 ==
  if [2 (help)]
  
  {open input}
  448 0 (getinput) (open)
  (getinputfd) swap putc disc
   
  {open output}
  448 66 "temp.asm" (open)
  (getoutputfd) swap putc disc
  
  {parse input}
  (parsefile) disc 

  {close output}
  (getoutputfd) read (close)
  
  {close input}
  (getinputfd) read (close)

  ret
end
