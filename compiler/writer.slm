inc "stdlib/os.slm"

class writer
  var fd int.SIZE
  var strings int.SIZE
  var tmem int.SIZE
  var tmpstr int.SIZE

  proc write 1 0
    copy (cstr.len) swap writer.fd read (os.write)

    ret
  end

  proc cr 0 0
    "\n" (writer.write)

    ret
  end

  proc writeln 1 0
    (writer.write)
    (writer.cr)

    ret
  end
  
  var len int.SIZE

  proc getlen 1 1
    writer.tmpstr swap put disc

    0
    do
      writer.tmpstr read str.data . covr + readc
      '\' != if [
        writer.len copy
        read 1 +
        put disc
      ]
      1 +
      copy writer.tmpstr read str.size . read 1 - <
    end
    disc
    
    writer.len read

    ret
  end

  proc addstr 1 0
    writer.tmpstr swap put disc

    writer.strings read (llist.len) 0 == if [
      writer.strings read 
      writer.tmpstr read (llist.append) disc

      writer.strings read (llist.len) 1 -
      (int.cstr) (writer.write)
      ret
    ]

    -1
    do
      1 +
      writer.strings read 
      covr (llist.ptrat) read

      writer.tmpstr read read (str.seq) !
      covr writer.strings read (llist.len) 1 - != &&
    end

    writer.strings read (llist.len) 1 - covr == if [
      writer.strings read 
      writer.tmpstr read (llist.append) disc

      writer.strings read (llist.len) 1 -
      (int.cstr) (writer.write)
      disc
      ret
    ]

    (int.cstr) (writer.write)

    ret
  end

  proc header 0 0
    "format ELF64\n" (writer.write)
    "section '.text' executable\n" (writer.write)
    "public _start\n\n" (writer.write)
    "print:\n" (writer.write)
    "    mov r10, rsp\n" (writer.write)
    "    sub rsp, 8\n" (writer.write)
    "    mov [rsp], al\n" (writer.write)
    "    mov edi, 1\n" (writer.write)
    "    mov rsi, rsp\n" (writer.write)
    "    mov edx, 1\n" (writer.write)
    "    mov eax, 1\n" (writer.write)
    "    syscall\n" (writer.write)
    "    mov rsp, r10\n" (writer.write)
    "    ret\n" (writer.write)

    ret
  end

  var escape int.SIZE

  proc getescape 1 1
    copy 'n' == if [ disc 10 ret ]
    copy 't' == if [ disc 9 ret ]

    ret
  end

  proc writestring 1 0
    writer.tmpstr swap put disc
    0
    do
      writer.tmpstr read str.data . covr + readc
      writer.escape read if [
        (writer.getescape)
      ]
      writer.escape bool.true put disc
      copy '\' != if [
        writer.escape bool.false put disc
        (int.cstr) (writer.write)

        ", " (writer.write) 0
      ]
      disc
      1 +
      copy writer.tmpstr read str.size . read 1 - <
    end
    disc

    ret
  end

  proc writestrings 0 0
    writer.strings read (llist.len) 0 == if [ ret ]

    0
    do
      writer.strings read 
      covr (llist.ptrat)
      copy NULL != if [
        "str_" (writer.write)
        covr (int.cstr) (writer.write)
        ": db " (writer.write)
        copy read (writer.writestring)
        "0" (writer.writeln)
      ]
      disc
      
      1 +

      writer.strings read (llist.len) covr !=
    end
    disc

    ret
  end

  proc footer 0 0
    "_start:\n" (writer.write)
    "    mov qword [args_ptr], rsp\n" (writer.write)
    "    mov qword [ret_stack_rsp], ret_stack\n" (writer.write)
    "    mov rax, [ret_stack_rsp] \n" (writer.write)
    "    mov qword [rax], quit\n" (writer.write)
    "    jmp proc_main\n" (writer.write)
    "quit:\n" (writer.write)
    "    mov rax, 60\n" (writer.write)
    "    mov rdi, 0\n" (writer.write)
    "    syscall\n" (writer.write)
    "section '.data'\n" (writer.write)

    (writer.writestrings)

    "section '.bss'\n" (writer.write)
    "args_ptr: rq 1\n" (writer.write)
    "ret_stack_rsp: rq 1\n" (writer.write)
    "ret_stack: rb 65536\n" (writer.write)
    "mem: rb " (writer.write)
    writer.tmem read (int.cstr) (writer.writeln)

    ret
  end

  proc open 1 0
    511 swap
    65 swap
    -100
    (os.open)
    writer.fd swap put disc

    writer.strings int.SIZE (llist.new) put disc
    ret
  end
end
