inc "compiler/assembler.slh"

class assembler
  {
    ARGS: out in node self
    RETS: self
  }
  oper proc new 0 1
    var result 8

    result assembler.SIZE heap.zalloc put disc

    result read assembler.includedtab . 256 1 assembler.MAX_NAME_SIZE map.new put disc
    result read assembler.consttab . 256 8 assembler.MAX_NAME_SIZE map.new put disc
    result read assembler.proctab . 256 asmprocdata.SIZE assembler.MAX_NAME_SIZE map.new put disc
    result read assembler.lvartab . 256 8 assembler.MAX_NAME_SIZE map.new put disc
    result read assembler.vartab . 256 8 assembler.MAX_NAME_SIZE map.new put disc
    result read assembler.procname . str.new put disc

    result read

    ret
  end

  {
    ARGS: out in node self
    RETS: self
  }
  oper proc internalname 1 1
    var start 8
    var name 8
    var char 2

    start swap put disc
    name str.new put disc

    char 1 + 0 putc disc

    0
    do
      copy start read
      str.data . + readc
      copy char swap putc disc
      copy '/' == if
        name read
        "slash" str.catc
        name swap put disc
        disc 0
      end
      copy '%' == if
        name read
        "perc" str.catc
        name swap put disc
        disc 0
      end
      copy '.' == if
        name read
        "_" str.catc
        name swap put disc
        disc 0
      end
      copy 0 != if
        name read
        char str.catc
        name swap put disc
        disc 0
      end
      disc

      1 +

      copy
      start read
      str.size @ <
      covr 1000 < &&
    end
    disc

    name read str.data .
    name read str.size @ +
    0 putc disc

    name read

    ret
  end

  {
    ARGS: name self
    RETS: value
  }
  oper proc getconst 3 1
    var name 8
    var node 8
    var nodep 8
    var self 8
    var tmpname 8

    name swap put disc
    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    tmpname assembler.MAX_NAME_SIZE heap.zalloc put disc

    tmpname read name read cstr.cpy disc disc

    self read assembler.consttab @
    tmpname read map.in swap disc ! if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      "Undefined const"

      error.new
      error.eval
    end

    self read assembler.consttab @
    tmpname read map.getptr read
    swap disc

    tmpname read heap.free

    ret
  end

  {
    ARGS: out in node self
    RETS:
  }
  oper proc updatestack 4 0
    var self 8
    var node 8
    var nodep 8
    var out 8
    var in 8

    out swap put disc
    in swap put disc
    nodep swap put disc
    self swap put disc

    nodep read NULL != if
      node nodep read slmnode.data @ put disc
    end

    self read assembler.depth @
    in read -
    self read assembler.depth . swap put disc

    self read assembler.depth @ 0 < if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDERFLOW
      "Stack Underflow"

      error.new
      error.eval
    end

    self read assembler.depth @
    out read +
    self read assembler.depth . swap put disc

    ret
  end

  {
    ARGS: proc self
    RETS: self
  }
  oper proc addproctab 2 1
    var name 8
    var self 8

    name swap put disc
    self swap put disc

    name read
    self read assembler.parentclass @ str.data .
    copy cstr.len
    mem.eq
    ! if
      self read

      ret
    end

    "proc_" writer.write
    self read assembler.classname @ str.data . writer.write
    name read
    do
      1 +
      copy readc '_' !=
    end
    writer.write

    ":\n    jmp proc_" writer.write

    name read writer.write
    "\n" writer.write

    self read

    ret
  end

  {
    ARGS: wordnode self
    RETS: success
  }
  oper proc addwordproc 3 0
    var self 8
    var node 8
    var name 8
    var nodep 8

    nodep swap put disc
    self swap put disc
    name swap put disc

    node nodep read slmnode.data @ put disc

    self read assembler.proctab @
    name read
    map.getptr swap disc
    asmprocdata.kind @ 10 /% swap disc PNK_PUSH == if
      self read nodep read
      0 1 assembler.updatestack

      "    push proc_" writer.write
      name read writer.write
      "\n" writer.write

      ret
    end

    self read nodep read

    self read assembler.proctab @
    name read
    map.getptr swap disc
    copy asmprocdata.in @
    swap asmprocdata.out @
    assembler.updatestack

    ".blockstart_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write
    "    mov rax, [ret_stack_rsp]\n" writer.write
    "    add rax, 16\n" writer.write
    "    mov rbx, [loc_stack_rsp]\n" writer.write
    "    mov qword [rax - 8], rbx\n" writer.write
    "    mov qword [ret_stack_rsp], rax\n" writer.write
    "    mov qword [rax], .blockend_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    "\n" writer.write
    "    jmp proc_" writer.write
    name read writer.write
    "\n" writer.write
    ".blockend_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write

    self read assembler.lastblock .
    copy read 1 +
    put disc

    ret
  end

  {
    ARGS: self node 
    RETS: self node
  }
  oper proc addprochead 2 2
    var self 8
    var node 8
    var nametmp 8

    nametmp assembler.MAX_NAME_SIZE heap.zalloc put disc
    node swap put disc
    self swap put disc

    self read assembler.procname @ str.size . 0 put disc

    self read assembler.procdata . asmprocdata.kind .
    node read blockdata.blockmisc @
    put disc

    self read assembler.lastblock . 0 put disc

    node read blockdata.blockin @ str.data . cstr.int
    self read assembler.procdata . asmprocdata.in .
    covr
    put disc
    self read assembler.depth .
    swap
    put disc

    node read blockdata.blockout @ str.data . cstr.int
    self read assembler.procdata . asmprocdata.out .
    covr
    put disc
    self read assembler.procout .
    swap
    put disc

    node read blockdata.blockmisc @
    copy PNK_OHEAD <
    swap PNK_PHEAD > || if
      "proc_" writer.write
    end

    node read blockdata.blockmisc @
    copy PNK_OUNSAFE < !
    swap PNK_PUNSAFE > ! && if
      self read assembler.procout . 255 put disc
    end

    self read assembler.classname @
    copy NULL != if
      assembler.internalname str.data .
      self read assembler.procname @
      swap str.catc
      "_" str.catc
      self read assembler.procname . swap put disc
      0
    end
    disc

    node read blockdata.blockname @
    assembler.internalname str.data .

    self read assembler.procname @ 
    swap str.catc
    self read assembler.procname . swap put disc

    self read assembler.procname @
    copy str.data .
    swap str.size @ +
    0 putc disc

    nametmp read
    self read assembler.procname @ str.data .
    self read assembler.procname @ str.size @
    mem.cpy

    self read assembler.proctab @
    nametmp read
    self read assembler.procdata .
    map.append disc

    node read blockdata.blockmisc @
    copy PNK_OHEAD <
    swap PNK_PHEAD > || ! if
      "; head" writer.write
    end
    nametmp read writer.write
    ":\n" writer.write

    self read
    node read

    ret
  end

  {
    ARGS: self name 
    RETS: fullname
  }
  oper proc getfullname 2 1
    var string 8
    var name 8
    var self 8

    name swap put disc
    self swap put disc

    string assembler.MAX_NAME_SIZE heap.zalloc put disc

    string read
    self read assembler.classname @
    copy NULL != if
      str.data . cstr.cpy

      string read
      "_" cstr.cat
      disc
    end
    disc disc

    string read
    name read
    cstr.cat
    disc

    string read

    ret
  end

  {
    ARGS: self node
    RETS:
  }
  oper proc visitof 2 0
    var nodep 8
    var node 8
    var self 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNIMP
    "Inheritance is unimplemented as of now"

    error.new
    error.eval
    
    ret
  end

  {
    ARGS: self word
    RETS:
  }
  oper proc visitword 2 0
    var word 8
    var self 8
    var string 8
    var intern 8
    var nametmp 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    word node read constdata.constvalue @ str.data . put disc

    nametmp assembler.MAX_NAME_SIZE heap.zalloc put disc

    string str.new put disc
    string read
    word read cstr.len
    word read
    str.sput disc

    intern
    string read
    assembler.internalname
    put disc

    nametmp read
    intern read str.data .
    intern read str.size @
    mem.cpy

    nametmp read

    self read assembler.consttab @ covr map.in if
      self read NULL
      0 1 assembler.updatestack

      nametmp read
      map.getptr read
      "    push qword " writer.write
      int.cstr writer.write
      "\n" writer.write
      disc disc

      ret
    end
    disc
    self read assembler.vartab @ covr map.in if
      self read NULL
      0 1 assembler.updatestack

      nametmp read
      map.getptr read
      "    push mem+" writer.write
      int.cstr writer.write
      "; " writer.write
      covr writer.write
      "\n" writer.write
      disc disc

      ret
    end
    disc
    self read assembler.lvartab @ covr map.in if
      self read NULL
      0 1 assembler.updatestack

      covr map.getptr read
      "    mov rax, [ret_stack_rsp]\n" writer.write
      "    mov rax, [rax-8]\n" writer.write
      "    add rax, " writer.write
      int.cstr writer.write "\n" writer.write
      "    push rax\n" writer.write
      disc disc

      ret
    end
    disc
    self read assembler.proctab @ covr map.in if
      disc disc

      nametmp read
      self read
      nodep read
      assembler.addwordproc

      ret
    end
    disc disc

    node read constdata.constvalue @ str.print

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Word used is not defined"

    error.new
    error.eval

    ret
  end

  oper proc visitconst 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read constdata.constkind @
    copy CNK_NUMBER == if
      disc

      self read nodep read
      0 1 assembler.updatestack

      "    push qword " writer.write
      node read constdata.constvalue @ str.data . writer.write
      "\n" writer.write

      ret
    end
    copy CNK_STRING == if
      disc

      self read nodep read
      0 1 assembler.updatestack

      "    push str_" writer.write
      node read constdata.constvalue . writer.addstr
      "\n" writer.write

      ret
    end
    copy CNK_SSTRING == if
      disc

      self read nodep read
      0 2 assembler.updatestack

      "    push qword " writer.write
      node read constdata.constvalue @ writer.getlen int.cstr writer.write
      "\n" writer.write
      "    push str_" writer.write
      node read constdata.constvalue . writer.addstr
      "\n" writer.write

      ret
    end
    copy CNK_WORD == if
      disc

      self read
      nodep read
      assembler.visitword

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreachable assembler.visitword"

    error.new
    error.eval

    ret
  end

  oper proc visitdef 2 0
    var self 8
    var node 8
    var nodep 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read defdata.defkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read defdata.defname @ str.data .
      assembler.getfullname
      put disc

      def
      node read defdata.defvalue @ str.data . cstr.int
      put disc

      self read assembler.consttab @
      full read
      def
      map.append
      disc

      ret
    end
    disc


    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assembler.visitdef"

    error.new
    error.eval

    ret
  end

  oper proc visitprop 2 0
    var self 8
    var nodep 8
    var node 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read propdata.propkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read propdata.propname @ str.data .
      assembler.getfullname
      put disc

      self read assembler.consttab @
      full read
      self read assembler.classsize .
      map.append
      disc

      self read assembler.classsize .
      node read propdata.propvalue @ str.data . cstr.int
      self read assembler.classsize @ +
      put disc

      ret
    end
    copy CNK_WORD == if
      disc

      full
      self read
      node read propdata.propname @ str.data .
      assembler.getfullname
      put disc

      self read assembler.classsize .

      self read nodep read
      node read propdata.propvalue @
      assembler.internalname
      str.data .
      assembler.getconst

      self read assembler.classsize @ +
      put disc

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assembler.visitprop"

    error.new
    error.eval

    ret
  end

  oper proc visitvar 2 0
    var self 8
    var node 8
    var nodep 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    self read assembler.procname @ str.size @ 0 != if
      node read vardata.varkind @
      copy CNK_NUMBER == if
        disc

        full assembler.MAX_NAME_SIZE heap.zalloc put disc

        full read
        node read vardata.varname @ str.data .
        cstr.cpy disc disc

        self read assembler.lvartab @
        full read
        self read assembler.proclmem .
        map.append
        disc

        node read vardata.varvalue @
        "    mov rax, [loc_stack_rsp]\n" writer.write
        "    add rax, " writer.write
        str.data . writer.write
        "\n" writer.write
        "    mov [loc_stack_rsp], rax\n" writer.write

        self read assembler.proclmem .
        self read assembler.proclmem @
        node read vardata.varvalue @ str.data . cstr.int +
        put disc

        ret
      end
      copy CNK_WORD == if
        disc

        full assembler.MAX_NAME_SIZE heap.zalloc put disc

        full read
        node read vardata.varname @ str.data .
        cstr.cpy disc disc

        self read assembler.lvartab @
        full read
        self read assembler.proclmem .
        map.append
        disc

        self read nodep read
        node read vardata.varvalue @
        assembler.internalname
        str.data .
        assembler.getconst
        "    mov rax, [loc_stack_rsp]\n" writer.write
        "    add rax, " writer.write
        int.cstr writer.write
        "\n" writer.write
        "    mov [loc_stack_rsp], rax\n" writer.write

        self read assembler.proclmem .
        self read assembler.proclmem @
        self read nodep read
        node read vardata.varvalue @
        assembler.internalname
        str.data .
        assembler.getconst +
        put disc

        ret
      end
      disc

      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      "Unreacable assembler.visitvar local"

      error.new
      error.eval

      ret
    end

    node read vardata.varkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read vardata.varname @ str.data .
      assembler.getfullname
      put disc

      self read assembler.vartab @
      full read
      writer.mem
      map.append
      disc

      writer.mem
      node read vardata.varvalue @ str.data . cstr.int
      writer.mem read +
      put disc

      ret
    end
    copy CNK_WORD == if
      disc

      full
      self read
      node read vardata.varname @ str.data .
      assembler.getfullname
      put disc

      self read assembler.vartab @
      full read
      writer.mem
      map.append
      disc

      writer.mem
      self read nodep read
      node read vardata.varvalue @
      assembler.internalname
      str.data .
      assembler.getconst
      writer.mem read +
      put disc

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assembler.visitvar global"

    error.new
    error.eval

    ret
  end

  oper proc visitcall 2 0
    var self 8
    var node 8
    var nodep 8
    var internal 8
    var callee 8
    var data 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    callee assembler.MAX_NAME_SIZE heap.zalloc put disc

    node read calldata.callee @ str.size @
    0 == if
      ".blockstart_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; call\n" writer.write
      "    pop rcx\n" writer.write
      "    mov rax, [ret_stack_rsp]\n" writer.write
      "    add rax, 16\n" writer.write
      "    mov rbx, [loc_stack_rsp]\n" writer.write
      "    mov qword [rax - 8], rbx\n" writer.write
      "    mov qword [ret_stack_rsp], rax\n" writer.write
      "    jmp qword rcx\n" writer.write
      ".blockend_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; call\n" writer.write

      self read assembler.lastblock .
      copy read 1 +
      put disc

      callee read heap.free

      ret
    end

    internal
    node read calldata.callee @
    assembler.internalname
    put disc

    callee read
    internal read str.data .
    cstr.cpy disc disc

    self read assembler.proctab @
    callee read map.in swap disc ! if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      "proc not defined"
      error.new
      error.eval
    end

    data
    self read assembler.proctab @
    callee read
    map.getptr swap disc
    put disc

    data read asmprocdata.kind @ 10 /% swap disc
    PNK_OPER == if
      self read nodep read
      0 1 assembler.updatestack

      "    push proc_" writer.write
      callee read writer.write
      "\n" writer.write

      internal read heap.free
      callee read heap.free

      ret
    end

    self read nodep read
    data read asmprocdata.in @
    data read asmprocdata.out @
    assembler.updatestack

    ".blockstart_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write
    "    mov rax, [ret_stack_rsp]\n" writer.write
    "    add rax, 16\n" writer.write
    "    mov rbx, [loc_stack_rsp]\n" writer.write
    "    mov qword [rax - 8], rbx\n" writer.write
    "    mov qword [ret_stack_rsp], [rax]\n" writer.write
    "    mov qword [rax], .blockend_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    "\n" writer.write
    "    jmp proc_" writer.write
    callee read writer.write
    "\n" writer.write
    ".blockend_" writer.write
    self read assembler.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write

    self read assembler.lastblock .
    copy read 1 +
    put disc

    internal read heap.free
    callee read heap.free

    ret
  end

  oper proc visitintr 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read intrdata.intrkind @
    copy INK_RETURN == if
      disc

      self read assembler.didret . bool.true putc disc

      self read assembler.depth @
      self read assembler.procout @ !=
      self read assembler.procout @ 255 != &&
      if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Invalid proc"

        error.new
        error.eval
      end

      "    mov rax, [ret_stack_rsp]\n" writer.write
      "    mov rax, [rax - 8]\n" writer.write
      "    mov [loc_stack_rsp], rax\n" writer.write
      "    mov rax, [ret_stack_rsp]\n" writer.write
      "    sub rax, 16\n" writer.write
      "    mov qword [ret_stack_rsp], rax\n" writer.write
      "    add rax, 16\n" writer.write
      "    jmp qword [rax]\n" writer.write

      ret
    end
    copy INK_COPY == if
      disc

      self read nodep read
      1 2 assembler.updatestack
      "    pop rax\n" writer.write
      "    push rax\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_DISC == if
      disc

      self read nodep read
      1 0 assembler.updatestack
      "    add rsp, 8\n" writer.write

      ret
    end
    copy INK_ARGC == if
      disc

      self read nodep read
      0 1 assembler.updatestack
      "    mov rax, [args_ptr]\n" writer.write
      "    mov rax, [rax]\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_ARGV == if
      disc

      self read nodep read
      0 1 assembler.updatestack
      "    mov rax, [args_ptr]\n" writer.write
      "    add rax, 8\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_ENVP == if
      disc

      self read nodep read
      0 1 assembler.updatestack
      "    mov rax, [args_ptr]\n" writer.write
      "    mov rax, [rax]\n" writer.write
      "    add rax, 2\n" writer.write
      "    shl rax, 3\n" writer.write
      "    mov rbx, [args_ptr]\n" writer.write
      "    add rbx, rax\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_QUIT == if
      disc

      self read assembler.didret . bool.true putc disc

      self read nodep read
      1 0 assembler.updatestack
      "    mov rax, 60\n" writer.write
      "    pop rdi\n" writer.write
      "    syscall\n" writer.write

      ret
    end
    copy INK_SWAP == if
      disc

      self read nodep read
      2 2 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    push rax\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_COVR == if
      disc

      self read nodep read
      2 3 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    push rbx\n" writer.write
      "    push rax\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_READ == if
      disc

      self read nodep read
      1 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    mov rbx, [rax]\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_READC == if
      disc

      self read nodep read
      1 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    xor rbx, rbx\n" writer.write
      "    mov bl, [rax]\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_PUT == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    mov qword [rax], rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_PUTC == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    mov byte [rax], bl\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_EQ == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    xor rcx, rcx\n" writer.write
      "    mov rdx, 1\n" writer.write
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    cmp rax, rbx\n" writer.write
      "    cmove rcx, rdx\n" writer.write
      "    push rcx\n" writer.write

      ret
    end
    copy INK_NEQ == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    xor rcx, rcx\n" writer.write
      "    mov rdx, 1\n" writer.write
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    cmp rax, rbx\n" writer.write
      "    cmovne rcx, rdx\n" writer.write
      "    push rcx\n" writer.write

      ret
    end
    copy INK_LT == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    xor rcx, rcx\n" writer.write
      "    mov rdx, 1\n" writer.write
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    cmp rax, rbx\n" writer.write
      "    cmovl rcx, rdx\n" writer.write
      "    push rcx\n" writer.write

      ret
    end
    copy INK_GT == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    xor rcx, rcx\n" writer.write
      "    mov rdx, 1\n" writer.write
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    cmp rax, rbx\n" writer.write
      "    cmovg rcx, rdx\n" writer.write
      "    push rcx\n" writer.write

      ret
    end
    copy INK_NOT == if
      disc

      self read nodep read
      1 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    xor rax, 1\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_INV == if
      disc

      self read nodep read
      1 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    not rax\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_AND == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    and rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_OR == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    or rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_ACCESS == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    add rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_REFACCESS == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    add rax, rbx\n" writer.write
      "    mov rbx, [rax]\n" writer.write
      "    push rbx\n" writer.write

      ret
    end
    copy INK_ADD == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    add rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SUB == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    sub rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_MUL == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rbx\n" writer.write
      "    imul rax, rbx\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_DIVMOD == if
      disc

      self read nodep read
      2 2 assembler.updatestack
      "    xor rdx, rdx\n" writer.write
      "    pop rbx\n" writer.write
      "    pop rax\n" writer.write
      "    idiv rbx\n" writer.write
      "    push rax\n" writer.write
      "    push rdx\n" writer.write

      ret
    end
    copy INK_SYS0 == if
      disc

      self read nodep read
      1 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS1 == if
      disc

      self read nodep read
      2 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS2 == if
      disc

      self read nodep read
      3 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS3 == if
      disc

      self read nodep read
      4 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop rdx\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS4 == if
      disc

      self read nodep read
      5 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop rdx\n" writer.write
      "    pop r10\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS5 == if
      disc

      self read nodep read
      6 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop rdx\n" writer.write
      "    pop r10\n" writer.write
      "    pop r8\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    copy INK_SYS6 == if
      disc

      self read nodep read
      7 1 assembler.updatestack
      "    pop rax\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop rdx\n" writer.write
      "    pop r10\n" writer.write
      "    pop r8\n" writer.write
      "    pop r9\n" writer.write
      "    syscall\n" writer.write
      "    push rax\n" writer.write

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Intrinsic action not defined"

    error.new
    error.eval

    ret
  end

  oper proc visitasm 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    "    " writer.write
    node read asmdata.raw @ str.data . writer.write
    "\n" writer.write

    ret
  end

  oper proc visitinc 2 0
    var self 8
    var node 8
    var subnode 8
    var nodep 8
    var file 8
    var name 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    file
    self read assembler.filename @
    put disc

    name assembler.MAX_NAME_SIZE heap.zalloc put disc

    name read
    node read incdata.include @ str.data .
    cstr.cpy disc disc

    self read assembler.includedtab @
    name read
    map.in swap disc if
      name read heap.free
      ret
    end

    self read assembler.includedtab @
    name read
    "y"
    map.append
    disc

    name read
    bool.true
    lexer.new lexer.run
    parser.new parser.run

    copy subnode swap put disc

    self read swap
    assembler.visitnode

    self read assembler.filename .
    file read
    put disc

    name read heap.free
    {subnode read slmnode.free}

    ret
  end

  oper proc visitfile 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    "[ASM] " cstr.print
    node read filedata.filename @ str.print
    "\n" cstr.print

    self read assembler.filename .
    node read filedata.filename @
    put disc

    node read filedata.childcount @
    0 == if ret end

    0
    do
      node read filedata.children .
      covr 8 * + read

      self read swap
      assembler.visitnode

      1 +
      node read filedata.childcount @
      covr >
    end
    disc

    ret
  end

  oper proc visitenum 2 0
    var self 8
    var node 8
    var value 8
    var string 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    value 0 put disc

    node read blockdata.childcount @
    0 == if ret end

    0
    do
      node read blockdata.children .
      covr 8 * + read
      slmnode.data @ copy
      constdata.constkind @ swap
      covr CNK_NUMBER == if
        value
        covr constdata.constvalue @ str.data . cstr.int
        put disc
      end
      covr CNK_WORD == if
        self read
        covr constdata.constvalue @ str.data .
        assembler.getfullname

        self read assembler.consttab @
        swap
        value
        map.append disc

        value
        copy read 1 +
        put disc
      end
      disc disc
      {TODO: ERROR}

      1 +
      node read blockdata.childcount @
      covr >
    end
    disc

    ret
  end

  {TODO: visitsim}

  oper proc visitblock 2 0
    var node 8
    var nodep 8
    var self 8
    var stop 8
    var oldret 1
    var olddepth 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read blockdata.blockkind @
    BNK_PROC == if
      self read node read
      assembler.addprochead
      disc disc

      node read blockdata.childcount @
      0 == if
        self read assembler.proclmem . 0 put disc
        self read assembler.procname @ str.size . 0 put disc
        ret
      end
    end

    node read blockdata.blockkind @
    copy BNK_SIM == if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNIMP
      "Simulator is unimplemented as of now"

      error.new
      error.eval
    end
    copy BNK_CLASS == if
      self read assembler.classsize . 0 put disc

      self read assembler.classname .
      node read blockdata.blockname @
      put disc

      self read
      "SIZE"
      assembler.getfullname
      self read assembler.consttab @
      covr map.in swap disc if
        self read assembler.consttab @
        covr map.getptr read swap disc
        self read assembler.classsize .
        swap put disc
      end
      disc
    end
    copy BNK_ENUM == if
      disc
      self read nodep read
      assembler.visitenum
      ret
    end
    copy BNK_IF == if
      self read nodep read
      1 0 assembler.updatestack

      "    pop rbx\n" writer.write
      "    test rbx, rbx\n" writer.write
      ".blockstart_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; if\n" writer.write
      "    jz .blockend_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      "\n" writer.write

      stop
      self read assembler.lastblock @
      put disc

      self read assembler.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_DO == if
      ".blockstart_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; do\n" writer.write

      stop
      self read assembler.lastblock @
      put disc

      self read assembler.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_LAMBDA == if
      "    jmp .blockend_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ".blockstart_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; lambda\n" writer.write

      stop
      self read assembler.lastblock @
      put disc

      self read assembler.lastblock .
      copy read 1 +
      put disc
    end
    disc


    oldret
    self read assembler.didret . readc
    putc disc
    olddepth
    self read assembler.depth @
    put disc

    self read assembler.didret . 0 putc disc

    0
    do
      node read blockdata.children .
      covr 8 * + read

      self read swap
      assembler.visitnode

      1 +
      node read blockdata.childcount @
      covr >
    end
    disc

    node read blockdata.blockkind @
    copy BNK_CLASS == if
      self read "SIZE"
      assembler.getfullname

      self read assembler.consttab @
      swap
      self read assembler.classsize .
      map.append
      disc

      self read assembler.classname .
      0
      put disc
    end
    copy BNK_IF == if
      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; if\n" writer.write

      self read assembler.didret . readc ! if
        olddepth read
        self read assembler.depth @ !=
        self read assembler.procout @ 255 != && if
          nodep read slmnode.start .
          nodep read slmnode.stop .
          error.EK_BADBLOCK
          "Invalid if"

          error.new
          error.eval
        end
      end
    end
    copy BNK_LAMBDA == if
      self read nodep read
      0 1 assembler.updatestack

      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; lambda\n" writer.write
      "    push .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write
    end
    copy BNK_PLAMBDA == if
      self read nodep read
      0 1 assembler.updatestack

      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; lambda\n" writer.write
      "    push .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write

      "    mov rax, [ret_stack_rsp]\n" writer.write
      "    add rax, 16\n" writer.write
      "    mov rbx, [loc_stack_rsp]\n" writer.write
      "    mov qword [rax - 8], rbx\n" writer.write
      "    mov qword [ret_stack_rsp], rax\n" writer.write
      "    mov qword [rax], .blockend_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      "\n" writer.write
      "    jmp proc_" writer.write
      node read blockdata.blockname @
      assembler.internalname str.data .
      writer.write
      "\n" writer.write
      ".blockend_" writer.write
      self read assembler.lastblock @ int.cstr writer.write
      ": ; call\n" writer.write

      self read assembler.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_DO == if
      self read nodep read
      1 0 assembler.updatestack

      "    pop rbx\n" writer.write
      "    test rbx, rbx\n" writer.write
      "    jnz .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write
      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; do\n" writer.write

      olddepth read
      self read assembler.depth @ !=
      self read assembler.procout @ 255 != && if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Invalid do"

        error.new
        error.eval
      end
    end
    copy BNK_PROC == if
      self read assembler.didret . readc ! if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Invalid proc without ret"

        error.new
        error.eval
      end

      self read assembler.proclmem . 0 put disc
      self read assembler.procname @ str.size . 0 put disc
    end
    disc

    self read assembler.didret .
    oldret readc
    putc disc
    self read assembler.depth .
    olddepth read
    put disc

    ret
  end

  oper proc visitnode 2 0
    copy slmnode.data @
    nodedata.kind @
    copy SNK_INC == if
      disc
      assembler.visitinc

      ret
    end
    copy SNK_COMMENT == if
      disc disc disc

      ret
    end
    copy SNK_FILE == if
      disc
      assembler.visitfile

      ret
    end
    copy SNK_BLOCK == if
      disc
      assembler.visitblock

      ret
    end
    copy SNK_CONST == if
      disc
      assembler.visitconst

      ret
    end
    copy SNK_DEF == if
      disc
      assembler.visitdef

      ret
    end
    copy SNK_ASM == if
      disc
      assembler.visitasm

      ret
    end
    copy SNK_INTR == if
      disc
      assembler.visitintr

      ret
    end
    copy SNK_PROP == if
      disc
      assembler.visitprop

      ret
    end
    copy SNK_VAR == if
      disc
      assembler.visitvar

      ret
    end
    copy SNK_CALL == if
      disc
      assembler.visitcall

      ret
    end
    copy SNK_OF == if
      disc
      assembler.visitof

      ret
    end
    disc

    disc disc

    ret
  end
end
