inc "compiler/node.slm"
inc "compiler/writer.slm"
inc "stdlib/maps.slm"

{the size of a key for the proc, const table}
const TAB_KEY_SIZE  64

class assembler
  const SUCCESS 0
  const FAIL 1

  var root int.SIZE
  var visit int.SIZE
  var file int.SIZE

  var consttab int.SIZE
  var proctab int.SIZE
  var vartab int.SIZE

  var classsize int.SIZE
  var curcall int.SIZE
  var curif int.SIZE
  var curdo int.SIZE
  var laststring int.SIZE
  var classname int.SIZE

  var includedtab int.SIZE

  var tmpname int.SIZE

  var tmpchar 2

  var procnamecstr TAB_KEY_SIZE


  push proc getconst 1 1
    assembler.consttab read covr (map.in) if [
      covr (map.get) read
      swap disc
      swap disc
      ret
    ] disc

    ret
  end

  var itemp int.SIZE

  push proc internalname 1 1
    assembler.itemp swap put disc

    assembler.tmpname read
    str.size . 0 put disc

    0
    do
      copy
      assembler.itemp read
      str.data . +
      readc 
      copy assembler.tmpchar swap putc disc
      copy '/' == if [
        assembler.tmpname read
        "slash" (str.catc)
        disc disc 0
      ]
      copy '%' == if [
        assembler.tmpname read
        "perc" (str.catc)
        disc disc 0
      ]
      copy '.' == if [
        assembler.tmpname read
        "_" (str.catc)
        disc disc 0
      ]
      copy 0 != if [
        assembler.tmpname read
        assembler.tmpchar
        (str.catc)
        disc disc 0
      ]
      disc
      
      1 +
      
      copy
      assembler.itemp read
      str.size . read
      <
    end
    disc

    assembler.tmpname read
    copy
    copy str.data .
    swap str.size . read +
    0 putc disc

    ret
  end

  var tmpof int.SIZE

  push proc addproctab 1 1
    copy
    assembler.tmpof read ofdata.inherit . read str.data .
    copy 
    (cstr.len) (mem.eq)
    ! if [
      ret
    ]
  
    "proc_" (writer.write)
    assembler.classname read str.data . (writer.write)
    copy
    do
      1 +
      copy readc '_' !=
    end
    (writer.write)

    ":" (writer.write)

    copy
    "  jmp proc_" (writer.write)
    (writer.writeln)

    ret
  end

  push proc visitof 1 1
    assembler.tmpof swap put disc

    assembler.proctab read
    assembler.addproctab
    (map.foreach)

    assembler.SUCCESS

    ret
  end

  var blockprocname int.SIZE

  push proc visitword 1 1
    assembler.blockprocname read covr copy (cstr.len) swap (str.sput) disc
    assembler.blockprocname read (assembler.internalname) disc

    assembler.procnamecstr TAB_KEY_SIZE (mem.zero)
    assembler.procnamecstr
    assembler.tmpname read str.data . (cstr.cpy) disc disc

    assembler.consttab read covr (map.in) if [
      covr (map.get) read
      "    push qword " (writer.write)
      (int.cstr) (writer.write)
      (writer.cr)

      disc
      disc

      assembler.SUCCESS

      ret
    ] disc
    assembler.vartab read covr (map.in) if [
      covr (map.get) read
      "    push mem+" (writer.write)
      (int.cstr) (writer.write)
      (writer.cr)

      disc
      disc

      assembler.SUCCESS

      ret
    ] disc
    assembler.proctab read assembler.procnamecstr (map.in) if [
      "    push proc_" (writer.write)

      assembler.procnamecstr
      (writer.write)
      (writer.cr)

      disc
      disc

      assembler.SUCCESS

      ret
    ] disc
    disc
    "    ; Word " (writer.write)
    assembler.tmpname read str.data .
    (writer.writeln)

    assembler.FAIL
    
    ret
  end

  push proc visitconst 1 1
    copy constdata.constkind . read swap
    covr CNK_NUMBER == if [
      "    push qword " (writer.write)
      copy constdata.constvalue . read str.data . 
      (writer.write)
      (writer.cr)
      disc
      disc
      assembler.SUCCESS
      ret
    ]
    covr CNK_STRING == if [
      "    push str_" (writer.write)
      constdata.constvalue . (writer.addstr)
      (writer.cr)

      disc
      assembler.SUCCESS
      ret
    ]
    covr CNK_SSTRING == if [
      "    push qword " (writer.write)
      copy constdata.constvalue . read (writer.getlen) (int.cstr) (writer.writeln)
      "    push str_" (writer.write)
      constdata.constvalue . (writer.addstr)
      (writer.cr)

      disc
      assembler.SUCCESS
      ret
    ]
    covr CNK_WORD == if [
      swap disc
      constdata.constvalue . read str.data .
      (assembler.visitword)
      ret
    ]
    disc
    disc
    assembler.FAIL
    ret
  end

  var tmp int.SIZE
  var tmpstr int.SIZE

  push proc getfullname 1 0
    assembler.tmpstr read 0 != if [
      assembler.tmpstr read 
      (heap.free)
    ]
    assembler.tmpstr 64 (heap.zalloc) put disc

    assembler.tmpstr read
    assembler.classname read
    copy NULL != if [
      str.data . (cstr.cpy)

      assembler.tmpstr read
      "." (cstr.cat) disc
    ] disc disc

    assembler.tmpstr read
    covr (cstr.cat)
    disc
    disc
    ret
  end
  
  var tmpdef int.SIZE

  push proc visitdef 1 1
    copy defdata.defkind . read swap
    covr CNK_NUMBER == if [
      copy defdata.defname . read str.data .
      (assembler.getfullname)

      copy defdata.defvalue . read str.data . (cstr.tonum)
      assembler.tmpdef swap put disc

      assembler.consttab read
      assembler.tmpstr read
      assembler.tmpdef
      (map.putat)
      disc
      disc
      disc

      assembler.SUCCESS
      ret
    ]
    covr CNK_WORD == if [
      

      disc
      disc
      assembler.FAIL
      ret
    ]
    disc
    disc
    assembler.FAIL

    ret
  end

  push proc visitprop 1 1
    copy propdata.propkind . read swap
    covr CNK_NUMBER == if [
      copy propdata.propname . read str.data .
      (assembler.getfullname)    
    
      assembler.consttab read
      assembler.tmpstr read
      assembler.classsize
      (map.putat)
      disc
      
      assembler.classsize
      covr propdata.propvalue . read
      assembler.classsize read +
      put disc
      
      disc
      disc
      assembler.SUCCESS
      ret
    ]
    covr CNK_WORD == if [
      copy propdata.propname . read str.data .
      (assembler.getfullname)    

      assembler.consttab read
      assembler.tmpstr read
      assembler.classsize
      (map.putat)
      disc
      
      assembler.classsize
      covr propdata.propvalue . read str.data . 
      (assembler.getconst)

      assembler.classsize read +
      put disc
      
      disc
      disc
      assembler.SUCCESS
      ret
    ]
    disc
    disc
    assembler.FAIL
    ret
  end

  push proc visitvar 1 1
    copy vardata.varkind . read swap
    covr CNK_NUMBER == if [
      copy vardata.varname . read str.data .
      (assembler.getfullname)

      assembler.vartab read
      assembler.tmpstr read
      writer.tmem
      (map.putat)
      disc

      writer.tmem
      covr vardata.varvalue . read
      writer.tmem read +
      put disc
      
      disc
      disc
      assembler.SUCCESS
      ret
    ]
    covr CNK_WORD == if [
      copy vardata.varname . read str.data .
      (assembler.getfullname)
      
      assembler.vartab read
      assembler.tmpstr read
      writer.tmem
      (map.putat)
      disc

      writer.tmem
      covr vardata.varvalue . read str.data .
      (assembler.getconst)
      
      writer.tmem read +
      put disc
      
      disc
      disc
      assembler.SUCCESS
      ret
    ]
    swap disc

    ret
  end

  push proc visitcall 1 1
    calldata.callee . read
    copy str.data . "" (cstr.eq) if [
      disc

      "    pop rbx\n" (writer.write)
      "    mov rax, [ret_stack_rsp]\n" (writer.write)
      "    add rax, 8\n" (writer.write)
      "    mov qword [ret_stack_rsp], rax\n" (writer.write)
      "    mov qword [rax], .call_" (writer.write)
      assembler.curcall read (int.cstr) (writer.writeln)
      "    jmp qword rbx\n" (writer.write)
      ".call_" (writer.write)
      assembler.curcall read (int.cstr) (writer.write)
      ":" (writer.writeln)
      assembler.curcall copy
      read 1 +
      put disc

      assembler.SUCCESS

      ret
    ]
    "    mov rax, [ret_stack_rsp]\n" (writer.write)
    "    add rax, 8\n" (writer.write)
    "    mov qword [ret_stack_rsp], rax\n" (writer.write)
    "    mov qword [rax], .call_" (writer.write)
    assembler.curcall read (int.cstr) (writer.writeln)
    "    jmp proc_" (writer.write)
    (assembler.internalname)
    str.data . (writer.writeln)
    ".call_" (writer.write)
    assembler.curcall read (int.cstr) (writer.write)
    ":" (writer.writeln)

    assembler.curcall copy
    read 1 +
    put disc

    assembler.SUCCESS
    
    ret
  end

  push proc visitintr 1 1
    copy intrdata.intrkind . read swap
    covr INK_RETURN == if [
      "    mov rax, [ret_stack_rsp]\n" (writer.write)
      "    sub rax, 8\n" (writer.write)
      "    mov qword [ret_stack_rsp], rax\n" (writer.write)
      "    add rax, 8\n" (writer.write)
      "    jmp qword [rax]\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_COPY == if [
      "    pop rax\n" (writer.write)
      "    push rax\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_ARGC == if [
      "    mov rax, [args_ptr]\n" (writer.write)
      "    mov rax, [rax]\n" (writer.write)
      "    push rax\n" (writer.write)

      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_ARGV == if [
      "    mov rax, [args_ptr]\n" (writer.write)
      "    add rax, 8\n" (writer.write)
      "    push rax\n" (writer.write)

      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_ENVP == if [
      "    mov rax, [args_ptr]\n" (writer.write)
      "    mov rax, [rax]\n" (writer.write)
      "    add rax, 2\n" (writer.write)
      "    shl rax, 3\n" (writer.write)
      "    mov rbx, [args_ptr]\n" (writer.write)
      "    add rbx, rax\n" (writer.write)
      "    push rbx\n" (writer.write)

      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SWAP == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      "    push rbx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_COVR == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    push rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      "    push rbx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_READ == if [
      "    pop rax\n" (writer.write)
      "    xor rbx, rbx\n" (writer.write)
      "    mov rbx, [rax]\n" (writer.write)
      "    push rbx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_READC == if [
      "    pop rax\n" (writer.write)
      "    xor rbx, rbx\n" (writer.write)
      "    mov bl, [rax]\n" (writer.write)
      "    push rbx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_PUT == if [
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    mov qword [rax], rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_PUTC == if [
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    mov byte [rax], bl\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_EQ == if [
      "    mov rcx, 0\n" (writer.write)
      "    mov rdx, 1\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    cmp rax, rbx\n" (writer.write)
      "    cmove rcx, rdx\n" (writer.write)
      "    push rcx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_NEQ == if [
      "    mov rcx, 0\n" (writer.write)
      "    mov rdx, 1\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    cmp rax, rbx\n" (writer.write)
      "    cmovne rcx, rdx\n" (writer.write)
      "    push rcx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_NOT == if [
      "    pop rax\n" (writer.write)
      "    xor rax, 1\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_LT == if [
      "    mov rcx, 0\n" (writer.write)
      "    mov rdx, 1\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    cmp rax, rbx\n" (writer.write)
      "    cmovl rcx, rdx\n" (writer.write)
      "    push rcx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_GT == if [
      "    mov rcx, 0\n" (writer.write)
      "    mov rdx, 1\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    cmp rax, rbx\n" (writer.write)
      "    cmovg rcx, rdx\n" (writer.write)
      "    push rcx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_AND == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    and rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_OR == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    or rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_ADD == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    add rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_ACCESS == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    add rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_MUL == if [
      "    pop rax\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    imul rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_DIVMOD == if [
      "    xor rdx, rdx\n" (writer.write)
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    idiv rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      "    push rdx\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SUB == if [
      "    pop rbx\n" (writer.write)
      "    pop rax\n" (writer.write)
      "    sub rax, rbx\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS0 == if [
      "    pop rax\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS1 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS2 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    pop rsi\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS3 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    pop rsi\n" (writer.write)
      "    pop rdx\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS4 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    pop rsi\n" (writer.write)
      "    pop rdx\n" (writer.write)
      "    pop r10\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS5 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    pop rsi\n" (writer.write)
      "    pop rdx\n" (writer.write)
      "    pop r10\n" (writer.write)
      "    pop r8\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_SYS5 == if [
      "    pop rax\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    pop rsi\n" (writer.write)
      "    pop rdx\n" (writer.write)
      "    pop r10\n" (writer.write)
      "    pop r8\n" (writer.write)
      "    pop r9\n" (writer.write)
      "    syscall\n" (writer.write)
      "    push rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_DISC == if [
      "    pop rax\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    covr INK_QUIT == if [
      "    mov rax, 60\n" (writer.write)
      "    pop rdi\n" (writer.write)
      "    syscall\n" (writer.write)
      disc
      disc
      assembler.SUCCESS

      ret
    ]
    disc
    disc
    assembler.FAIL

    ret
  end

  push proc visitasm 1 1
    "    " (writer.write)
    asmdata.raw . read str.data . (writer.write)
    (writer.cr)
  
    assembler.SUCCESS
    ret
  end

  push proc visitinc 1 1
    assembler.file read

    covr incdata.include . read
    str.data .
    copy assembler.includedtab read swap (map.in) swap disc if [
      disc disc disc
      assembler.SUCCESS
      ret
    ]
    assembler.includedtab read covr
    "y" (map.putat)
    disc

    bool.true
    (lexer.new) (lexer.run)
    (parser.new) (parser.run)

    assembler.visit read ()
    swap

    assembler.file swap put disc

    swap disc

    ret
  end

  push proc visitfile 1 1
    "[ASM] " (cstr.print)
    copy filedata.name . read
    (cstr.println)

    assembler.file
    covr filedata.name . read
    put disc
  
    copy filedata.childcount . read

    0 == if [
      disc
      assembler.SUCCESS
      ret
    ]

    0
    do
      covr filedata.children .
      covr int.SIZE * + read

      copy assembler.visit read ()
      assembler.SUCCESS != if [
        (slmnode.print)
        (writer.cr)
        disc
        disc
        assembler.FAIL
        ret
      ]

      disc

      1 +
      covr filedata.childcount . read
      covr >
    end
    disc
    disc

    assembler.SUCCESS

    ret
  end

  var procdata int.SIZE
  var procname int.SIZE

  push proc addprochead 2 2
    assembler.procname read str.size . 0 put disc
    assembler.procdata 1 put disc

    assembler.curcall 0 put disc
    assembler.curif 0 put disc
    assembler.curdo 0 put disc
    "proc_" (writer.write)
    
    assembler.classname read
    copy NULL != if [
      (assembler.internalname) str.data .
      assembler.procname read
      swap (str.catc)
      "_" (str.catc)
    ] disc
    covr blockdata.blockname . read
    (assembler.internalname) str.data . 

    assembler.procname read
    swap (str.catc) disc

    assembler.procname read
    copy str.data .
    swap str.size . read +
    0 putc disc

    assembler.procnamecstr TAB_KEY_SIZE (mem.zero)
    assembler.procnamecstr
    assembler.procname read str.data . (cstr.cpy) disc disc



    assembler.proctab read
    assembler.procnamecstr
    assembler.procdata
    (map.putat) disc

    assembler.procname read str.data . (writer.write)
    ":" (writer.writeln)

    ret
  end

  var enumval int.SIZE

  push proc visitenum 1 1
    copy blockdata.childcount . read
    0 == if [
      disc
      assembler.SUCCESS
      ret
    ]

    assembler.enumval 0 put disc

    0
    do
      covr blockdata.children .
      covr int.SIZE * + read
      slmnode.data . read
      copy constdata.constkind . read swap
      covr CNK_NUMBER == if [
        copy constdata.constvalue . read str.data . (cstr.tonum) assembler.enumval swap put disc
      ]
      covr CNK_WORD == if [
        copy constdata.constvalue . read str.data .
        (assembler.getfullname)
      
        assembler.consttab read
        assembler.tmpstr read
        assembler.enumval
        (map.putat) disc

        assembler.enumval copy read 1 + put disc
      ]
      disc
      disc

      1 +
      covr blockdata.childcount . read
      covr >
    end
    disc
    disc

    assembler.SUCCESS

    ret
  end

  var blockends int.SIZE

  push proc visitblock 1 1
    copy blockdata.blockkind . read
    copy BNK_CLASS == if [
      assembler.classsize 0 put disc
      "class_" (writer.write)
      covr blockdata.blockname . read
      (assembler.internalname)
      str.data . (writer.write)
      ":" (writer.writeln)
      covr blockdata.blockname . read
      assembler.classname swap
      put disc
    ]
    copy BNK_PROC == if [
      (assembler.addprochead)
    ]
    copy BNK_ENUM == if [
      disc (assembler.visitenum)
      ret
    ]
    copy BNK_IF == if [
      "    pop rbx\n" (writer.write)
      "    test rbx, rbx\n" (writer.write)
      "    jz .if_" (writer.write)
      assembler.curif read (int.cstr) (writer.writeln)
      assembler.blockends read
      assembler.curif read (seq.pushint) disc
      assembler.curif copy
      read 1 +
      put disc
    ]
    copy BNK_DO == if [
      ".do_" (writer.write)
      assembler.curdo read (int.cstr) (writer.write)
      ":" (writer.writeln)
      assembler.blockends read
      assembler.curdo read (seq.pushint) disc
      assembler.curdo copy
      read 1 +
      put disc
    ]
    disc

    copy blockdata.childcount . read

    0 == if [
      disc
      assembler.SUCCESS
      ret
    ]

    0
    do
      covr blockdata.children .
      covr int.SIZE * + read

      copy assembler.visit read ()
      assembler.SUCCESS != if [
        (slmnode.print)
        (writer.cr)
        disc
        disc
        assembler.FAIL
        ret
      ]

      disc

      1 +
      covr blockdata.childcount . read
      covr >
    end
    disc
    blockdata.blockkind . read
    copy BNK_CLASS == if [
      "SIZE"
      (assembler.getfullname)
    
      assembler.consttab read
      assembler.tmpstr read
      assembler.classsize
      (map.putat)
      disc

      assembler.classname
      NULL
      put disc
    ]
    copy BNK_IF == if [
      ".if_" (writer.write)
      assembler.blockends read (seq.popaddr) read (int.cstr) (writer.write)
      ":" (writer.writeln)
      disc
    ]
    copy BNK_DO == if [
      "    pop rbx\n" (writer.write)
      "    test rbx, rbx\n" (writer.write)
      "    jnz .do_" (writer.write)
      assembler.blockends read (seq.popaddr) read (int.cstr) (writer.writeln)
      disc
    ]
    disc

    assembler.SUCCESS

    ret
  end

  push proc visitnode 1 1
    assembler.blockends read NULL == if [
      assembler.blockends int.SIZE 256 (seq.new) put disc
      assembler.consttab 256 int.SIZE TAB_KEY_SIZE (map.new) put disc
      assembler.proctab 256 int.SIZE TAB_KEY_SIZE (map.new) put disc
      assembler.vartab 256 int.SIZE TAB_KEY_SIZE (map.new) put disc
      assembler.includedtab 256 int.SIZE TAB_KEY_SIZE (map.new) put disc
      assembler.tmpname (str.new) put disc
      assembler.procname (str.new) put disc
      assembler.blockprocname (str.new) put disc
    ]
    assembler.visit assembler.visitnode put disc

    slmnode.data . read copy nodedata.kind . read
    copy SNK_NULL == if [
      disc disc
      assembler.FAIL

      ret
    ]
    copy SNK_INC == if [
      disc
      (assembler.visitinc)
      
      ret
    ]
    copy SNK_COMMENT == if [
      disc disc
      assembler.SUCCESS

      ret
    ]
    copy SNK_COMMENT == if [
      disc disc
      assembler.SUCCESS

      ret
    ]
    copy SNK_FILE == if [
      disc
      (assembler.visitfile)
      
      ret
    ]
    copy SNK_BLOCK == if [
      disc
      (assembler.visitblock)
      
      ret
    ]
    copy SNK_CONST == if [
      disc
      (assembler.visitconst)
      
      ret
    ]
    copy SNK_DEF == if [
      disc
      (assembler.visitdef)
      
      ret
    ]
    copy SNK_ASM == if [
      disc
      (assembler.visitasm)
      
      ret
    ]
    copy SNK_INTR == if [
      disc
      (assembler.visitintr)
      
      ret
    ]
    copy SNK_PROP == if [
      disc
      (assembler.visitprop)
      
      ret
    ]
    copy SNK_VAR == if [
      disc
      (assembler.visitvar)
      
      ret
    ]
    copy SNK_CALL == if [
      disc
      (assembler.visitcall)
      
      ret
    ]
    copy SNK_OF == if [
      disc
      (assembler.visitof)
      
      ret
    ]
    disc (slmnode.print)

    assembler.FAIL
    ret
  end
end
