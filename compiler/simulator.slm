inc "compiler/simulator.slh"

class simasm
  oper proc appendch 2 1
    var str 8
    var char 1

    char swap putc disc
    str swap put disc

    str read
    " " str.catc
    str swap put disc

    str read str.size @
    str read str.data . + 1 -
    char readc
    putc disc

    str read

    ret
  end

  oper proc addsetrax 2 1
    var pushes 8

    pushes swap put disc

    72 simasm.appendch
    184 simasm.appendch
    pushes 0 + readc simasm.appendch
    pushes 1 + readc simasm.appendch
    pushes 2 + readc simasm.appendch
    pushes 3 + readc simasm.appendch
    pushes 4 + readc simasm.appendch
    pushes 5 + readc simasm.appendch
    pushes 6 + readc simasm.appendch
    pushes 7 + readc simasm.appendch

    ret
  end

  oper proc addpushreg 2 1
    80 + simasm.appendch

    ret
  end

  oper proc addpopreg 2 1
    88 + simasm.appendch

    ret
  end

  oper proc addop 2 1
    swap
    72 simasm.appendch
    swap simasm.appendch
    216 simasm.appendch

    ret
  end

  oper proc addsyscall 1 1
    15 simasm.appendch
    5 simasm.appendch

    ret
  end

  oper proc start 1 1
    85 simasm.appendch
    72 simasm.appendch
    137 simasm.appendch
    229 simasm.appendch

    ret
  end

  oper proc stop 2 1
    simasm.addsetrax
    88 simasm.appendch
    93 simasm.appendch
    195 simasm.appendch


    ret
  end
end

class simulator
  oper proc new 1 1
    var result 8

    result simulator.SIZE heap.alloc put disc

    result read simulator.procs . 255 simproc.SIZE 128 map.new put disc
    result read simulator.nodes . swap put disc

    result read simulator.nodes @ slmnode.data @ filedata.childcount @
    0 == if
      result read ret
    end

    0
    do
      result read
      covr int.SIZE *
      result read simulator.nodes @ slmnode.data @ filedata.children + @
      simulator.asmproc

      1 +
      node read filedata.childcount @ covr >
    end
    disc

    result read

    ret
  end

  oper proc run 1 0
    var self 8
    var tmp 8

    tmp 128 heap.zalloc put disc

    tmp read "main" cstr.cpy disc disc

    self swap put disc

    self read simulator.procs @ tmp read map.in swap disc if
      self read
      self read simulator.procs @ tmp read map.getptr swap disc read

      tmp read heap.free

      simulator.runproc quit

      ret
    end

    tmp read heap.free

    "no main proc" cstr.println
    1 quit
  end

  unsafe oper proc callc 1 1
    asm "pop rax"
    asm "call rax"
    asm "push rax"

    ret
  end

  oper proc runproc 2 1
    var self 8
    var simproc 8
    var buff 8

    simproc swap put disc
    self swap put disc

    0
    -1
    2 32 ||
    2 4 ||
    simproc read simproc.execstr @ str.len
    NULL
    sysc.MMAP
    sys6
    buff covr put disc
    0 < if
      "Cannot map memory" cstr.println

      1 quit
    end

    buff read
    simproc read simproc.execstr @ str.data .
    simproc read simproc.execstr @ str.len
    mem.cpy

    "[RUN]" cstr.println

    buff read simulator.callc

    ret
  end

  oper proc asmblock 2 1
    var block 8

    swap disc

    ret
  end

  oper proc asmintr 2 1
    var nodep 8
    var node 8
    var str 8

    str swap put disc
    nodep swap put disc

    node nodep read slmnode.data @ put disc

    node read intrdata.intrkind @
    copy INK_RETURN == if
      disc

      str read
      1 simasm.stop
      ret
    end
    copy INK_COPY == if
      disc

      str read
      simasm.RAX simasm.addpopreg
      simasm.RAX simasm.addpushreg
      simasm.RAX simasm.addpushreg

      ret
    end
    copy INK_COVR == if
      disc

      str read
      simasm.RAX simasm.addpopreg
      simasm.RBX simasm.addpopreg
      simasm.RBX simasm.addpushreg
      simasm.RAX simasm.addpushreg
      simasm.RBX simasm.addpushreg

      ret
    end
    copy INK_SWAP == if
      disc

      str read
      simasm.RAX simasm.addpopreg
      simasm.RBX simasm.addpopreg
      simasm.RAX simasm.addpushreg
      simasm.RBX simasm.addpushreg

      ret
    end
    copy INK_DISC == if
      disc

      str read
      simasm.RAX simasm.addpopreg

      ret
    end
    copy INK_READC == if
      disc

      str read
      simasm.RAX simasm.addpopreg
      {xor rbx, rbx}
      72 simasm.appendch
      49 simasm.appendch
      219 simasm.appendch

      {mov bl, rax}
      138 simasm.appendch
      24 simasm.appendch

      simasm.RBX simasm.addpushreg

      ret
    end
    copy INK_EQ == if
      disc

      str read
      simasm.RAX simasm.addpopreg
      simasm.RBX simasm.addpopreg
      {xor rcx, rcx}
      72 simasm.appendch
      49 simasm.appendch
      201 simasm.appendch
      {mov edx, 1}
      186 simasm.appendch
      1 simasm.appendch
      0 simasm.appendch
      0 simasm.appendch
      0 simasm.appendch
      {cmp rax, rbx}
      72 simasm.appendch
      57 simasm.appendch
      216 simasm.appendch
      {cmove rcx, rdx}
      72 simasm.appendch
      15 simasm.appendch
      68 simasm.appendch
      202 simasm.appendch

      simasm.RCX simasm.addpushreg

      ret
    end
    copy INK_ADD == if
      disc

      str read
      simasm.RBX simasm.addpopreg
      simasm.RAX simasm.addpopreg
      simasm.OP_ADD simasm.addop
      simasm.RAX simasm.addpushreg

      ret
    end
    copy INK_SUB == if
      disc

      str read
      simasm.RBX simasm.addpopreg
      simasm.RAX simasm.addpopreg
      simasm.OP_SUB simasm.addop
      simasm.RAX simasm.addpushreg

      ret
    end
    copy INK_MUL == if
      disc

      str read
      simasm.RBX simasm.addpopreg
      simasm.RAX simasm.addpopreg
      72 simasm.appendch
      15 simasm.appendch
      175 simasm.appendch
      195 simasm.appendch

      simasm.RAX simasm.addpushreg

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNIMP
    "Intr not implemented"

    error.new
    error.eval

    0

    ret
  end

  unsafe oper proc callthing 2 0
    var lol 8

    lol swap put disc

    "call" cstr.print
    cstr.println

    lol read
    asm "pop rax"
    asm "jmp rax"

    ret
  end

  oper proc asmconst 2 1
    var nodep 8
    var node 8
    var str 8

    str swap put disc
    nodep swap put disc

    node nodep read slmnode.data @ put disc

    node read constdata.constkind @
    copy CNK_NUMBER == if
      disc

      str read
      node read constdata.constvalue @ str.data . cstr.int
      simasm.addsetrax
      simasm.RAX simasm.addpushreg

      ret
    end
    copy CNK_STRING == if
      disc

      str read
      node read constdata.constvalue @ str.data .
      simasm.addsetrax
      simasm.RAX simasm.addpushreg

      ret
    end
    copy CNK_WORD == if
      disc

      node read constdata.constvalue @ str.data .
      "echo" cstr.eq if
        str read
        simasm.RDX simasm.addpopreg
        simasm.RSI simasm.addpopreg
        1 simasm.addsetrax

        72 simasm.appendch
        137 simasm.appendch
        199 simasm.appendch

        simasm.addsyscall

        ret
      end

      str read
      node read constdata.constvalue @ str.data . simasm.addsetrax
      simasm.RAX simasm.addpushreg
      (simulator.callthing)
      copy int.print
      simasm.addsetrax
      232 simasm.appendch
      0 simasm.appendch
      0 simasm.appendch
      0 simasm.appendch
      0 simasm.appendch
      255 simasm.appendch
      224 simasm.appendch

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNIMP
    "Const not implemented"

    error.new
    error.eval

    0

    ret
  end

  oper proc asmnode 2 1
    var nodep 8
    var node 8
    var str 8

    str swap put disc
    nodep swap put disc

    node nodep read slmnode.data @ put disc

    node read nodedata.kind @
    copy SNK_INTR == if
      disc

      nodep read str read
      simulator.asmintr

      ret
    end
    copy SNK_CONST == if
      disc

      nodep read str read
      simulator.asmconst

      ret
    end
    copy SNK_BLOCK == if
      disc

      nodep read str read
      simulator.asmblock

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNIMP
    "Node kind not implemented"

    error.new
    error.eval

    0

    ret
  end

  oper proc asmproc 2 0
    var self 8
    var nodep 8
    var node 8
    var result 8
    var tmp 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    result simproc.SIZE heap.zalloc put disc
    result read simproc.execstr . str.new put disc

    result read simproc.execstr @
    simasm.start
    result read simproc.execstr . swap put disc

    node read blockdata.childcount @ 0 == if
      result read simproc.execstr @ str.free
      result read heap.free
      ret
    end

    0
    do
      node read blockdata.children . covr int.SIZE * + read
      result read simproc.execstr @
      simulator.asmnode
      result read simproc.execstr . swap put disc

      1 +
      node read blockdata.childcount @ covr >
    end
    disc


    result read simproc.execstr @
    0 simasm.stop
    144 simasm.appendch
    result read simproc.execstr . swap put disc

    tmp 128 heap.zalloc put disc

    tmp read node read blockdata.blockname @ str.data .
    cstr.cpy disc disc

    self read simulator.procs @
    tmp read
    result
    map.append
    self read simulator.procs . swap put disc

    tmp read heap.free

    ret
  end
end
