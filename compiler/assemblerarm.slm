inc "compiler/assemblerarm.slh"

class assemblerarm
  {
    ARGS: out in node self
    RETS: self
  }
  oper proc new 0 1
    var result 8

    result assemblerarm.SIZE heap.zalloc put disc

    result read assemblerarm.includedtab . 256 1 assemblerarm.MAX_NAME_SIZE map.new put disc
    result read assemblerarm.consttab . 256 8 assemblerarm.MAX_NAME_SIZE map.new put disc
    result read assemblerarm.proctab . 256 asmprocdata.SIZE assemblerarm.MAX_NAME_SIZE map.new put disc
    result read assemblerarm.lvartab . 256 8 assemblerarm.MAX_NAME_SIZE map.new put disc
    result read assemblerarm.vartab . 256 8 assemblerarm.MAX_NAME_SIZE map.new put disc
    result read assemblerarm.procname . str.new put disc

    result read

    ret
  end

  {
    ARGS: out in node self
    RETS: self
  }
  oper proc internalname 1 1
    var start 8
    var name 8
    var char 2

    start swap put disc
    name str.new put disc

    char 1 + 0 putc disc

    0
    do
      copy start read
      str.data . + readc
      copy char swap putc disc
      copy '/' == if
        name read
        "slash" str.catc
        name swap put disc
        disc 0
      end
      copy '%' == if
        name read
        "perc" str.catc
        name swap put disc
        disc 0
      end
      copy '.' == if
        name read
        "_" str.catc
        name swap put disc
        disc 0
      end
      copy 0 != if
        name read
        char str.catc
        name swap put disc
        disc 0
      end
      disc

      1 +

      copy
      start read
      str.size @ <
      covr 1000 < &&
    end
    disc

    name read str.data .
    name read str.size @ +
    0 putc disc

    name read

    ret
  end

  {
    ARGS: name self
    RETS: value
  }
  oper proc getconst 3 1
    var name 8
    var node 8
    var nodep 8
    var self 8
    var tmpname 8

    name swap put disc
    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    tmpname assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

    tmpname read name read cstr.cpy disc disc

    self read assemblerarm.consttab @
    tmpname read map.in swap disc ! if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      str.new
      "Const '" str.catc
      tmpname read str.catc
      "' is not defined." str.catc

      str.data .

      error.new
      error.eval
    end

    self read assemblerarm.consttab @
    tmpname read map.getptr read
    swap disc

    tmpname read heap.free

    ret
  end

  {
    ARGS: out in node self
    RETS:
  }
  oper proc updatestack 4 0
    var self 8
    var node 8
    var nodep 8
    var out 8
    var in 8

    out swap put disc
    in swap put disc
    nodep swap put disc
    self swap put disc

    nodep read NULL != if
      node nodep read slmnode.data @ put disc
    end

    self read assemblerarm.depth @
    in read -
    self read assemblerarm.depth . swap put disc

    self read assemblerarm.depth @ 0 < if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDERFLOW
      "Stack Underflow"

      error.new
      error.eval
    end

    self read assemblerarm.depth @
    out read +
    self read assemblerarm.depth . swap put disc

    ret
  end

  {
    ARGS: proc self
    RETS: self
  }
  oper proc addproctab 2 1
    var name 8
    var self 8

    name swap put disc
    self swap put disc

    name read
    self read assemblerarm.parentclass @ str.data .
    copy cstr.len
    mem.eq
    ! if
      self read

      ret
    end

    "proc_" writer.write
    self read assemblerarm.classname @ str.data . writer.write
    name read
    do
      1 +
      copy readc '_' !=
    end
    writer.write

    ":\n    b proc_" writer.write

    name read writer.write
    "\n" writer.write

    self read

    ret
  end

  {
    ARGS: wordnode self
    RETS: success
  }
  oper proc addwordproc 3 0
    var self 8
    var node 8
    var name 8
    var nodep 8

    nodep swap put disc
    self swap put disc
    name swap put disc

    node nodep read slmnode.data @ put disc

    self read assemblerarm.proctab @
    name read
    map.getptr swap disc
    asmprocdata.kind @ 10 /% swap disc PNK_PUSH == if
      self read nodep read
      0 1 assemblerarm.updatestack

      "    push proc_" writer.write
      name read writer.write
      "\n" writer.write

      ret
    end

    self read nodep read

    self read assemblerarm.proctab @
    name read
    map.getptr swap disc
    copy asmprocdata.in @
    swap asmprocdata.out @
    assemblerarm.updatestack

    ".blockstart_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write
    "    ldr r1, ret_stack_rsp\n" writer.write
    "    ldr r1, [r1]\n" writer.write
    "    add r1, #16\n" writer.write
    "    ldr r2, #[loc_stack_rsp]\n" writer.write
    "    sub r1, #8\n" writer.write
    "    str r2, [r1]\n" writer.write
    "    str r1, #[ret_stack_rsp]\n" writer.write
    "    add r1, #8\n" writer.write
    "    ldr r2, .blockend_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    "\n" writer.write
    "    str r2, [r1]\n" writer.write
    "    b proc_" writer.write
    name read writer.write
    "\n" writer.write
    ".blockend_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write

    self read assemblerarm.lastblock .
    copy read 1 +
    put disc

    ret
  end

  {
    ARGS: self node 
    RETS: self node
  }
  oper proc addprochead 2 2
    var self 8
    var node 8
    var nametmp 8

    nametmp assemblerarm.MAX_NAME_SIZE heap.zalloc put disc
    node swap put disc
    self swap put disc

    self read assemblerarm.procname @ str.size . 0 put disc

    self read assemblerarm.procdata . asmprocdata.kind .
    node read blockdata.blockmisc @
    put disc

    self read assemblerarm.lastblock . 0 put disc

    node read blockdata.blockin @ str.data . cstr.int
    self read assemblerarm.procdata . asmprocdata.in .
    covr
    put disc
    self read assemblerarm.depth .
    swap
    put disc

    node read blockdata.blockout @ str.data . cstr.int
    self read assemblerarm.procdata . asmprocdata.out .
    covr
    put disc
    self read assemblerarm.procout .
    swap
    put disc

    node read blockdata.blockmisc @
    copy PNK_OHEAD <
    swap PNK_PHEAD > || if
      "proc_" writer.write
    end

    node read blockdata.blockmisc @
    copy PNK_OUNSAFE < !
    swap PNK_PUNSAFE > ! && if
      self read assemblerarm.procout . 255 put disc
    end

    self read assemblerarm.classname @
    copy NULL != if
      assemblerarm.internalname str.data .
      self read assemblerarm.procname @
      swap str.catc
      "_" str.catc
      self read assemblerarm.procname . swap put disc
      0
    end
    disc

    node read blockdata.blockname @
    assemblerarm.internalname str.data .

    self read assemblerarm.procname @
    swap str.catc
    self read assemblerarm.procname . swap put disc

    self read assemblerarm.procname @
    copy str.data .
    swap str.size @ +
    0 putc disc

    nametmp read
    self read assemblerarm.procname @ str.data .
    self read assemblerarm.procname @ str.size @
    mem.cpy

    self read assemblerarm.proctab @
    nametmp read
    self read assemblerarm.procdata .
    map.append disc

    node read blockdata.blockmisc @
    copy PNK_OHEAD <
    swap PNK_PHEAD > || ! if
      "; head" writer.write
    end
    nametmp read writer.write
    ":\n" writer.write

    self read
    node read

    ret
  end

  {
    ARGS: self name 
    RETS: fullname
  }
  oper proc getfullname 2 1
    var string 8
    var name 8
    var self 8

    name swap put disc
    self swap put disc

    string assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

    string read
    self read assemblerarm.classname @
    copy NULL != if
      str.data . cstr.cpy

      string read
      "_" cstr.cat
      disc
    end
    disc disc

    string read
    name read
    cstr.cat
    disc

    string read

    ret
  end

  {
    ARGS: self node
    RETS:
  }
  oper proc visitof 2 0
    var nodep 8
    var node 8
    var self 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNIMP
    "Inheritance is unimplemented as of now"

    error.new
    error.eval
    
    ret
  end

  {
    ARGS: self word
    RETS:
  }
  oper proc visitword 2 0
    var word 8
    var self 8
    var string 8
    var intern 8
    var nametmp 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    word node read constdata.constvalue @ str.data . put disc

    nametmp assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

    string str.new put disc
    string read
    word read cstr.len
    word read
    str.sput disc

    intern
    string read
    assemblerarm.internalname
    put disc

    nametmp read
    intern read str.data .
    intern read str.size @
    mem.cpy

    nametmp read

    self read assemblerarm.consttab @ covr map.in if
      self read NULL
      0 1 assemblerarm.updatestack

      nametmp read
      map.getptr read
      "    ldr r1, #" writer.write
      int.cstr writer.write
      "\n    push {r1}\n" writer.write
      disc disc

      ret
    end
    disc
    self read assemblerarm.vartab @ covr map.in if
      self read NULL
      0 1 assemblerarm.updatestack

      nametmp read
      map.getptr read
      "    push mem+" writer.write
      int.cstr writer.write
      "; " writer.write
      covr writer.write
      "\n" writer.write
      disc disc

      ret
    end
    disc
    self read assemblerarm.lvartab @ covr map.in if
      self read NULL
      0 1 assemblerarm.updatestack

      covr map.getptr read
      "    ldr r1, [ret_stack_rsp]\n" writer.write
      "    sub r1, #8\n" writer.write
      "    ldr r1, #[r1]\n" writer.write
      "    add r1, " writer.write
      int.cstr writer.write "\n" writer.write
      "    push {r1}\n" writer.write
      disc disc

      ret
    end
    disc
    self read assemblerarm.proctab @ covr map.in if
      disc disc

      nametmp read
      self read
      nodep read
      assemblerarm.addwordproc

      ret
    end
    disc disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED

    str.new
    "Word '" str.catc
    node read constdata.constvalue @ str.data . str.catc
    "'is not defined" str.catc
    str.data .

    error.new
    error.eval

    ret
  end

  oper proc visitconst 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read constdata.constkind @
    copy CNK_NUMBER == if
      disc

      self read nodep read
      0 1 assemblerarm.updatestack

      "    ldr r1, #" writer.write
      node read constdata.constvalue @ str.data . writer.write
      "\n    push {r1}\n" writer.write

      ret
    end
    copy CNK_STRING == if
      disc

      self read nodep read
      0 1 assemblerarm.updatestack

      "    push str_" writer.write
      node read constdata.constvalue . writer.addstr
      "\n" writer.write

      ret
    end
    copy CNK_SSTRING == if
      disc

      self read nodep read
      0 2 assemblerarm.updatestack

      "    ldr #" writer.write
      node read constdata.constvalue @ writer.getlen int.cstr writer.write
      "\n" writer.write
      "    push {r1}\n" writer.write
      "    push str_" writer.write
      node read constdata.constvalue . writer.addstr
      "\n" writer.write

      ret
    end
    copy CNK_WORD == if
      disc

      self read
      nodep read
      assemblerarm.visitword

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreachable assemblerarm.visitword"

    error.new
    error.eval

    ret
  end

  oper proc visitdef 2 0
    var self 8
    var node 8
    var nodep 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read defdata.defkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read defdata.defname @ str.data .
      assemblerarm.getfullname
      put disc

      def
      node read defdata.defvalue @ str.data . cstr.int
      put disc

      self read assemblerarm.consttab @
      full read
      def
      map.append
      disc

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assemblerarm.visitdef"

    error.new
    error.eval

    ret
  end

  oper proc visitprop 2 0
    var self 8
    var nodep 8
    var node 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read propdata.propkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read propdata.propname @ str.data .
      assemblerarm.getfullname
      put disc

      self read assemblerarm.consttab @
      full read
      self read assemblerarm.classsize .
      map.append
      disc

      self read assemblerarm.classsize .
      node read propdata.propvalue @ str.data . cstr.int
      self read assemblerarm.classsize @ +
      put disc

      ret
    end
    copy CNK_WORD == if
      disc

      full
      self read
      node read propdata.propname @ str.data .
      assemblerarm.getfullname
      put disc

      self read assemblerarm.classsize .

      self read nodep read
      node read propdata.propvalue @
      assemblerarm.internalname
      str.data .
      assemblerarm.getconst

      self read assemblerarm.classsize @ +
      put disc

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assemblerarm.visitprop"

    error.new
    error.eval

    ret
  end

  oper proc visitvar 2 0
    var self 8
    var node 8
    var nodep 8
    var full 8
    var def 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    self read assemblerarm.procname @ str.size @ 0 != if
      node read vardata.varkind @
      copy CNK_NUMBER == if
        disc

        full assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

        full read
        node read vardata.varname @ str.data .
        cstr.cpy disc disc

        self read assemblerarm.lvartab @
        full read
        self read assemblerarm.proclmem .
        map.append
        disc

        node read vardata.varvalue @
        "    mov r1, [loc_stack_rsp]\n" writer.write
        "    add r1, " writer.write
        str.data . writer.write
        "\n" writer.write
        "    mov [loc_stack_rsp], r1\n" writer.write

        self read assemblerarm.proclmem .
        self read assemblerarm.proclmem @
        node read vardata.varvalue @ str.data . cstr.int +
        put disc

        ret
      end
      copy CNK_WORD == if
        disc

        full assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

        full read
        node read vardata.varname @ str.data .
        cstr.cpy disc disc

        self read assemblerarm.lvartab @
        full read
        self read assemblerarm.proclmem .
        map.append
        disc

        self read nodep read
        node read vardata.varvalue @
        assemblerarm.internalname
        str.data .
        assemblerarm.getconst
        "    mov r1, [loc_stack_rsp]\n" writer.write
        "    add r1, " writer.write
        int.cstr writer.write
        "\n" writer.write
        "    mov [loc_stack_rsp], r1\n" writer.write

        self read assemblerarm.proclmem .
        self read assemblerarm.proclmem @
        self read nodep read
        node read vardata.varvalue @
        assemblerarm.internalname
        str.data .
        assemblerarm.getconst +
        put disc

        ret
      end
      disc

      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      "Unreacable assemblerarm.visitvar local"

      error.new
      error.eval

      ret
    end

    node read vardata.varkind @
    copy CNK_NUMBER == if
      disc

      full
      self read
      node read vardata.varname @ str.data .
      assemblerarm.getfullname
      put disc

      self read assemblerarm.vartab @
      full read
      writer.mem
      map.append
      disc

      writer.mem
      node read vardata.varvalue @ str.data . cstr.int
      writer.mem read +
      put disc

      ret
    end
    copy CNK_WORD == if
      disc

      full
      self read
      node read vardata.varname @ str.data .
      assemblerarm.getfullname
      put disc

      self read assemblerarm.vartab @
      full read
      writer.mem
      map.append
      disc

      writer.mem
      self read nodep read
      node read vardata.varvalue @
      assemblerarm.internalname
      str.data .
      assemblerarm.getconst
      writer.mem read +
      put disc

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Unreacable assemblerarm.visitvar global"

    error.new
    error.eval

    ret
  end

  oper proc visitcall 2 0
    var self 8
    var node 8
    var nodep 8
    var internal 8
    var callee 8
    var data 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    callee assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

    node read calldata.callee @ str.size @
    0 == if
      ".blockstart_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; call\n" writer.write
      "    pop r3\n" writer.write
      "    mov r1, [ret_stack_rsp]\n" writer.write
      "    add r1, 16\n" writer.write
      "    mov r2, [loc_stack_rsp]\n" writer.write
      "    mov [r1 - 8], r2\n" writer.write
      "    mov [ret_stack_rsp], r1\n" writer.write
      "    mov [r1], .blockend_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      "\n" writer.write
      "    b r3\n" writer.write
      ".blockend_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; call\n" writer.write

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc

      callee read heap.free

      ret
    end

    internal
    node read calldata.callee @
    assemblerarm.internalname
    put disc

    callee read
    internal read str.data .
    cstr.cpy disc disc

    self read assemblerarm.proctab @
    callee read map.in swap disc ! if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNDEFINED
      str.new
      "proc '" str.catc
      callee read str.catc
      "' not defined" str.catc
      str.data .

      error.new
      error.eval
    end

    data
    self read assemblerarm.proctab @
    callee read
    map.getptr swap disc
    put disc

    data read asmprocdata.kind @ 10 /% swap disc
    PNK_OPER == if
      self read nodep read
      0 1 assemblerarm.updatestack

      "    push proc_" writer.write
      callee read writer.write
      "\n" writer.write

      internal read heap.free
      callee read heap.free

      ret
    end

    self read nodep read
    data read asmprocdata.in @
    data read asmprocdata.out @
    assemblerarm.updatestack

    ".blockstart_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write
    "    mov r1, [ret_stack_rsp]\n" writer.write
    "    add r1, 16\n" writer.write
    "    mov r2, [loc_stack_rsp]\n" writer.write
    "    mov [r1 - 8], r2\n" writer.write
    "    mov [ret_stack_rsp], [r1]\n" writer.write
    "    mov [r1], .blockend_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    "\n" writer.write
    "    b proc_" writer.write
    callee read writer.write
    "\n" writer.write
    ".blockend_" writer.write
    self read assemblerarm.lastblock @ int.cstr writer.write
    ": ; call\n" writer.write

    self read assemblerarm.lastblock .
    copy read 1 +
    put disc

    internal read heap.free
    callee read heap.free

    ret
  end

  oper proc visitintr 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read intrdata.intrkind @
    copy INK_RETURN == if
      disc

      self read assemblerarm.didret . bool.true putc disc

      self read assemblerarm.depth @
      self read assemblerarm.procout @ !=
      self read assemblerarm.procout @ 255 != &&
      if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Proc dosent return correct ammount"

        error.new
        error.eval
      end

      "    ldr r1, =ret_stack_rsp\n" writer.write
      "    sub r1, #8\n" writer.write
      "    ldr r1, [r1]\n" writer.write
      "    ldr r2, loc_stack_rsp\n" writer.write
      "    str r1, [r2]\n" writer.write
      "    ldr r1, =ret_stack_rsp\n" writer.write
      "    sub r1, #16\n" writer.write
      "    ldr r2, ret_stack_rsp\n" writer.write
      "    str r1, [r2]\n" writer.write
      "    ldr r1, #16\n" writer.write
      "    b [r1]\n" writer.write

      ret
    end
    copy INK_COPY == if
      disc

      self read nodep read
      1 2 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    push {r1}\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_DISC == if
      disc

      self read nodep read
      1 0 assemblerarm.updatestack
      "    pop {r1}\n" writer.write

      ret
    end
    copy INK_ARGC == if
      disc

      self read nodep read
      0 1 assemblerarm.updatestack
      "    mov r1, [args_ptr]\n" writer.write
      "    mov r1, [r1]\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_ARGV == if
      disc

      self read nodep read
      0 1 assemblerarm.updatestack
      "    mov r1, [args_ptr]\n" writer.write
      "    add r1, 8\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_ENVP == if
      disc

      self read nodep read
      0 1 assemblerarm.updatestack
      "    mov r1, [args_ptr]\n" writer.write
      "    mov r1, [r1]\n" writer.write
      "    add r1, 2\n" writer.write
      "    shl r1, 3\n" writer.write
      "    mov r2, [args_ptr]\n" writer.write
      "    add r2, r1\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_QUIT == if
      disc

      self read assemblerarm.didret . bool.true putc disc

      self read nodep read
      1 0 assemblerarm.updatestack
      "    mov r1, 60\n" writer.write
      "    pop rdi\n" writer.write
      "    syscall\n" writer.write

      ret
    end
    copy INK_SWAP == if
      disc

      self read nodep read
      2 2 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    push {r1}\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_COVR == if
      disc

      self read nodep read
      2 3 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    push {r2}\n" writer.write
      "    push {r1}\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_READ == if
      disc

      self read nodep read
      1 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    mov r2, [r1]\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_READC == if
      disc

      self read nodep read
      1 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    xor r2, r2\n" writer.write
      "    mov bl, [r1]\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_PUT == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    str r2, [r1]\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_PUTC == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    strb r2, [r1]\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_EQ == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    xor r3, r3\n" writer.write
      "    mov r4, 1\n" writer.write
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    cmp r1, r2\n" writer.write
      "    cmove r3, r4\n" writer.write
      "    push r3\n" writer.write

      ret
    end
    copy INK_NEQ == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    xor r3, r3\n" writer.write
      "    mov r4, 1\n" writer.write
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    cmp r1, r2\n" writer.write
      "    cmovne r3, r4\n" writer.write
      "    push r3\n" writer.write

      ret
    end
    copy INK_LT == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    xor r3, r3\n" writer.write
      "    mov r4, 1\n" writer.write
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    cmp r1, r2\n" writer.write
      "    cmovl r3, r4\n" writer.write
      "    push r3\n" writer.write

      ret
    end
    copy INK_GT == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    xor r3, r3\n" writer.write
      "    mov r4, 1\n" writer.write
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    cmp r1, r2\n" writer.write
      "    cmovg r3, r4\n" writer.write
      "    push r3\n" writer.write

      ret
    end
    copy INK_NOT == if
      disc

      self read nodep read
      1 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    xor r1, 1\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_INV == if
      disc

      self read nodep read
      1 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    not r1\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_AND == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    and r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_OR == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    or r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_ACCESS == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    add r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_REFACCESS == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    add r1, r2\n" writer.write
      "    mov r2, [r1]\n" writer.write
      "    push {r2}\n" writer.write

      ret
    end
    copy INK_ADD == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    add r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SUB == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    sub r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_MUL == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop {r2}\n" writer.write
      "    mul r1, r2\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_DIVMOD == if
      disc

      self read nodep read
      2 2 assemblerarm.updatestack
      "    xor r4, r4\n" writer.write
      "    pop {r2}\n" writer.write
      "    pop {r1}\n" writer.write
      "    idiv r2\n" writer.write
      "    push {r1}\n" writer.write
      "    push r4\n" writer.write

      ret
    end
    copy INK_SYS0 == if
      disc

      self read nodep read
      1 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS1 == if
      disc

      self read nodep read
      2 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS2 == if
      disc

      self read nodep read
      3 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS3 == if
      disc

      self read nodep read
      4 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop r4\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS4 == if
      disc

      self read nodep read
      5 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop r4\n" writer.write
      "    pop {r1}0\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS5 == if
      disc

      self read nodep read
      6 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop r4\n" writer.write
      "    pop {r1}0\n" writer.write
      "    pop r8\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    copy INK_SYS6 == if
      disc

      self read nodep read
      7 1 assemblerarm.updatestack
      "    pop {r1}\n" writer.write
      "    pop rdi\n" writer.write
      "    pop rsi\n" writer.write
      "    pop r4\n" writer.write
      "    pop {r1}0\n" writer.write
      "    pop r8\n" writer.write
      "    pop r9\n" writer.write
      "    syscall\n" writer.write
      "    push {r1}\n" writer.write

      ret
    end
    disc

    nodep read slmnode.start .
    nodep read slmnode.stop .
    error.EK_UNDEFINED
    "Intrinsic action not defined"

    error.new
    error.eval

    ret
  end

  oper proc visitasm 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    "    " writer.write
    node read asmdata.raw @ str.data . writer.write
    "\n" writer.write

    ret
  end

  oper proc visitinc 2 0
    var self 8
    var node 8
    var subnode 8
    var nodep 8
    var file 8
    var name 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    file
    self read assemblerarm.filename @
    put disc

    name assemblerarm.MAX_NAME_SIZE heap.zalloc put disc

    name read
    node read incdata.include @ str.data .
    cstr.cpy disc disc

    self read assemblerarm.includedtab @
    name read
    map.in swap disc if
      name read heap.free
      ret
    end

    self read assemblerarm.includedtab @
    name read
    "y"
    map.append
    disc

    name read
    bool.true
    lexer.new lexer.run
    parser.new parser.run

    copy subnode swap put disc

    self read swap
    assemblerarm.visitnode

    self read assemblerarm.filename .
    file read
    put disc

    name read heap.free
    {subnode read slmnode.free}

    ret
  end

  oper proc visitfile 2 0
    var self 8
    var node 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    "[ASM] " cstr.print
    node read filedata.filename @ str.print
    "\n" cstr.print

    self read assemblerarm.filename .
    node read filedata.filename @
    put disc

    node read filedata.childcount @
    0 == if ret end

    0
    do
      node read filedata.children .
      covr 8 * + read

      self read swap
      assemblerarm.visitnode

      1 +
      node read filedata.childcount @
      covr >
    end
    disc

    ret
  end

  oper proc visitenum 2 0
    var self 8
    var node 8
    var value 8
    var string 8
    var nodep 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    value 0 put disc

    node read blockdata.childcount @
    0 == if ret end

    0
    do
      node read blockdata.children .
      covr 8 * + read
      slmnode.data @ copy
      constdata.constkind @ swap
      covr CNK_NUMBER == if
        value
        covr constdata.constvalue @ str.data . cstr.int
        put disc
      end
      covr CNK_WORD == if
        self read
        covr constdata.constvalue @ str.data .
        assemblerarm.getfullname

        self read assemblerarm.consttab @
        swap
        value
        map.append disc

        value
        copy read 1 +
        put disc
      end
      disc disc
      {TODO: ERROR}

      1 +
      node read blockdata.childcount @
      covr >
    end
    disc

    ret
  end

  {TODO: visitsim}

  oper proc visitblock 2 0
    var node 8
    var nodep 8
    var self 8
    var stop 8
    var oldret 1
    var olddepth 8
    var wordtmp 8
    var oldprocout 8

    nodep swap put disc
    self swap put disc

    node nodep read slmnode.data @ put disc

    node read blockdata.blockkind @
    BNK_PROC == if
      self read node read
      assemblerarm.addprochead
      disc disc

      node read blockdata.childcount @
      0 == if
        self read assemblerarm.proclmem . 0 put disc
        self read assemblerarm.procname @ str.size . 0 put disc
        ret
      end
    end

    node read blockdata.blockkind @
    copy BNK_SIM == if
      nodep read slmnode.start .
      nodep read slmnode.stop .
      error.EK_UNIMP
      "Simulator is unimplemented as of now"

      error.new
      error.eval
    end
    copy BNK_CLASS == if
      self read assemblerarm.classsize . 0 put disc

      self read assemblerarm.classname .
      node read blockdata.blockname @
      put disc

      self read
      "SIZE"
      assemblerarm.getfullname
      self read assemblerarm.consttab @
      covr map.in swap disc if
        self read assemblerarm.consttab @
        covr map.getptr read swap disc
        self read assemblerarm.classsize .
        swap put disc
      end
      disc
    end
    copy BNK_ENUM == if
      disc
      self read nodep read
      assemblerarm.visitenum
      ret
    end
    copy BNK_IF == if
      self read nodep read
      1 0 assemblerarm.updatestack

      "    pop {r2}\n" writer.write
      "    test r2, r2\n" writer.write
      ".blockstart_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; if\n" writer.write
      "    jz .blockend_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      "\n" writer.write

      stop
      self read assemblerarm.lastblock @
      put disc

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_DO == if
      ".blockstart_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; do\n" writer.write

      stop
      self read assemblerarm.lastblock @
      put disc

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_LAMBDA == if
      "    b .blockend_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ".blockstart_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; lambda\n" writer.write

      stop
      self read assemblerarm.lastblock @
      put disc

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc
    end
    copy BNK_PLAMBDA == if
      "    b .blockend_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      "\n.blockstart_" writer.write
      self read assemblerarm.lastblock @ int.cstr writer.write
      ": ; plambda\n" writer.write

      stop
      self read assemblerarm.lastblock @
      put disc

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc

      oldprocout
      self read assemblerarm.procout @
      put disc

      self read assemblerarm.procout .
      self read assemblerarm.depth @
      put disc
    end
    disc


    oldret
    self read assemblerarm.didret . readc
    putc disc
    olddepth
    self read assemblerarm.depth @
    put disc

    self read assemblerarm.didret . 0 putc disc

    0
    do
      node read blockdata.children .
      covr 8 * + read

      self read swap
      assemblerarm.visitnode

      1 +
      node read blockdata.childcount @
      covr >
    end
    disc

    node read blockdata.blockkind @
    copy BNK_CLASS == if
      self read "SIZE"
      assemblerarm.getfullname

      self read assemblerarm.consttab @
      swap
      self read assemblerarm.classsize .
      map.append
      disc

      self read assemblerarm.classname .
      0
      put disc
    end
    copy BNK_IF == if
      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; if\n" writer.write

      self read assemblerarm.didret . readc ! if
        olddepth read
        self read assemblerarm.depth @ !=
        self read assemblerarm.procout @ 255 != && if
          nodep read slmnode.start .
          nodep read slmnode.stop .
          error.EK_BADBLOCK
          "If statement changes stack position"

          error.new
          error.eval
        end
      end
    end
    copy BNK_LAMBDA == if
      self read nodep read
      0 1 assemblerarm.updatestack

      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; lambda\n" writer.write
      "    push .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write
    end
    copy BNK_PLAMBDA == if
      self read assemblerarm.procout .
      oldprocout read
      put disc

      self read nodep read
      0 1 assemblerarm.updatestack

      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; plambda\n" writer.write
      "    push .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write

      word
      nodep read slmnode.start .
      nodep read slmnode.stop .
      CNK_WORD
      node read blockdata.blockname @
      constdata.new
      slmnode.new
      put disc

      self read word read assemblerarm.visitword

      word read slmnode.free

      self read assemblerarm.lastblock .
      copy read 1 +
      put disc

      disc
      ret
    end
    copy BNK_DO == if
      self read nodep read
      1 0 assemblerarm.updatestack

      "    pop {r2}\n" writer.write
      "    test r2, r2\n" writer.write
      "    jnz .blockstart_" writer.write
      stop read int.cstr writer.write
      "\n" writer.write
      ".blockend_" writer.write
      stop read int.cstr writer.write
      ": ; do\n" writer.write

      olddepth read
      self read assemblerarm.depth @ !=
      self read assemblerarm.procout @ 255 != && if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Do statement changes stack position"

        error.new
        error.eval
      end
    end
    copy BNK_PROC == if
      self read assemblerarm.didret . readc ! if
        nodep read slmnode.start .
        nodep read slmnode.stop .
        error.EK_BADBLOCK
        "Proc dosent return or quit"

        error.new
        error.eval
      end

      self read assemblerarm.proclmem . 0 put disc
      self read assemblerarm.procname @ str.size . 0 put disc
    end
    disc

    self read assemblerarm.didret .
    oldret readc
    putc disc
    self read assemblerarm.depth .
    olddepth read
    put disc

    ret
  end

  oper proc visitnode 2 0
    copy slmnode.data @
    nodedata.kind @
    copy SNK_INC == if
      disc
      assemblerarm.visitinc

      ret
    end
    copy SNK_COMMENT == if
      disc disc disc

      ret
    end
    copy SNK_FILE == if
      disc
      assemblerarm.visitfile

      ret
    end
    copy SNK_BLOCK == if
      disc
      assemblerarm.visitblock

      ret
    end
    copy SNK_CONST == if
      disc
      assemblerarm.visitconst

      ret
    end
    copy SNK_DEF == if
      disc
      assemblerarm.visitdef

      ret
    end
    copy SNK_ASM == if
      disc
      assemblerarm.visitasm

      ret
    end
    copy SNK_INTR == if
      disc
      assemblerarm.visitintr

      ret
    end
    copy SNK_PROP == if
      disc
      assemblerarm.visitprop

      ret
    end
    copy SNK_VAR == if
      disc
      assemblerarm.visitvar

      ret
    end
    copy SNK_CALL == if
      disc
      assemblerarm.visitcall

      ret
    end
    copy SNK_OF == if
      disc
      assemblerarm.visitof

      ret
    end
    disc

    disc disc

    ret
  end
end
