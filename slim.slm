inc lib/stdlib.slm
inc lib/tables.slm

{The Slim Compiler, written in Slim}

const OP_BAD   255
const OP_NOP   0
const OP_PUSH  1
const OP_SUB   2
const OP_MUL   3
const OP_PLUS  4
const OP_SWAP  5
const OP_DUMP  6
const OP_COPY  7 
const OP_COVR  8
const OP_GPTR  9 
const OP_READ  10
const OP_PUTC  11
const OP_DISC  12
const OP_ARGV  13
const OP_ARGC  14
const OP_PUSHP 15
const OP_CALLS 16
const OP_MULTI 17
const OP_CONST 18
const OP_CALL  19
const OP_PROC  20
const OP_RET   21
const OP_QUIT  22
const OP_LOCX  23
const OP_JUMPX 24
const OP_JUMP  25
const OP_IF    26
const OP_JNZ   27
const OP_GETP  28
const OP_CYCL  29
const OP_NQ    30
const OP_EQ    31
const OP_LT    32
const OP_GT    33
const OP_AND   34
const OP_SYS0  35
const OP_SYS1  36
const OP_SYS2  37
const OP_SYS3  38
const OP_SYS4  39
const OP_SYS5  40
const OP_SYS6  41
const OP_PUT   42
const OP_DIV   43
const OP_ENVP  44

const IDENT_INC 45
const IDENT_PROC 46
const IDENT_DO 47
const IDENT_END 48

proc getconstTab 0 1
  var 300000
  ret
end

proc getprocTab 0 1
  var 300000
  ret
end

proc getcmdbuffer 0 1
  var 1024
  ret
end

proc getblockbuffer 0 1
  var 1024
  ret
end

proc getreadbuffer 0 1
  var 1024
  ret
end

proc getstringbuffer 0 1
  var 100000

  ret
end

proc getinputfd 0 1
  var 8
  ret
end

const READSIZE 1023

proc getescape 1 1
  copy 110 == if [ disc 10 ret ]
  copy 164 == if [ disc 9 ret ]
  ret
end

proc getnameop 1 1
  OP_BAD
  covr read 255 && 123 == if [disc OP_NOP]
  covr "do"    (streq) if [disc IDENT_DO]  
  covr "end"   (streq) if [disc IDENT_END]  
  covr "inc"   (streq) if [disc IDENT_INC]  

  covr "nop"   (streq) if [disc OP_NOP]
  covr "}"     (streq) if [disc OP_NOP]
  covr "-"     (streq) if [disc OP_SUB]  
  covr "*"     (streq) if [disc OP_MUL]  
  covr "/"     (streq) if [disc OP_DIV]
  covr "+"     (streq) if [disc OP_PLUS]
  covr "swap"  (streq) if [disc OP_SWAP]
  covr "dump"  (streq) if [disc OP_DUMP] 
  covr "copy"  (streq) if [disc OP_COPY] 
  covr "covr"  (streq) if [disc OP_COVR] 
  covr "var"   (streq) if [disc OP_GPTR] 
  covr "read"  (streq) if [disc OP_READ] 
  covr "putc"  (streq) if [disc OP_PUTC] 
  covr "put"   (streq) if [disc OP_PUT]  
  covr "disc"  (streq) if [disc OP_DISC] 
  covr "argv"  (streq) if [disc OP_ARGV] 
  covr "argc"  (streq) if [disc OP_ARGC] 
  covr "envp"  (streq) if [disc OP_ENVP]  
  covr "()"    (streq) if [disc OP_CALLS] 
  covr "const" (streq) if [disc OP_CONST]
  covr "proc"  (streq) if [disc OP_PROC]
  covr "ret"   (streq) if [disc OP_RET] 
  covr "quit"  (streq) if [disc OP_QUIT]  
  covr "if"    (streq) if [disc OP_IF] 
  covr "cycl"  (streq) if [disc OP_CYCL] 
  covr "!="    (streq) if [disc OP_NQ] 
  covr "=="    (streq) if [disc OP_EQ]   
  covr "<"     (streq) if [disc OP_LT]   
  covr ">"     (streq) if [disc OP_GT]   
  covr "&&"    (streq) if [disc OP_AND]  
  covr "sys0"  (streq) if [disc OP_SYS0]
  covr "sys1"  (streq) if [disc OP_SYS1]  
  covr "sys2"  (streq) if [disc OP_SYS2]  
  covr "sys3"  (streq) if [disc OP_SYS3]  
  covr "sys4"  (streq) if [disc OP_SYS4]  
  covr "sys5"  (streq) if [disc OP_SYS5]  
  covr "sys6"  (streq) if [disc OP_SYS6]  
  swap disc

  ret
end

proc getopname 1 1
  "bad"
  covr OP_NOP   == if [disc "nop"]
  covr OP_PUSH  == if [disc "push"]
  covr OP_SUB   == if [disc "sub"]
  covr OP_MUL   == if [disc "mul"]
  covr OP_PLUS  == if [disc "plus"]
  covr OP_SWAP  == if [disc "swap"]
  covr OP_DUMP  == if [disc "dump"]
  covr OP_COPY  == if [disc "copy"]
  covr OP_COVR  == if [disc "covr"]
  covr OP_GPTR  == if [disc "gptr"]
  covr OP_READ  == if [disc "read"]
  covr OP_PUTC  == if [disc "putc"]
  covr OP_PUT   == if [disc "put"]
  covr OP_DISC  == if [disc "disc"]
  covr OP_ARGV  == if [disc "argv"]
  covr OP_ARGC  == if [disc "argc"]
  covr OP_ENVP  == if [disc "envp"]
  covr OP_PUSHP == if [disc "push"]
  covr OP_CALLS == if [disc "call"]
  covr OP_MULTI == if [disc "[]"]
  covr OP_CONST == if [disc "const"]
  covr OP_CALL  == if [disc "call"]
  covr OP_PROC  == if [disc "proc"]
  covr OP_RET   == if [disc "ret"]
  covr OP_QUIT  == if [disc "quit"]
  covr OP_LOCX  == if [disc "location"]
  covr OP_JUMPX == if [disc "jump"]
  covr OP_JUMP  == if [disc "jump"]
  covr OP_IF    == if [disc "if"]
  covr OP_JNZ   == if [disc "jnz"]
  covr OP_GETP  == if [disc "getp"]
  covr OP_CYCL  == if [disc "cycl"]
  covr OP_NQ    == if [disc "!="]
  covr OP_EQ    == if [disc "=="]
  covr OP_LT    == if [disc "<"]
  covr OP_GT    == if [disc ">"]
  covr OP_AND   == if [disc "&&"]
  covr OP_SYS0  == if [disc "sys0"]
  covr OP_SYS1  == if [disc "sys1"]
  covr OP_SYS2  == if [disc "sys2"]
  covr OP_SYS3  == if [disc "sys3"]
  covr OP_SYS4  == if [disc "sys4"]
  covr OP_SYS5  == if [disc "sys5"]
  covr OP_SYS6  == if [disc "sys6"]
  swap disc
  ret
end

proc identstack 0 1
  var 64
  ret
end

proc identstackrsp 0 1
  var 8
  ret
end

proc identstackpush 1 0
  (identstackrsp) read (identstack) +
  swap
  put disc

  (identstackrsp) read
  8 +
  (identstackrsp) swap put disc
  ret
end

proc identstackpop 0 1
  (identstackrsp) read 0 != "stack underflow" (assert)
  (identstackrsp) read
  8 -
  (identstackrsp) swap put disc

  (identstackrsp) read (identstack) +
  read

  ret
end

proc inner 1 1
  1 + copy
  copy (strlen) 1 - + 0 putc disc
  ret
end

proc getoutput 0 1
  var 128
  ret
end

proc getoutputfd 0 1
  var 8
  ret
end

proc getinput 0 1
  var 128
  ret
end

proc getsilent 0 1
  var 8
  ret
end

proc getcmdidx 0 1
  var 8
  ret
end

proc cmdflags 0 1
  var 8
  ret
end

proc addr 0 1
  var 8
  ret
end

proc stringidx 0 1
  var 8
  ret
end

proc progmemory 0 1
  var 8
  ret
end

proc subaddr 0 1
  var 8
  ret
end

proc getstringidx 0 1
  (stringidx) read
  copy 1 +
  (stringidx) swap put disc
  ret
end

proc getaddr 0 1
  (subaddr)
  0 put disc

  (addr) read
  copy 1 +
  (addr) swap put disc
  ret
end

proc getsubaddr 0 1
  (subaddr) read
  copy 1 +
  (subaddr) swap put disc
  ret
end

proc exit 0 0
  {close output}
  (getoutputfd) read
  copy != 0 if [(close) 0]
  disc
  
  {close input}
  (getinputfd) read
  copy != 0 if [(close) 0]
  disc

  quit
  ret
end

proc noproc 0 0
  "proc not found: " (print)
  (getcmdbuffer) 1 + (println)
  (exit)

  ret
end

proc writeout 1 0
  copy (strlen) swap (getoutputfd) read (write)
  ret
end

proc writeoutln 0 0
  "\n" 1 swap (getoutputfd) read (write)

  ret
end

proc addproc 1 0
  disc
  " " (writeout)
  (getcmdbuffer) (writeout)
  (cmdflags) copy read 255 &&
  copy 3 == if [
    "[SLM]\ " (print)
    (getcmdbuffer) (println)
    (getprocTab) (getcmdbuffer) (addr) read (putTab) disc
  ]
  copy 1 == if [
    (writeoutln)
  ]
  1 -
  putc disc

  ret
end

proc constname 0 1
  var 64

  ret
end

proc addconst 1 0
  disc

  (cmdflags)
  copy read 255 && 1 - copy 3 == if [
    (getconstTab) (constname) (getcmdbuffer) (tonum) (putTab) disc
    disc 0
  ] copy 4 == if [
    (getcmdbuffer) (constname) (clearbuf) swap (strcpy) disc disc
  ]
  putc disc

  ret
end

proc addinc 1 0
  disc
  
  (cmdflags)
  0
  putc disc

  ret
end

proc addvar 1 0
  disc
  
  "    mov rax, mem\n" (writeout)
  "    add rax, " (writeout)
  (progmemory) read (strint) (writeout)
  (writeoutln)
  "    push rax\n" (writeout)
  
  (getcmdbuffer) (tonum) 
  (progmemory) read +
  (progmemory) swap put
  disc
  
  (cmdflags)
  0
  putc disc

  ret
end

proc asmheader 0 0
    "BITS 64\n" (writeout)
    "segment .text\n" (writeout)
    "print:\n" (writeout)
    "    mov r10, rsp\n" (writeout)
    "    sub rsp, 8\n" (writeout)
    "    mov [rsp], al\n" (writeout)
    "    mov edi, 1\n" (writeout)
    "    mov rsi, rsp\n" (writeout)
    "    mov edx, 1\n" (writeout)
    "    mov eax, 1\n" (writeout)
    "    syscall\n" (writeout)
    "    mov rsp, r10\n" (writeout)
    "    ret\n" (writeout)
    ret
end

proc asmfooter 0 0
  "addr_" (writeout)
  (getaddr) (strint) (writeout)
  ":\n" (writeout)
  "    ret\n" (writeout)
  "global _start\n" (writeout)
  "_start:\n" (writeout)
  "    mov qword [args_ptr], rsp\n" (writeout)
  "    mov qword [ret_stack_rsp], ret_stack\n" (writeout)
  "    mov rax, [ret_stack_rsp]\n" (writeout)
  "    mov qword [rax], quit\n" (writeout)
  "    jmp addr_" (writeout)
  (getprocTab)
  "main" (inTab) 0 == if [
    "no main proc defined" (println)
    (exit)
  ]
  "main" (getTab) 1 - (strint) (writeout)
  (writeoutln)
  "quit:\n" (writeout)
  "    mov rax, 60\n" (writeout)
  "    mov rdi, 0x0\n" (writeout)
  "    syscall\n" (writeout)
  "segment .data\n" (writeout)
  (getstringbuffer) 1 + (writeout)
  "segment .bss\n" (writeout)
  "args_ptr: resq 1\n" (writeout)
  "ret_stack_rsp: resq 1\n" (writeout)
  "ret_stack: resb 25565\n" (writeout)
  "ret_stack_end: resb 25565\n" (writeout)
  "mem: resb " (writeout)
  (progmemory) read (strint) (writeout)
  (writeoutln)
  disc
  ret
end

proc endopasm 1 0
  copy IDENT_DO == if [
    "    pop rbx\n" (writeout)
    "    test rbx, rbx\n" (writeout)
    "    jz addr_" (writeout)
    (addr) read (strint) (writeout)
    (writeoutln)
    "    jmp addr_" (writeout)
    (identstackpop) (strint) (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc endopblockasm 1 0
  copy IDENT_DO == if [
    "    pop rbx\n" (writeout)
    "    test rbx, rbx\n" (writeout)
    "    jz addr_" (writeout)
    (addr) read 1 - (strint) (writeout)
    "_" (writeout)
    (subaddr) read (strint) (writeout)
    (writeoutln)
    "    jmp addr_" (writeout)
    (identstackpop) (strint) (writeout)
    "_" (writeout)
    (identstackpop) (strint) (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc writeaddr 0 0
  "addr_" (writeout)
  (getaddr) (strint) (writeout)
  ":" (writeout)
  (writeoutln)

  ret
end

proc writesubaddr 0 0
  "addr_" (writeout)
  (addr) read 1 - (strint) (writeout)
  "_" (writeout)
  (getsubaddr) (strint) (writeout)
  ":" (writeout)
  (writeoutln)

  ret
end

proc badblockop 0 0
  "BAD OPERATION: " (println)
  "`" (print) (getblockbuffer) (print) "`" (println)

  "chunk" (println)
  (getreadbuffer) (println)
  "block" (println)
  (getcmdbuffer) (println)
  (exit)

  ret
end

proc getblockasm 1 0
  (getblockbuffer) (alphanum) if [
    disc
    OP_PUSH
  ]
  
  (writesubaddr)

  copy OP_BAD == if [
    (getconstTab) (getblockbuffer) (inTab) 0 == if (badblockop)

    (getblockbuffer) (getTab) swap disc
    (strint)
    (getblockbuffer) (clearbuf) swap (strcpy) disc disc
    disc
    OP_PUSH
  ] copy OP_NOP == if [
    disc ret
  ] copy OP_PUSH == if [
    "    mov qword rax, " (writeout)
    (getblockbuffer) (writeout)
    (writeoutln)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_COPY == if [
    "    pop rax\n" (writeout)
    "    push rax\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_SWAP == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_SUB == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    sub rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_PLUS == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    add rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_AND == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    and rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_MUL == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    imul rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_DIV == if [
    "    xor rdx, rdx\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    idiv rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rdx\n" (writeout)
    disc ret
  ] copy OP_COVR == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    push rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_GPTR == if [
    (cmdflags)
    7
    putc disc
    disc ret
  ] copy OP_ARGC == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    mov rax, [rax]\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_ARGV == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_ENVP == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    mov rax, [rax]\n" (writeout)
    "    add rax, 2\n" (writeout)
    "    shl rax, 3\n" (writeout)
    "    mov rbx, [args_ptr]\n" (writeout)
    "    add rbx, rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_QUIT == if [
    "    jmp quit\n" (writeout)
    disc ret
  ] copy OP_RET == if [
    "    mov rax, [ret_stack_rsp]\n" (writeout)
    "    sub rax, 8\n" (writeout)
    "    mov qword [ret_stack_rsp], rax\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    jmp [rax]\n" (writeout)
    disc ret
  ] copy OP_DISC == if [
    "    pop rax\n" (writeout)
    disc ret
  ] copy OP_CONST == if [
    (cmdflags)
    5
    putc disc
    disc ret
  ] copy OP_READ == if [
    "    pop rax\n" (writeout)
    "    xor rbx, rbx\n" (writeout)
    "    mov rbx, [rax]\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_PUTC == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    mov byte [rax], bl\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_PUT == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    mov qword [rax], rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_NQ == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovne rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_EQ == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmove rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_GT == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovg rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_LT == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovl rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_IF == if [
    "    pop rbx\n" (writeout)
    "    test rbx, rbx\n" (writeout)
    "    jz addr_" (writeout)
    (addr) read 1 - (strint) (writeout)
    "_" (writeout)
    (subaddr) read 1 + (strint) (writeout)
    (writeoutln)
    disc ret
  ] copy OP_SYS0 == if [
    "    pop rax\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS1 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS2 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS3 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS4 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS5 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    pop r8\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS6 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    pop r8\n" (writeout) 
    "    pop r9\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_DUMP == if [
    "    pop rax\n" (writeout) 
    "    call print\n" (writeout)
    disc ret
  ] copy IDENT_INC == if [
    (cmdflags)
    6
    putc disc
    disc ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopblockasm)
    disc ret
  ] copy IDENT_DO == if [
    (subaddr) read 1 - (identstackpush)
    (addr) read 1 - (identstackpush)
    IDENT_DO (identstackpush) 
    disc ret
  ]
  "; unimp " (writeout)
  (getopname) (writeout)
  " " (writeout)
  (getcmdbuffer) (writeout)
  (writeoutln)
  ret
end

proc parsecall 0 0
  { add code }
  "    push str_" (writeout)
  (getstringidx) (strint) (writeout)
  (writeoutln)

  { put the header }
  "str_"
  (getstringbuffer) copy (strlen) + 
  swap (strcpy) disc disc
  
  (stringidx) read 1 - (strint)
  (getstringbuffer) copy (strlen) + 
  swap (strcpy) disc disc
  
  ": db "
  (getstringbuffer) copy (strlen) + 
  swap (strcpy) disc disc
  (getblockbuffer) (inner)

  { put the first char }
  copy read 255 &&
  (strint)
  (getstringbuffer) copy (strlen) + 
  swap (strcpy) disc disc
  do
    1 +

    { comma }
    ", "
    (getstringbuffer) copy (strlen) +
    swap (strcpy) disc disc

    { put the next char }
    copy read 255 &&
    copy (strint)
    (getstringbuffer) copy (strlen) +
    swap (strcpy) disc disc
  end
  "\n"
  (getstringbuffer) copy (strlen) +
  swap (strcpy) disc disc
  disc

  (getblockbuffer) (clearbuf) disc
  ret
end

proc parseblockcmd 0 0
  (getblockbuffer) read 255 && 123 == (getblockbuffer) (last) 125 == && if [

    (getblockbuffer) (clearbuf) disc
  ] (getblockbuffer) read 255 && 34 == (getblockbuffer) (last) 34 == && if [
    (writesubaddr)
    (parsecall)

    ret
  ] (getblockbuffer) read 255 && 40 == (getblockbuffer) (last) 41 == && if [
    (writesubaddr)
    "    mov rax, [ret_stack_rsp]\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    mov qword [ret_stack_rsp], rax\n" (writeout)
    "    mov qword [rax], addr_" (writeout)
    (addr) read 1 - (strint) (writeout)
    "_" (writeout)
    (subaddr) read (strint) (writeout)
    (writeoutln)
    "    jmp addr_" (writeout)
    (getblockbuffer) (inner) disc
    (getprocTab)
    (getblockbuffer) 1 + (inTab) 0 == if (noproc)
    (getblockbuffer) 1 + (getTab) (strint)
    (writeout)
    disc
    (getblockbuffer) (clearbuf) disc
    (writeoutln)
    ret
  ] (getblockbuffer) read 255 && 0 != if [
    (cmdflags) read
    (getblockbuffer) (getnameop)
    covr 0 == if (getblockasm)
    covr 1 == if (addproc)
    covr 2 == if (addproc)
    covr 3 == if (addproc)
    covr 4 == if (addconst)
    covr 5 == if (addconst)
    covr 6 == if (addinc)
    covr 7 == if (addvar)
    disc
  ]
  (getblockbuffer) (clearbuf) disc
  
  ret
end

proc badop 0 0
  "BAD OPERATION: " (println)
  "`" (print) (getcmdbuffer) (print) "`" (println)

  "chunk" (println)
  (getreadbuffer) (println)
  (exit)

  ret
end


proc getcmdasm 1 0
  (getcmdbuffer) (alphanum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if [
    (getconstTab) (getcmdbuffer) (inTab) 0 == if (badop)
    (getcmdbuffer) (getTab) swap disc
    (strint)
    (getcmdbuffer) (clearbuf) swap (strcpy) disc disc
    disc
    OP_PUSH
  ] copy OP_NOP == if [
    disc ret
  ] copy OP_PUSH == if [
    "    mov qword rax, " (writeout)
    (getcmdbuffer) (writeout)
    (writeoutln)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_COPY == if [
    "    pop rax\n" (writeout)
    "    push rax\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_SWAP == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_SUB == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    sub rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_PLUS == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    add rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_AND == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    and rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_MUL == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    imul rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_DIV == if [
    "    xor rdx, rdx\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    idiv rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rdx\n" (writeout)
    disc ret
  ] copy OP_COVR == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    push rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_PROC == if [
    IDENT_PROC (identstackpush) 
    "    ; - proc" (writeout)
    (cmdflags)
    3
    putc disc
    disc ret
  ] copy OP_GPTR == if [
    (cmdflags)
    7
    putc disc
    disc ret
  ] copy OP_ARGC == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    mov rax, [rax]\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_ARGV == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_ENVP == if [
    "    mov rax, [args_ptr]\n" (writeout)
    "    mov rax, [rax]\n" (writeout)
    "    add rax, 2\n" (writeout)
    "    shl rax, 3\n" (writeout)
    "    mov rbx, [args_ptr]\n" (writeout)
    "    add rbx, rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_QUIT == if [
    "    jmp quit\n" (writeout)
    disc ret
  ] copy OP_RET == if [
    "    mov rax, [ret_stack_rsp]\n" (writeout)
    "    sub rax, 8\n" (writeout)
    "    mov qword [ret_stack_rsp], rax\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    jmp [rax]\n" (writeout)
    disc ret
  ] copy OP_DISC == if [
    "    pop rax\n" (writeout)
    disc ret
  ] copy OP_CONST == if [
    (cmdflags)
    5
    putc disc
    disc ret
  ] copy OP_READ == if [
    "    pop rax\n" (writeout)
    "    xor rbx, rbx\n" (writeout)
    "    mov rbx, [rax]\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_PUTC == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    mov byte [rax], bl\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_PUT == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    mov qword [rax], rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_NQ == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovne rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_EQ == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmove rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_GT == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovg rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_LT == if [
    "    mov rcx, 0\n" (writeout)
    "    mov rdx, 1\n" (writeout)
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    cmp rax, rbx\n" (writeout)
    "    cmovl rcx, rdx\n" (writeout)
    "    push rcx\n" (writeout)
    disc ret
  ] copy OP_IF == if [
    "    pop rbx\n" (writeout)
    "    test rbx, rbx\n" (writeout)
    "    jz addr_" (writeout)
    (addr) read 1 + (strint) (writeout)
    (writeoutln)
    disc ret
  ] copy OP_SYS0 == if [
    "    pop rax\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS1 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS2 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS3 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS4 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS5 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    pop r8\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_SYS6 == if [
    "    pop rax\n" (writeout) 
    "    pop rdi\n" (writeout) 
    "    pop rsi\n" (writeout) 
    "    pop rdx\n" (writeout) 
    "    pop r10\n" (writeout) 
    "    pop r8\n" (writeout) 
    "    pop r9\n" (writeout) 
    "    syscall\n" (writeout) 
    "    push rax\n" (writeout) 
    disc ret
  ] copy OP_DUMP == if [
    "    pop rax\n" (writeout) 
    "    call print\n" (writeout)
    disc ret
  ] copy IDENT_INC == if [
    (cmdflags)
    6
    putc disc
    disc ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopasm)
    disc ret
  ] copy IDENT_DO == if [
    (addr) read 1 - (identstackpush)
    IDENT_DO (identstackpush) 
    disc ret
  ]
  "; unimp " (writeout)
  (getopname) (writeout)
  " " (writeout)
  (getcmdbuffer) (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  {""}
  (getcmdbuffer) read 255 && 34 == (getcmdbuffer) (last) 34 != &&
  (getcmdbuffer) """ (streq) +
  {[]}
  (getcmdbuffer) read 255 && 91 == (getcmdbuffer) (last) 93 != && +
  {{}}
  (getcmdbuffer) read 255 && 123 == (getcmdbuffer) (last) 125 != && +
  0 ==

  ret
end

proc checkblockcmd 0 1
  {""}
  (getblockbuffer) read 255 && 34 == (getblockbuffer) (last) 34 != &&
  (getblockbuffer) """ (streq) +
  {[]}
  (getblockbuffer) read 255 && 91 == (getblockbuffer) (last) 93 != && +
  {{}}
  (getblockbuffer) read 255 && 123 == (getblockbuffer) (last) 125 != && +
  0 ==

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc (getblockbuffer) 0 ret]
  
  { if the command is not complete, append a space }
  disc 32

  ret
end

proc parseblock 0 0
  (getcmdbuffer)
  (getblockbuffer)
  do
    covr
    read 255 &&
    copy 9 {tab} ==
    covr 10 {lf} == +
    covr 13 {cr} == +
    covr 32 {spc} == +
    0 != 
    if (checkbufferblock)
      
    (getblockbuffer) read 255 &&

    34 ==
    covr 92 == &&
    if [
      disc
      swap 1 +
      swap

      covr read 255 && (getescape)
    ]

    covr
    swap
    putc disc
    
    swap
    1 +
    swap
    copy read 255 && 0 != if [
      1 +
    ]

    covr read 255 && 0 !=
  end
  disc
  disc
  
  (getblockbuffer)
  32
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  ret
end

proc parsecmd 0 0
  (getcmdbuffer) read 255 && 123 == (getcmdbuffer) (last) 125 == && if [

    (getcmdbuffer) (clearbuf) disc
    ret
  ]
  (getcmdbuffer) read 255 && 34 == (getcmdbuffer) (last) 34 == && if [
    (writeaddr)

    { add code }
    "    push str_" (writeout)
    (getstringidx) (strint) (writeout)
    (writeoutln)

    { put the header }
    "str_"
    (getstringbuffer) copy (strlen) + 
    swap (strcpy) disc disc
    
    (stringidx) read 1 - (strint)
    (getstringbuffer) copy (strlen) + 
    swap (strcpy) disc disc
    
    ": db "
    (getstringbuffer) copy (strlen) + 
    swap (strcpy) disc disc
    (getcmdbuffer) (inner)

    { put the first char }
    copy read 255 &&
    (strint)
    (getstringbuffer) copy (strlen) + 
    swap (strcpy) disc disc
    do
      1 +

      { comma }
      ", "
      (getstringbuffer) copy (strlen) +
      swap (strcpy) disc disc

      { put the next char }
      copy read 255 &&
      copy (strint)
      (getstringbuffer) copy (strlen) +
      swap (strcpy) disc disc
    end
    "\n"
    (getstringbuffer) copy (strlen) +
    swap (strcpy) disc disc
    disc

    (getcmdbuffer) (clearbuf) disc
    ret
  ]
  (getcmdbuffer) read 255 && 91 == (getcmdbuffer) (last) 93 == && if [
    (writeaddr)
    (getcmdbuffer) (inner)
    (getcmdbuffer) swap (strcpy) disc disc
    (getcmdbuffer) copy (strlen) 1 - + 0 putc disc
    (parseblock)
    (getcmdbuffer) (clearbuf) disc
    ret
  ]
  (getcmdbuffer) read 255 && 40 == (getcmdbuffer) (last) 41 == && if [
    (writeaddr)
    "    mov rax, [ret_stack_rsp]\n" (writeout)
    "    add rax, 8\n" (writeout)
    "    mov qword [ret_stack_rsp], rax\n" (writeout)
    "    mov qword [rax], addr_" (writeout)
    (addr) read (strint) (writeout)
    (writeoutln)
    "    jmp addr_" (writeout)
    (getcmdbuffer) (inner) disc
    (getprocTab)
    (getcmdbuffer) 1 + (inTab) 0 == if (noproc)
    (getcmdbuffer) 1 + (getTab) (strint)
    (writeout)
    disc
    (getcmdbuffer) (clearbuf) disc
    (writeoutln)
    ret
  ]
  (getcmdbuffer) read 255 && 0 != if [
    (cmdflags) read
    (getcmdbuffer) (getnameop)
    covr 0 == if (getcmdasm)
    covr 1 == if (addproc)
    covr 2 == if (addproc)
    covr 3 == if (addproc)
    covr 4 == if (addconst)
    covr 5 == if (addconst)
    covr 6 == if (addinc)
    covr 7 == if (addvar)
    disc
  ]
  (getcmdbuffer) (clearbuf) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc (getcmdbuffer) 0 ret]
  
  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  (asmheader)
  READSIZE (getreadbuffer)
  (getinputfd) read (read) disc
  (getinputfd) read 74 sys1 disc
  do
    (getreadbuffer)
    (getcmdbuffer)
    do
      covr read 255 &&

      copy 9 {tab} ==
      covr 10 {lf} == +
      covr 13 {cr} == +
      covr 32 {spc} == +
      0 != 
      if (checkbuffer)
      
      (getcmdbuffer) read 255 &&

      34 ==
      covr 92 == &&
      if [
        disc
        swap 1 +
        swap

        covr read 255 && (getescape)
      ]

      covr
      swap
      putc disc
      
      swap
      1 +
      swap
      copy read 255 && 0 != if [
        1 +
      ]

      covr read 255 && 0 !=
    end
    disc
    disc

    (getreadbuffer) (clearbuf)

    (getcmdbuffer) (strcpy) disc disc

    READSIZE (getcmdbuffer) (strlen) -

    (getreadbuffer) (getcmdbuffer) (strlen) +

    (getinputfd) read (read) copy
    (getreadbuffer) + (getcmdbuffer) (strlen) + 1 + 0 putc disc
    (getinputfd) read 74 sys1 disc

    (getcmdbuffer) (clearbuf) disc
  end
  (asmfooter)
  ret
end

{
args: int 
result: 

prints a help string
}
proc help 1 0
  "INVALID HELP ID"
  covr 1 == if [
    disc 
    "Help"
  ] covr 2 == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr 3 == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (println)
  "slim compiler usage:" (println)
  (endl)
  "slim [-h]\ [-s]\ [-o output]\ file" (println)
  (endl)
  "-h, --help    shows this help message." (println)
  "-s, --silent  disables output text." (println)
  "-o, --output  selects the output file." (println)
  disc
  (exit)

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  (getsilent)
  1
  putc
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [3 (help)]
    
    (getoutput)
    covr (args)
    (strcpy)

    disc
    disc
    ret
end

proc setinput 1 0
  (getinput)
  read 255 && 0 != if [2 (help)]

  { set input to argument if its not a flag }
  (getinput)
  covr (args)
  (strcpy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int 
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (streq)
  if [disc 1 (help) 0 ret]
  copy "--help" (streq)
  if [disc 1 (help) 0 ret]
  copy "-o" (streq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (streq) 
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (streq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (streq)
  if [disc (setsilent) 0 ret]
  disc
  1 ret
end

proc cmdtmp 0 1
  var 64

  ret
end

proc nasm 0 0
  (cmdtmp)
  "/usr/bin/nasm" put 8 +
  "-f" put 8 +
  "elf64" put 8 +
  "-o" put 8 +
  "temp.o" put 8 +
  "temp.nasm" put 8 +
  NULL put

  disc
  (cmdtmp) (execcmdecho) 
  
  ret
end

proc ld 0 0
  (cmdtmp)
  "/usr/bin/ld" put 8 +
  "-dynamic-linker" put 8 +
  "/lib64/ld-linux-x86-64.so.2" put 8 +
  "-o" put 8 +
  (getoutput) put 8 +
  "-lc" put 8 +
  "temp.o" put 8 +
  NULL put

  disc
  (cmdtmp) (execcmdecho) 

  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [2 (help)]
  
  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (args)

    (applyarg) if [copy (setinput)]

    copy argc 1 - <
  end
  disc

  (getoutput)
  read 255 && 0 ==
  if [(getoutput) "output" (strcpy)]

  (getinput)
  read 255 && 0 ==
  if [2 (help)]
  
  {open input}
  0 0 (getinput)
  0 100 -
  (open)
  (getinputfd) swap put disc
   
  {open output}
  420 577 "temp.nasm"
  0 100 -
  (open)
  (getoutputfd) swap put disc
  
  {parse input}
  (parsefile) 

  {close output}
  (getoutputfd) read (close)
  
  {close input}
  (getinputfd) read (close)
  
  (nasm)
  (ld)

  ret
end
