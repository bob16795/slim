inc lib/stdlib.slm
inc lib/tables.slm

{The Slim Compiler, written in Slim}

{TODO: fix inc}
{TODO: Track stack}
{TODO: track last reg}

proc version 0 1
  "0.1.2" ret
end

enum
0   OP_NOP
    OP_PUSH
    OP_SUB
    OP_MUL
    OP_DIV
    OP_PLUS
    OP_SWAP
    OP_DUMP
    OP_COPY
    OP_COVR
    OP_READ
    OP_READC
    OP_PUTC
    OP_PUT
    OP_DISC
    OP_ARGV
    OP_ARGC
    OP_ENVP
    OP_PUSHP
    OP_CALLS
    OP_MULTI
    OP_CONST
    OP_RET
    OP_QUIT
    OP_LOCX
    OP_JUMPX
    OP_JUMP
    OP_IF
    OP_JNZ
    OP_GETP
    OP_CYCL
    OP_NQ
    OP_EQ
    OP_LT
    OP_GT
    OP_AND
    OP_OR
    OP_NOT
    OP_SYS0
    OP_SYS1
    OP_SYS2
    OP_SYS3
    OP_SYS4
    OP_SYS5
    OP_SYS6

100 IDENT_INC 
    IDENT_GVAR
    IDENT_ENUM
    IDENT_PROC
    IDENT_DO
    IDENT_VAR
    IDENT_END

255 OP_BAD
end

enum
0   CF_NONE
    CF_PROC_OUT
    CF_PROC_IN
    CF_PROC_NAME
    CF_CONST_VALUE
    CF_CONST_NAME
    CF_INC
    CF_VAR
    CF_GVAR_VALUE
    CF_GVAR_NAME
    CF_ENUM_CONTENT
    CF_ENUM_START
end

{this is for optimization}
enum
0   REG_A
    REG_B
end

gvar gvarTab 300000
gvar constTab 300000
gvar procTab 300000

gvar cmdbuffer 2048
gvar blockbuffer 2048
gvar readbuffer 2048

gvar stringbuffer 100000
gvar stringbufferlen 8
gvar inputfd 8
gvar outputfd 8

gvar cmdlineflags 8

gvar identstack 64
gvar identstackrsp 8

gvar outputbuffer 128
gvar inputbuffer 128
gvar cmdtmpbuffer 128
gvar includebuffer 128
gvar includetmpbuffer 128

gvar parseflags 8

gvar parseaddr 8
gvar parsesubaddr 8
gvar parsestringidx 8
gvar parsememory 8

gvar constname 64
gvar enumvalue 8

const READSIZE 2047

proc getescape 1 1
  copy 110 == if [ disc 10 ret ]
  copy 164 == if [ disc 9 ret ]
  copy 101 == if [ disc 27 ret ]
  ret
end

proc getnameop 1 1
  OP_BAD
  covr "proc"  (streq) if [disc IDENT_PROC]
  covr "do"    (streq) if [disc IDENT_DO]
  covr "end"   (streq) if [disc IDENT_END]
  covr "inc"   (streq) if [disc IDENT_INC]
  covr "enum"  (streq) if [disc IDENT_ENUM]
  covr "var"   (streq) if [disc IDENT_VAR]
  covr "gvar"  (streq) if [disc IDENT_GVAR]
  
  covr "nop"   (streq) if [disc OP_NOP]
  covr "}"     (streq) if [disc OP_NOP]
  covr "-"     (streq) if [disc OP_SUB]
  covr "*"     (streq) if [disc OP_MUL]
  covr "/"     (streq) if [disc OP_DIV]
  covr "+"     (streq) if [disc OP_PLUS]
  covr "swap"  (streq) if [disc OP_SWAP]
  covr "dump"  (streq) if [disc OP_DUMP]
  covr "copy"  (streq) if [disc OP_COPY]
  covr "covr"  (streq) if [disc OP_COVR]
  covr "readc" (streq) if [disc OP_READC]
  covr "read"  (streq) if [disc OP_READ]
  covr "putc"  (streq) if [disc OP_PUTC]
  covr "put"   (streq) if [disc OP_PUT]
  covr "disc"  (streq) if [disc OP_DISC]
  covr "argv"  (streq) if [disc OP_ARGV]
  covr "argc"  (streq) if [disc OP_ARGC]
  covr "envp"  (streq) if [disc OP_ENVP]
  covr "()"    (streq) if [disc OP_CALLS]
  covr "const" (streq) if [disc OP_CONST]
  covr "ret"   (streq) if [disc OP_RET]
  covr "quit"  (streq) if [disc OP_QUIT]
  covr "if"    (streq) if [disc OP_IF]
  covr "cycl"  (streq) if [disc OP_CYCL]
  covr "!="    (streq) if [disc OP_NQ]
  covr "=="    (streq) if [disc OP_EQ]
  covr "<"     (streq) if [disc OP_LT]
  covr ">"     (streq) if [disc OP_GT]
  covr "&&"    (streq) if [disc OP_AND]
  covr "||"    (streq) if [disc OP_OR]
  covr "!"     (streq) if [disc OP_NOT]
  covr "sys0"  (streq) if [disc OP_SYS0]
  covr "sys1"  (streq) if [disc OP_SYS1]
  covr "sys2"  (streq) if [disc OP_SYS2]
  covr "sys3"  (streq) if [disc OP_SYS3]
  covr "sys4"  (streq) if [disc OP_SYS4]
  covr "sys5"  (streq) if [disc OP_SYS5]
  covr "sys6"  (streq) if [disc OP_SYS6]
  swap disc
  
  ret
end

proc getopname 1 1
  copy (strint)
  covr OP_NOP   == if [disc "nop"]
  covr OP_PUSH  == if [disc "push"]
  covr OP_SUB   == if [disc "sub"]
  covr OP_MUL   == if [disc "mul"]
  covr OP_PLUS  == if [disc "plus"]
  covr OP_SWAP  == if [disc "swap"]
  covr OP_DUMP  == if [disc "dump"]
  covr OP_COPY  == if [disc "copy"]
  covr OP_COVR  == if [disc "covr"]
  covr OP_READ  == if [disc "read"]
  covr OP_READC == if [disc "readc"]
  covr OP_PUTC  == if [disc "putc"]
  covr OP_PUT   == if [disc "put"]
  covr OP_DISC  == if [disc "disc"]
  covr OP_ARGV  == if [disc "argv"]
  covr OP_ARGC  == if [disc "argc"]
  covr OP_ENVP  == if [disc "envp"]
  covr OP_PUSHP == if [disc "push"]
  covr OP_CALLS == if [disc "call"]
  covr OP_MULTI == if [disc "[]"]
  covr OP_CONST == if [disc "const"]
  covr OP_RET   == if [disc "ret"]
  covr OP_QUIT  == if [disc "quit"]
  covr OP_LOCX  == if [disc "location"]
  covr OP_JUMPX == if [disc "jump"]
  covr OP_JUMP  == if [disc "jump"]
  covr OP_IF    == if [disc "if"]
  covr OP_JNZ   == if [disc "jnz"]
  covr OP_GETP  == if [disc "getp"]
  covr OP_CYCL  == if [disc "cycl"]
  covr OP_NQ    == if [disc "!="]
  covr OP_EQ    == if [disc "=="]
  covr OP_LT    == if [disc "<"]
  covr OP_GT    == if [disc ">"]
  covr OP_AND   == if [disc "&&"]
  covr OP_OR    == if [disc "||"]
  covr OP_NOT   == if [disc "!"]
  covr OP_SYS0  == if [disc "sys0"]
  covr OP_SYS1  == if [disc "sys1"]
  covr OP_SYS2  == if [disc "sys2"]
  covr OP_SYS3  == if [disc "sys3"]
  covr OP_SYS4  == if [disc "sys4"]
  covr OP_SYS5  == if [disc "sys5"]
  covr OP_SYS6  == if [disc "sys6"]
  
  covr IDENT_PROC  == if [disc "proc"]
  swap disc
  ret
end

proc identstackpush 1 0
  identstackrsp read identstack +
  swap
  put disc
  
  identstackrsp read
  8 +
  identstackrsp swap put disc
  ret
end

proc identstackpop 0 1
  identstackrsp read 0 !=
    "stack underflow" (assert)
  
  identstackrsp read 8 -
  identstackrsp swap put disc
  identstackrsp read identstack +
  read
  
  ret
end

proc inner 1 1
  1 + copy
  copy (strlen) 1 - + 0 putc disc
  ret
end

proc getstringidx 0 1
  parsestringidx read
  copy 1 +
  parsestringidx swap put disc
  ret
end

proc getaddr 0 1
  parsesubaddr
  0 put disc

  parseaddr read
  copy 1 +
  parseaddr swap put disc
  ret
end

proc getsubaddr 0 1
  parsesubaddr read
  copy 1 +
  parsesubaddr swap put disc
  ret
end

proc exit 0 0
  {close output}
  outputfd read
  copy != 0 if [(close) 0]
  disc

  {close input}
  inputfd read
  copy != 0 if [(close) 0]
  disc

  quit
  ret
end

proc noprocblock 0 0
  procTab (printTab)
  "proc not found: " (print)
  blockbuffer 1 + (println)
  (exit)

  ret
end


proc noproc 0 0
  procTab (printTab)
  "proc not found: " (print)
  cmdbuffer 1 + (println)
  (exit)

  ret
end

proc writeout 2 0
  outputfd read (write)
  ret
end

proc writeoutln 0 0
  '\n' (writeout)

  ret
end

proc addproc 0 0
  ' ' (writeout)
  cmdbuffer copy (strlen) swap (writeout)
  parseflags copy read
  copy CF_PROC_NAME == if [
    procTab cmdbuffer parseaddr read (putTab) disc
  ]
  copy CF_PROC_OUT == if [
    (writeoutln)
  ]
  1 -
  putc disc

  ret
end

proc addconst 0 0

  parseflags
  copy read 1 - copy
  CF_CONST_VALUE 1 - == if [
    constTab constname cmdbuffer (tonum) (putTab) disc
    disc CF_NONE
  ] copy CF_CONST_NAME 1 - == if [
    cmdbuffer constname (clearbuf) swap (strcpy) disc disc
  ]
  put disc

  ret
end

proc addgvar 0 0
  parseflags
  copy read 1 - copy
  CF_GVAR_VALUE 1 - == if [
    gvarTab constname parsememory read (putTab) disc
    cmdbuffer (tonum)
    parsememory read +
    parsememory swap put disc
    disc CF_NONE
  ] copy CF_GVAR_NAME 1 - == if [
    cmdbuffer constname (clearbuf) swap (strcpy) disc disc
  ]
  put disc

  ret
end

proc addenumstart 0 0
  enumvalue
  cmdbuffer (tonum)
  put disc

  parseflags
  CF_ENUM_CONTENT
  put disc

  ret
end

proc addenum 0 0 
  cmdbuffer (alphanum) if [
    enumvalue
    cmdbuffer (tonum)
    put disc

    ret
  ]

  cmdbuffer "end" (streq) if [
    parseflags
    CF_NONE
    put disc
    ret
  ]

  constTab cmdbuffer enumvalue read (putTab) disc

  enumvalue read
  1 +
  enumvalue swap put disc

  ret
end

proc addinc 0 0 
  parseflags
  CF_NONE
  putc disc

  ret
end

proc addvar 0 0
  '    mov rax, mem\n' (writeout)
  '    add rax, ' (writeout)
  parsememory read (strint) copy (strlen) swap (writeout)
  (writeoutln)
  '    push rax\n' (writeout)

  cmdbuffer (tonum)
  parsememory read +
  parsememory swap put
  disc

  parseflags
  CF_NONE
  putc disc

  ret
end

proc asmheader 0 0
    stringbufferlen 1 put disc
    'BITS 64\n' (writeout)
    'segment .text\n' (writeout)
    'print:\n' (writeout)
    '    mov r10, rsp\n' (writeout)
    '    sub rsp, 8\n' (writeout)
    '    mov [rsp], al\n' (writeout)
    '    mov edi, 1\n' (writeout)
    '    mov rsi, rsp\n' (writeout)
    '    mov edx, 1\n' (writeout)
    '    mov eax, 1\n' (writeout)
    '    syscall\n' (writeout)
    '    mov rsp, r10\n' (writeout)
    '    ret\n' (writeout)
    ret
end

proc asmfooter 0 0
  'addr_' (writeout)
  (getaddr) (strint) copy (strlen) swap (writeout)
  ':\n' (writeout)
  '    ret\n' (writeout)
  'global _start\n' (writeout)
  '_start:\n' (writeout)
  '    mov qword [args_ptr], rsp\n' (writeout)
  '    mov qword [ret_stack_rsp], ret_stack\n' (writeout)
  '    mov rax, [ret_stack_rsp]\n' (writeout)
  '    mov qword [rax], quit\n' (writeout)
  '    jmp addr_' (writeout)
  procTab
  "main" (inTab) ! if [
    "no main proc defined" (println)
    (exit)
  ]
  "main" (getTab) 1 - (strint) copy (strlen) swap (writeout)
  (writeoutln)
  'quit:\n' (writeout)
  '    mov rax, 60\n' (writeout)
  '    mov rdi, 0\n' (writeout)
  '    syscall\n' (writeout)
  'segment .data\n' (writeout)
  stringbuffer stringbufferlen read swap (writeout)
  'segment .bss\n' (writeout)
  'args_ptr: resq 1\n' (writeout)
  'ret_stack_rsp: resq 1\n' (writeout)
  'ret_stack: resb 65536\n' (writeout)
  'mem: resb ' (writeout)
  parsememory read (strint) copy (strlen) swap (writeout)
  (writeoutln)
  disc
  ret
end

proc endopasm 1 0
  copy IDENT_DO == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read (strint) copy (strlen) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    (identstackpop) (strint) copy (strlen) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc endopblockasm 1 0
  copy IDENT_DO == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 - (strint) copy (strlen) swap (writeout)
    '_' (writeout)
    parsesubaddr read (strint) copy (strlen) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    (identstackpop) (strint) copy (strlen) swap (writeout)
    '_' (writeout)
    (identstackpop) (strint) copy (strlen) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc writeaddr 0 0
  'addr_' (writeout)
  (getaddr) (strint) copy (strlen) swap (writeout)
  ':' (writeout)
  (writeoutln)

  ret
end

proc writesubaddr 0 0
  'addr_' (writeout)
  parseaddr read 1 - (strint) copy (strlen) swap (writeout)
  '_' (writeout)
  (getsubaddr) (strint) copy (strlen) swap (writeout)
  ':' (writeout)
  (writeoutln)

  ret
end

proc badblockop 0 0
  "BAD OPERATION: " (println)
  "`" (print) blockbuffer (print) "`" (println)

  "chunk" (println)
  readbuffer (println)
  "block" (println)
  cmdbuffer (println)
  (exit)

  ret
end


proc checkbadblock 1 1
  constTab blockbuffer (inTab) if [
    blockbuffer (getTab) swap disc
    (strint)
    blockbuffer (clearbuf) swap (strcpy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvarTab blockbuffer (inTab) if [
    '    mov rax, mem\n' (writeout)
    '    add rax, ' (writeout)
    gvarTab blockbuffer (getTab) swap disc (strint) copy (strlen) swap (writeout)
    (writeoutln) disc
    '    push rax\n' (writeout)
    
    disc OP_NOP
    ret
  ] disc
  (badblockop)
  ret
end


proc getblockasm 1 1
  blockbuffer (alphanum) if [
    disc
    OP_PUSH
  ]

  (writesubaddr)

  copy OP_BAD == if (checkbadblock)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    '    mov qword rax, ' (writeout)
    blockbuffer copy (strlen) swap (writeout)
    (writeoutln)
    '    push rax\n' (writeout)
    ret
  ] copy OP_COPY == if [
    '    pop rax\n' (writeout)
    '    push rax\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SWAP == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_SUB == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    sub rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PLUS == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    add rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_AND == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    and rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_OR == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    or rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NOT == if [
    '    pop rax\n' (writeout)
    '    xor rax, 1\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_MUL == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    imul rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DIV == if [
    '    xor rdx, rdx\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    idiv rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rdx\n' (writeout)
    ret
  ] copy OP_COVR == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_ARGC == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ARGV == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ENVP == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    add rax, 2\n' (writeout)
    '    shl rax, 3\n' (writeout)
    '    mov rbx, [args_ptr]\n' (writeout)
    '    add rbx, rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_QUIT == if [
    '    jmp quit\n' (writeout)
    ret
  ] copy OP_RET == if [
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    sub rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    jmp [rax + 8]\n' (writeout)
    ret
  ] copy OP_DISC == if [
    '    pop rax\n' (writeout)
    ret
  ] copy OP_READC == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov bl, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_READ == if [
    '   pop rax\n' (writeout)
    '   xor rbx, rbx\n' (writeout)
    '   mov rbx, [rax]\n' (writeout)
    '   push rbx\n' (writeout)
    ret
  ] copy OP_PUTC == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov byte [rax], bl\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PUT == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov qword [rax], rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovne rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_EQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmove rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_GT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovg rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_LT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovl rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_IF == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 - (strint) copy (strlen) swap (writeout)
    '_' (writeout)
    parsesubaddr read 1 + (strint) copy (strlen) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    '    pop rax\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS1 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS2 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS3 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS4 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS5 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS6 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    pop r9\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DUMP == if [
    '    pop rax\n' (writeout)
    '    call print\n' (writeout)
    ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopblockasm)
    ret
  ] copy IDENT_DO == if [
    parsesubaddr read 1 - (identstackpush)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  '; unimp ' (writeout)
  (getopname) copy (strlen) swap (writeout)
  ' ' (writeout)
  cmdbuffer copy (strlen) swap (writeout)
  (writeoutln)
  ret
end

proc parsestring 0 0

  { add code }
  '    push str_' (writeout)
  (getstringidx) (strint) copy (strlen) swap (writeout)
  (writeoutln)

  { put the header }
  'str_'
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (strint)
  copy (strlen) swap
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  ': db '
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  blockbuffer 1 +

  { put the first char }
  copy readc
  (strint)
  copy (strlen) swap
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    ', '
    stringbuffer stringbufferlen read +
    swap (strcpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (strint)
    copy (strlen) swap
    stringbuffer stringbufferlen read +
    swap (strcpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  '\n'
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  disc

  blockbuffer (clearbuf) disc
  ret
end

proc parseblockcmd 0 0
  blockbuffer readc 123 == blockbuffer (last) 125 == && if [
    {comment}

    nop

    blockbuffer (clearbuf) disc
  ] blockbuffer readc 34 == blockbuffer (last) 34 == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner)
    (parsestring)

    disc ret
  ] blockbuffer readc 39 == blockbuffer (last) 39 == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner) disc
    '    push ' (writeout)
    blockbuffer 1 + (strlen) (strint) copy (strlen) swap (writeout)
    (writeoutln)
    
    (parsestring)
    ret
  ] blockbuffer readc 40 == blockbuffer (last) 41 == && if [

    (writesubaddr)
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    mov qword [rax], addr_' (writeout)
    parseaddr read 1 - (strint) copy (strlen) swap (writeout)
    '_' (writeout)
    parsesubaddr read (strint) copy (strlen) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    blockbuffer (inner) disc
    procTab
    blockbuffer 1 + (inTab) ! if (noprocblock)
    blockbuffer 1 + (getTab) (strint)
    copy (strlen) swap
    (writeout)
    disc
    blockbuffer (clearbuf) disc
    (writeoutln)
    ret
  ] blockbuffer readc 0 != if [
    parseflags read
    blockbuffer (getnameop)
    covr CF_NONE == if (getblockasm)
    covr CF_VAR == if (addvar)
    disc disc
  ]
  blockbuffer (clearbuf) disc

  ret
end

proc badop 0 0
  "BAD OPERATION: " (println)
  "`" (print) cmdbuffer (print) "`" (println)

  "chunk" (println)
  readbuffer (println)
  (exit)

  ret
end

proc checkbad 1 1
  constTab cmdbuffer (inTab) if [
    cmdbuffer (getTab) swap disc
    (strint)
    cmdbuffer (clearbuf) swap (strcpy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvarTab cmdbuffer (inTab) if [
    '    mov rax, mem\n' (writeout)
    '    add rax, ' (writeout)
    gvarTab cmdbuffer (getTab) swap disc (strint) copy (strlen) swap (writeout)
    (writeoutln) disc
    '    push rax\n' (writeout)
    
    disc OP_NOP
    ret
  ] disc
  (badop)
  ret
end

proc getcmdasm 1 1
  cmdbuffer (alphanum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if (checkbad)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    '    mov qword rax, ' (writeout)
    cmdbuffer copy (strlen) swap (writeout)
    (writeoutln)
    '    push rax\n' (writeout)
    ret
  ] copy OP_COPY == if [
    '    pop rax\n' (writeout)
    '    push rax\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SWAP == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_SUB == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    sub rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PLUS == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    add rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_AND == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    and rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_OR == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    or rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NOT == if [
    '    pop rax\n' (writeout)
    '    xor rax, 1\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_MUL == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    imul rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DIV == if [
    '    xor rdx, rdx\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    idiv rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rdx\n' (writeout)
    ret
  ] copy OP_COVR == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy IDENT_PROC == if [
    IDENT_PROC (identstackpush)
    '    ; - proc' (writeout)
    parseflags
    CF_PROC_NAME
    put disc
    ret
  ] copy IDENT_ENUM == if [
    '    ; - enum\n' (writeout)
    parseflags
    CF_ENUM_START
    put disc
    ret
  ] copy OP_ARGC == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ARGV == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ENVP == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    add rax, 2\n' (writeout)
    '    shl rax, 3\n' (writeout)
    '    mov rbx, [args_ptr]\n' (writeout)
    '    add rbx, rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_QUIT == if [
    '    jmp quit\n' (writeout)
    ret
  ] copy OP_RET == if [
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    sub rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    jmp [rax]\n' (writeout)
    ret
  ] copy OP_DISC == if [
    '    pop rax\n' (writeout)
    ret
  ] copy OP_CONST == if [
    parseflags
    CF_CONST_NAME
    put disc
    ret
  ] copy OP_READC == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov bl, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_READ == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov rbx, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_PUTC == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov byte [rax], bl\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PUT == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov qword [rax], rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovne rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_EQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmove rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_GT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovg rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_LT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovl rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_IF == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 + (strint) copy (strlen) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    '    pop rax\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS1 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS2 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS3 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS4 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS5 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS6 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    pop r9\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DUMP == if [
    '    pop rax\n' (writeout)
    '    call print\n' (writeout)
    ret
  ] copy IDENT_INC == if [
    parseflags
    CF_INC
    put disc
    ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopasm)
    ret
  ] copy IDENT_DO == if [
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  '; unimp ' (writeout)
  (getopname) copy (strlen) swap (writeout)
  ' ' (writeout)
  cmdbuffer copy (strlen) swap (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  {""}
  cmdbuffer readc 34 == cmdbuffer (last) 34 != &&
  cmdbuffer """ (streq) ||
  {'  '}
  cmdbuffer readc 39 == cmdbuffer (last) 39 != && ||
  cmdbuffer "'" (streq) ||
  {[]}
  cmdbuffer readc 91 == cmdbuffer (last) 93 != && ||
  {{}}
  cmdbuffer readc 123 == cmdbuffer (last) 125 != && ||
  !

  ret
end

proc checkblockcmd 0 1
  {""}
  blockbuffer readc 34 == blockbuffer (last) 34 != &&
  blockbuffer """ (streq) ||
  {''}
  blockbuffer readc 39 == blockbuffer (last) 39 != && ||
  blockbuffer "'" (streq) ||
  {[]}
  blockbuffer readc 91 == blockbuffer (last) 93 != && ||
  {{}}
  blockbuffer readc 123 == blockbuffer (last) 125 != && ||
  !

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc blockbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32

  ret
end

proc parseblock 0 0
  cmdbuffer
  blockbuffer
  do
    covr readc
    copy 9 {tab} ==
    covr 10 {lf} == ||
    covr 13 {cr} == ||
    covr 32 {spc} == ||
    if (checkbufferblock)

    blockbuffer readc

    copy 34 ==
    swap 39 == ||
    covr 92 == &&
    if [
      disc
      swap 1 +
      swap

      covr readc (getescape)
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc

  blockbuffer
  32
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  ret
end

proc parsestringblock 0 0 

  { add code }
  '    push str_' (writeout)
  (getstringidx) (strint) copy (strlen) swap (writeout)
  (writeoutln)

  { put the header }
  'str_'
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (strint)
  copy (strlen) swap
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  ': db '
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer 1 +

  { put the first char }
  copy readc
  (strint)
  copy (strlen) swap
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    ', '
    stringbuffer stringbufferlen read +
    swap (strcpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (strint)
    copy (strlen) swap
    stringbuffer stringbufferlen read +
    swap (strcpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  disc
  '\n'
  stringbuffer stringbufferlen read +
  swap (strcpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer (clearbuf) disc
  ret
end

proc parsecmd 0 0
  cmdbuffer readc 123 == cmdbuffer (last) 125 == && if [

    cmdbuffer (clearbuf) disc
    ret
  ]
  cmdbuffer readc 34 == cmdbuffer (last) 34 == && if [
    (writeaddr)

    cmdbuffer (inner)
    (parsestringblock)
    disc ret
  ] cmdbuffer readc 39 == cmdbuffer (last) 39 == && if [
    {string}
    (writeaddr)

    cmdbuffer (inner) disc
    '    push ' (writeout)
    cmdbuffer 1 + (strlen) (strint) copy (strlen) swap (writeout)
    (writeoutln)
    
    (parsestringblock)
    ret
  ]
  cmdbuffer readc 91 == cmdbuffer (last) 93 == && if [
    (writeaddr)
    cmdbuffer (inner)
    cmdbuffer swap (strcpy) disc disc
    cmdbuffer copy (strlen) 1 - + 0 putc disc
    (parseblock)
    cmdbuffer (clearbuf) disc
    ret
  ]
  cmdbuffer readc 40 == cmdbuffer (last) 41 == && if [
    (writeaddr)
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    mov qword [rax], addr_' (writeout)
    parseaddr read (strint) copy (strlen) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    cmdbuffer (inner) disc
    procTab
    cmdbuffer 1 + (inTab) 0 == if (noproc)
    cmdbuffer 1 + (getTab) (strint)
    copy (strlen) swap
    (writeout)
    disc
    cmdbuffer (clearbuf) disc
    (writeoutln)
    ret
  ]
  cmdbuffer readc 0 != if [
    parseflags read
    cmdbuffer (getnameop)
    covr CF_NONE == if (getcmdasm)
    covr CF_PROC_OUT == if (addproc)
    covr CF_PROC_IN == if (addproc)
    covr CF_PROC_NAME == if (addproc)
    covr CF_CONST_VALUE == if (addconst)
    covr CF_CONST_NAME == if (addconst)
    covr CF_INC == if (addinc)
    covr CF_VAR == if (addvar)
    covr CF_GVAR_NAME == if (addgvar)
    covr CF_GVAR_VALUE == if (addgvar)
    covr CF_ENUM_CONTENT == if (addenum)
    covr CF_ENUM_START == if (addenumstart)
    disc disc
  ]
  cmdbuffer (clearbuf) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc cmdbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  READSIZE readbuffer
  inputfd read (read) disc
  inputfd read 74 sys1 disc
  do
    readbuffer
    cmdbuffer
    do
      covr readc

      copy 9 {tab} ==
      covr 10 {lf} == ||
      covr 13 {cr} == ||
      covr 32 {spc} == ||
      if (checkbuffer)

      cmdbuffer readc

      copy 34 ==
      swap 39 == ||
      covr 92 == &&
      if [
        disc
        swap 1 +
        swap

        covr readc (getescape)
      ]

      covr
      swap
      putc disc

      swap
      1 +
      swap
      copy readc 0 != if [
        1 +
      ]

      covr readc 0 !=
    end
    disc
    disc

    readbuffer (clearbuf)

    cmdbuffer (strcpy) disc disc

    READSIZE cmdbuffer (strlen) -

    readbuffer cmdbuffer (strlen) +

    inputfd read (read) copy
    readbuffer + cmdbuffer (strlen) + 1 + 0 putc disc
    inputfd read 74 sys1 disc

    cmdbuffer (clearbuf) disc
  end
  ret
end

{
args: int
result:

prints a help string
}
proc help 1 0
  copy 100 == if [
    "slim compiler v" (print) (version) (println)
    (exit)
  ]
  "INVALID HELP ID"
  covr 1 == if [
    disc
    "Help"
  ] covr 2 == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr 3 == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (println)
  "slim compiler v" (print) (version) (print) " usage:" (println)
  (endl)
  "slim [-h]\ [-a]\ [-s]\ [-i include]\ [-o output]\ file" (println)
  (endl)
  "-v            shows the version and exits." (println)
  "-h, --help    shows this help message." (println)
  "-i, --include includes a library." (println)
  "-s, --silent  disables output text." (println)
  "-a, --asm     keeps the assembly code." (println)
  "-o, --output  selects the output file." (println)
  disc
  (exit)

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  cmdlineflags
  cmdlineflags read 1 ||
  put
  disc
  ret
end

proc setasm 0 0
  cmdlineflags
  cmdlineflags read 2 ||
  put
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [3 (help)]

    outputbuffer
    covr (args)
    (strcpy)

    disc
    disc
    ret
end

proc openinput 1 0
  inputfd read
  copy != 0 if [(close) 0]
  disc

  cmdlineflags read ! if [
    "[SLM]\ " (print)
    copy (println)
  ]

  {open input}
  0 swap 0 swap
  0 100 -
  (open)
  inputfd swap put disc

  ret
end

proc parseinc 0 0
  includebuffer read NULL == if ret
  includebuffer
  includetmpbuffer
  do
    covr readc

    copy 44 ==
    if [
      includetmpbuffer (openinput)
      (parsefile)
      includetmpbuffer (clearbuf) disc
      disc disc
      includetmpbuffer 0
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc
  includetmpbuffer (openinput)
  (parsefile)
  includetmpbuffer (clearbuf) disc

  ret
end

proc setinclude 1 1
    copy argc 1 - > if [3 (help)]

    includebuffer
    covr (args)
    (strcpy)

    disc
    disc
    ret
end

proc setinput 1 0
  inputbuffer
  readc 0 != if [2 (help)]

  { set input to argument if its not a flag }
  inputbuffer
  covr (args)
  (strcpy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (streq)
  if [disc 1 (help) 0 ret]
  copy "-v" (streq)
  if [disc 100 (help) 0 ret]
  copy "-i" (streq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--include" (streq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--help" (streq)
  if [disc 1 (help) 0 ret]
  copy "-o" (streq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (streq)
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (streq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (streq)
  if [disc (setsilent) 0 ret]
  copy "-a" (streq)
  if [disc (setasm) 0 ret]
  copy "--asm" (streq)
  if [disc (setasm) 0 ret]
  disc
  1 ret
end

proc nasm 0 0
  cmdtmpbuffer
  "/usr/bin/nasm" put 8 +
  "-gdwarf" put 8 +
  "-f" put 8 +
  "elf64" put 8 +
  "-o" put 8 +
  "temp.o" put 8 +
  "temp.nasm" put 8 +
  NULL put
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(execcmdecho) 0]
  cmdlineflags read 1 && if [(execcmd) 0]
  disc

  ret
end

proc ld 0 0
  162 sys0 disc

  cmdtmpbuffer
  "/usr/bin/ld" put 8 +
  "-dynamic-linker" put 8 +
  "/lib64/ld-linux-x86-64.so.2" put 8 +
  "-o" put 8 +
  outputbuffer put 8 +
  "-lc" put 8 +
  "temp.o" put 8 +
  NULL put
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(execcmdecho) 0]
  cmdlineflags read 1 && if [(execcmd) 0]
  disc

  cmdtmpbuffer
  "/usr/bin/rm" put 8 +
  "temp.o" put 8 +
  cmdlineflags read 2 && 0 == if [
    "temp.nasm" put 8 +
  ]
  NULL put 8 +
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(execcmdecho) 0]
  cmdlineflags read 1 && if [(execcmd) 0]
  disc

  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [2 (help)]

  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (args)

    (applyarg) if [copy (setinput)]

    copy argc 1 - <
  end
  disc

  outputbuffer
  readc 0 ==
  if [outputbuffer "output" (strcpy) disc disc]

  inputbuffer
  readc 0 ==
  if [2 (help)]

  {open output}
  511 65 "temp.nasm"
  0 100 -
  (open)
  outputfd swap put disc

  {parse input}
  (asmheader)

  (parseinc)

  inputbuffer
  (openinput)

  (parsefile)

  (asmfooter)

  {close output}
  outputfd read (close)

  {close input}
  inputfd read (close)

  (nasm)
  (ld)

  ret
end
