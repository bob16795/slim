inc lib/stdlib.slm
inc lib/tables.slm
inc lib/arrays.slm
inc lib/log.slm
inc lib/os.slm

{The Slim Compiler, written in Slim}

{TODO: Fix inc}
{TODO: Track stack}
{TODO: Local variables}
{TODO: rewrite props}

proc version 0 1
  "0.2.2" ret
end

enum
0   OP_BAD
    OP_NOP
    OP_PUSH
    OP_SUB
    OP_MUL
    OP_DIV
    OP_PLUS
    OP_SWAP
    OP_DUMP
    OP_COPY
    OP_COVR
    OP_READ
    OP_READC
    OP_PUTC
    OP_PUT
    OP_DISC
    OP_ARGV
    OP_ARGC
    OP_ENVP
    OP_PUSHP
    OP_CALLS
    OP_MULTI
    OP_CONST
    OP_RET
    OP_QUIT
    OP_LOCX
    OP_JUMPX
    OP_JUMP
    OP_IF
    OP_JNZ
    OP_GETP
    OP_CYCL
    OP_NQ
    OP_EQ
    OP_LT
    OP_GT
    OP_AND
    OP_OR
    OP_NOT
    OP_SYS0
    OP_SYS1
    OP_SYS2
    OP_SYS3
    OP_SYS4
    OP_SYS5
    OP_SYS6

    IDENT_INC 
    IDENT_GVAR
    IDENT_LVAR
    IDENT_CLASS
    IDENT_ENUM
    IDENT_PROC
    IDENT_DO
    IDENT_VAR
    IDENT_END
end

enum
0   CF_NONE

    CF_PROC_OUT
    CF_PROC_IN
    CF_PROC_NAME

    CF_CONST_VALUE
    CF_CONST_NAME

    CF_INC

    CF_VAR

    CF_GVAR_VALUE
    CF_GVAR_NAME

    CF_LVAR_VALUE
    CF_LVAR_NAME

    CF_ENUM_CONTENT
    CF_ENUM_START

    CF_CLASS
end

gvar gvarTab 300000
gvar lvarTab 100000
gvar constTab 300000
gvar procTab 300000

const READSIZE 2047
gvar cmdbuffer 2048
gvar blockbuffer 2048
gvar readbuffer 2048

gvar stringbuffer 100000
gvar stringbufferlen 8
gvar inputfd 8
gvar outputfd 8

gvar cmdlineflags 8

gvar identstack 128

gvar classname 64
gvar outputbuffer 128
gvar inputbuffer 128
gvar cmdtmpbuffer 128
gvar includebuffer 128
gvar includetmpbuffer 128
gvar tmpprocbuffer 128

gvar parseflags 8

gvar parseaddr 8
gvar parsesubaddr 8
gvar parsestringidx 8
gvar parsememory 8

const LOCAL_CAP 1024
gvar parsememorylocal 8

gvar constname 64
gvar enumvalue 8

proc getescape 1 1
  copy 101 == if [ disc 27 ret ]
  copy 110 == if [ disc 10 ret ]
  copy 164 == if [ disc 9  ret ]
  ret
end

proc getnameop 1 1
  OP_BAD
  covr "proc"  (str.eq) if [disc IDENT_PROC]
  covr "do"    (str.eq) if [disc IDENT_DO]
  covr "end"   (str.eq) if [disc IDENT_END]
  covr "inc"   (str.eq) if [disc IDENT_INC]
  covr "enum"  (str.eq) if [disc IDENT_ENUM]
  covr "var"   (str.eq) if [disc IDENT_VAR]
  covr "gvar"  (str.eq) if [disc IDENT_GVAR]
  {covr "lvar"  (str.eq) if [disc IDENT_LVAR]}
  covr "class" (str.eq) if [disc IDENT_CLASS]
  
  covr "nop"   (str.eq) if [disc OP_NOP]
  covr "}"     (str.eq) if [disc OP_NOP]
  covr "-"     (str.eq) if [disc OP_SUB]
  covr "*"     (str.eq) if [disc OP_MUL]
  covr "/"     (str.eq) if [disc OP_DIV]
  covr "+"     (str.eq) if [disc OP_PLUS]
  covr "."     (str.eq) if [disc OP_PLUS]
  covr "swap"  (str.eq) if [disc OP_SWAP]
  covr "dump"  (str.eq) if [disc OP_DUMP]
  covr "copy"  (str.eq) if [disc OP_COPY]
  covr "covr"  (str.eq) if [disc OP_COVR]
  covr "readc" (str.eq) if [disc OP_READC]
  covr "read"  (str.eq) if [disc OP_READ]
  covr "putc"  (str.eq) if [disc OP_PUTC]
  covr "put"   (str.eq) if [disc OP_PUT]
  covr "disc"  (str.eq) if [disc OP_DISC]
  covr "argv"  (str.eq) if [disc OP_ARGV]
  covr "argc"  (str.eq) if [disc OP_ARGC]
  covr "envp"  (str.eq) if [disc OP_ENVP]
  covr "()"    (str.eq) if [disc OP_CALLS]
  covr "const" (str.eq) if [disc OP_CONST]
  covr "prop"  (str.eq) if [disc OP_CONST]
  covr "ret"   (str.eq) if [disc OP_RET]
  covr "quit"  (str.eq) if [disc OP_QUIT]
  covr "if"    (str.eq) if [disc OP_IF]
  covr "cycl"  (str.eq) if [disc OP_CYCL]
  covr "!="    (str.eq) if [disc OP_NQ]
  covr "=="    (str.eq) if [disc OP_EQ]
  covr "<"     (str.eq) if [disc OP_LT]
  covr ">"     (str.eq) if [disc OP_GT]
  covr "&&"    (str.eq) if [disc OP_AND]
  covr "||"    (str.eq) if [disc OP_OR]
  covr "!"     (str.eq) if [disc OP_NOT]
  covr "sys0"  (str.eq) if [disc OP_SYS0]
  covr "sys1"  (str.eq) if [disc OP_SYS1]
  covr "sys2"  (str.eq) if [disc OP_SYS2]
  covr "sys3"  (str.eq) if [disc OP_SYS3]
  covr "sys4"  (str.eq) if [disc OP_SYS4]
  covr "sys5"  (str.eq) if [disc OP_SYS5]
  covr "sys6"  (str.eq) if [disc OP_SYS6]
  swap disc
  
  ret
end

proc getopname 1 1
  (str.int)
  {TODO: reimplement}

  ret
end

proc identstackpush 1 0
  identstack swap (arr.pushint)
  disc

  ret
end

proc identstackpop 0 1
  identstack (arr.popaddr) read swap disc

  ret
end

proc inner 1 1
  1 + copy
  copy (str.len) 1 - + 0 putc disc
  ret
end

proc getstringidx 0 1
  parsestringidx read
  copy 1 +
  parsestringidx swap put disc
  ret
end

proc getaddr 0 1
  parsesubaddr
  0 put disc

  parseaddr read
  copy 1 +
  parseaddr swap put disc
  ret
end

proc getsubaddr 0 1
  parsesubaddr read
  copy 1 +
  parsesubaddr swap put disc
  ret
end

proc exit 0 0
  {close output}
  outputfd read
  copy != 0 if [(close) 0]
  disc

  {close input}
  inputfd read
  copy != 0 if [(close) 0]
  disc

  0 1 - quit
  disc
  ret
end

proc noprocblock 0 0
  0 1 (log.level)
  "ERR" "Proc not found: " (log.msg)
  blockbuffer 1 + (log.cat)
  (log.log)
  (exit)

  ret
end


proc noproc 0 0
  0 1 (log.level)
  "ERR" "Proc not found: " (log.msg)
  cmdbuffer 1 + (log.cat)
  (log.log)
  (exit)
  
  ret
end

proc writeout 2 0
  outputfd read (write)
  ret
end

proc writeoutln 0 0
  '\n' (writeout)

  ret
end

proc setclassname 0 0
  cmdbuffer classname swap (str.copy) disc disc

  IDENT_CLASS (identstackpush)

  parseflags
  CF_NONE
  put disc

  ret
end

proc getexpandedname 1 1
  tmpprocbuffer (str.clear) disc
  classname (str.len) 0 != if [
    tmpprocbuffer copy (str.len) +
    classname (str.copy) disc disc
    tmpprocbuffer copy (str.len) +
    "." (str.copy) disc disc
  ]
  tmpprocbuffer copy (str.len) +
  swap (str.copy) disc disc
  tmpprocbuffer

  ret
end

proc addproc 0 0
  ' ' (writeout)
  cmdbuffer copy (str.len) swap (writeout)
  parseflags copy read
  copy CF_PROC_NAME == if [
    procTab
    cmdbuffer (getexpandedname) parseaddr read (tab.put) disc
  ]
  copy CF_PROC_OUT == if [
    (writeoutln)
  ]
  1 -
  putc disc

  ret
end

proc addconst 0 0

  parseflags
  copy read 1 - copy
  CF_CONST_VALUE 1 - == if [
    constTab constname (getexpandedname) cmdbuffer (tonum) (tab.put) disc
    disc CF_NONE
  ] copy CF_CONST_NAME 1 - == if [
    cmdbuffer constname (str.clear) swap (str.copy) disc disc
  ]
  put disc

  ret
end

proc addgvar 0 0
  parseflags
  copy read 1 -
  copy CF_GVAR_VALUE 1 - == if [
    gvarTab constname (getexpandedname) parsememory read (tab.put) disc
    cmdbuffer (tonum)
    parsememory read +
    parsememory swap put disc
    disc CF_NONE
  ] copy CF_GVAR_NAME 1 - == if [
    cmdbuffer constname (str.clear) swap (str.copy) disc disc
  ]
  put disc

  ret
end

proc addlvar 0 0
  parseflags
  copy read 1 -
  copy CF_LVAR_VALUE 1 - == if [
    lvarTab constname parsememorylocal read (tab.put) disc
    cmdbuffer (tonum)
    parsememorylocal read +
    parsememorylocal swap put disc
    disc CF_NONE
  ] copy CF_LVAR_NAME 1 - == if [
    cmdbuffer constname (str.clear) swap (str.copy) disc disc
  ]
  put disc

  ret
end

proc addenumstart 0 0
  enumvalue
  cmdbuffer (tonum)
  put disc

  parseflags
  CF_ENUM_CONTENT
  put disc

  ret
end

proc addenum 0 0 
  cmdbuffer (alphanum) if [
    enumvalue
    cmdbuffer (tonum)
    put disc

    ret
  ]

  cmdbuffer "end" (str.eq) if [
    parseflags
    CF_NONE
    put disc
    ret
  ]

  constTab cmdbuffer (getexpandedname) enumvalue read (tab.put) disc

  enumvalue read
  1 +
  enumvalue swap put disc

  ret
end

proc addinc 0 0 
  parseflags
  CF_NONE
  putc disc

  ret
end

proc addvar 0 0
  '    push mem+' (writeout)
  parsememory read (str.int) copy (str.len) swap (writeout)
  (writeoutln)

  cmdbuffer (tonum)
  parsememory read +
  parsememory swap put
  disc

  parseflags
  CF_NONE
  putc disc

  ret
end

proc asmheader 0 0
    stringbufferlen 1 put disc
    'format ELF64 executable 3\n' (writeout)
    'segment readable executable\n' (writeout)
    'print:\n' (writeout)
    '    mov r10, rsp\n' (writeout)
    '    sub rsp, 8\n' (writeout)
    '    mov [rsp], al\n' (writeout)
    '    mov edi, 1\n' (writeout)
    '    mov rsi, rsp\n' (writeout)
    '    mov edx, 1\n' (writeout)
    '    mov eax, 1\n' (writeout)
    '    syscall\n' (writeout)
    '    mov rsp, r10\n' (writeout)
    '    ret\n' (writeout)
    ret
end

proc asmfooter 0 0
  'addr_' (writeout)
  (getaddr) (str.int) copy (str.len) swap (writeout)
  ':\n' (writeout)
  '    ret\n' (writeout)
  'entry start\n' (writeout)
  'start:\n' (writeout)
  '    mov qword [args_ptr], rsp\n' (writeout)
  '    mov qword [ret_stack_rsp], ret_stack\n' (writeout)
  '    mov rax, [ret_stack_rsp]\n' (writeout)
  '    mov qword [rax], quit\n' (writeout)
  '    jmp addr_' (writeout)
  procTab
  "main" (tab.in) ! if [
    "no main proc defined" (str.println)
    (exit)
  ]
  "main" (tab.get) 1 - (str.int) copy (str.len) swap (writeout)
  (writeoutln)
  'quit:\n' (writeout)
  '    mov rax, 60\n' (writeout)
  '    mov rdi, 0\n' (writeout)
  '    syscall\n' (writeout)
  'segment readable writeable\n' (writeout)
  stringbuffer 1 + stringbufferlen read 1 - swap (writeout)
  'args_ptr: rq 1\n' (writeout)
  'ret_stack_rsp: rq 1\n' (writeout)
  'ret_stack: rb 65536\n' (writeout)
  (writeoutln)
  'mem: rb ' (writeout)
  parsememory read (str.int) copy (str.len) swap (writeout)
  (writeoutln)
  disc
  ret
end

proc endopasm 1 0
  copy IDENT_DO == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    (identstackpop) (str.int) copy (str.len) swap (writeout)
    (writeoutln)
  ]
  copy IDENT_CLASS == if [
    classname (str.clear) disc
  ]
  copy IDENT_PROC == if [
    lvarTab 50 (mem.zero)
    lvarTab 20 100000 (tab.new) disc
  ]
  disc
  ret
end

proc endopblockasm 1 0
  copy IDENT_DO == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 - (str.int) copy (str.len) swap (writeout)
    '_' (writeout)
    parsesubaddr read (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    (identstackpop) (str.int) copy (str.len) swap (writeout)
    '_' (writeout)
    (identstackpop) (str.int) copy (str.len) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc writeaddr 0 0
  'addr_' (writeout)
  (getaddr) (str.int) copy (str.len) swap (writeout)
  ':' (writeout)
  (writeoutln)

  ret
end

proc writesubaddr 0 0
  'addr_' (writeout)
  parseaddr read 1 - (str.int) copy (str.len) swap (writeout)
  '_' (writeout)
  (getsubaddr) (str.int) copy (str.len) swap (writeout)
  ':' (writeout)
  (writeoutln)

  ret
end

proc badblockop 0 0
  "BAD OPERATION: " (str.println)
  "`" (str.print) blockbuffer (str.print) "`" (str.println)

  "chunk" (str.println)
  readbuffer (str.println)
  "block" (str.println)
  cmdbuffer (str.println)
  (exit)

  ret
end


proc checkbadblock 1 1
  constTab blockbuffer (tab.in) if [
    blockbuffer (tab.get) swap disc
    (str.int)
    blockbuffer (str.clear) swap (str.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  lvarTab blockbuffer (tab.in) if [
    '    push lmem+' (writeout)
    lvarTab blockbuffer (tab.get) swap disc (str.int) copy (str.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  gvarTab blockbuffer (tab.in) if [
    '    push mem+' (writeout)
    gvarTab blockbuffer (tab.get) swap disc (str.int) copy (str.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badblockop)
  ret
end


proc getblockasm 1 1
  blockbuffer (alphanum) if [
    disc
    OP_PUSH
  ]

  (writesubaddr)

  copy OP_BAD == if (checkbadblock)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    '    mov qword rax, ' (writeout)
    blockbuffer copy (str.len) swap (writeout)
    (writeoutln)
    '    push rax\n' (writeout)
    ret
  ] copy OP_COPY == if [
    '    pop rax\n' (writeout)
    '    push rax\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SWAP == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_SUB == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    sub rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PLUS == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    add rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_AND == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    and rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_OR == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    or rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NOT == if [
    '    pop rax\n' (writeout)
    '    xor rax, 1\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_MUL == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    imul rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DIV == if [
    '    xor rdx, rdx\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    idiv rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rdx\n' (writeout)
    ret
  ] copy OP_COVR == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_ARGC == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ARGV == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ENVP == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    add rax, 2\n' (writeout)
    '    shl rax, 3\n' (writeout)
    '    mov rbx, [args_ptr]\n' (writeout)
    '    add rbx, rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_QUIT == if [
    '    mov rax, 60\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    jmp quit\n' (writeout)
    ret
  ] copy OP_RET == if [
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    sub rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    jmp qword [rax]\n' (writeout)
    ret
  ] copy OP_DISC == if [
    '    pop rax\n' (writeout)
    ret
  ] copy OP_READC == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov bl, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_READ == if [
    '   pop rax\n' (writeout)
    '   xor rbx, rbx\n' (writeout)
    '   mov rbx, [rax]\n' (writeout)
    '   push rbx\n' (writeout)
    ret
  ] copy OP_PUTC == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov byte [rax], bl\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PUT == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov qword [rax], rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovne rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_EQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmove rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_GT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovg rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_LT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovl rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_IF == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 - (str.int) copy (str.len) swap (writeout)
    '_' (writeout)
    parsesubaddr read 1 + (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    '    pop rax\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS1 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS2 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS3 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS4 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS5 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS6 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    pop r9\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DUMP == if [
    '    pop rax\n' (writeout)
    '    call print\n' (writeout)
    ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopblockasm)
    ret
  ] copy IDENT_DO == if [
    parsesubaddr read 1 - (identstackpush)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_LVAR == if [
    parseflags
    CF_LVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  '; unimp ' (writeout)
  (getopname) copy (str.len) swap (writeout)
  ' ' (writeout)
  cmdbuffer copy (str.len) swap (writeout)
  (writeoutln)
  ret
end

proc parsestring 0 0

  { add code }
  '    push str_' (writeout)
  (getstringidx) (str.int) copy (str.len) swap (writeout)
  (writeoutln)

  { put the header }
  'str_'
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (str.int)
  copy (str.len) swap
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  ': db '
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  blockbuffer 1 +

  { put the first char }
  copy readc
  (str.int)
  copy (str.len) swap
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    ', '
    stringbuffer stringbufferlen read +
    swap (str.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (str.int)
    copy (str.len) swap
    stringbuffer stringbufferlen read +
    swap (str.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  '\n'
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  disc

  blockbuffer (str.clear) disc
  ret
end

proc parseblockcmd 0 0
  blockbuffer readc 123 == blockbuffer (str.last) 125 == && if [
    {comment}

    nop

    blockbuffer (str.clear) disc
  ] blockbuffer readc 34 == blockbuffer (str.last) 34 == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner)
    (parsestring)

    disc ret
  ] blockbuffer readc 39 == blockbuffer (str.last) 39 == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner) disc
    '    push ' (writeout)
    blockbuffer 1 + (str.len) (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    
    (parsestring)
    ret
  ] blockbuffer readc 40 == blockbuffer (str.last) 41 == && if [

    (writesubaddr)
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    mov qword [rax], addr_' (writeout)
    parseaddr read 1 - (str.int) copy (str.len) swap (writeout)
    '_' (writeout)
    parsesubaddr read (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    blockbuffer (inner) disc
    procTab
    blockbuffer 1 + (tab.in) ! if (noprocblock)
    blockbuffer 1 + (tab.get) (str.int)
    copy (str.len) swap
    (writeout)
    disc
    blockbuffer (str.clear) disc
    (writeoutln)
    ret
  ] blockbuffer readc 0 != if [
    parseflags read
    blockbuffer (getnameop)
    covr CF_NONE == if (getblockasm)
    covr CF_VAR == if (addvar)
    covr CF_LVAR_VALUE == if (addlvar)
    covr CF_LVAR_NAME == if (addlvar)
    disc disc
  ]
  blockbuffer (str.clear) disc

  ret
end

proc badop 0 0
  "BAD OPERATION: " (str.println)
  "`" (str.print) cmdbuffer (str.print) "`" (str.println)

  "chunk" (str.println)
  readbuffer (str.println)
  (exit)

  ret
end

proc checkbad 1 1
  constTab cmdbuffer (tab.in) if [
    cmdbuffer (tab.get) swap disc
    (str.int)
    cmdbuffer (str.clear) swap (str.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  lvarTab cmdbuffer (tab.in) if [
    '    push lmem+' (writeout)
    lvarTab cmdbuffer (tab.get) swap disc (str.int) copy (str.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  gvarTab cmdbuffer (tab.in) if [
    '    push mem+' (writeout)
    gvarTab cmdbuffer (tab.get) swap disc (str.int) copy (str.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badop)
  ret
end

proc getcmdasm 1 1
  cmdbuffer (alphanum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if (checkbad)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    '    mov qword rax, ' (writeout)
    cmdbuffer copy (str.len) swap (writeout)
    (writeoutln)
    '    push rax\n' (writeout)
    ret
  ] copy OP_COPY == if [
    '    pop rax\n' (writeout)
    '    push rax\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SWAP == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_SUB == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    sub rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PLUS == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    add rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_AND == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    and rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_OR == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    or rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NOT == if [
    '    pop rax\n' (writeout)
    '    xor rax, 1\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_MUL == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    imul rax, rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DIV == if [
    '    xor rdx, rdx\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    idiv rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rdx\n' (writeout)
    ret
  ] copy OP_COVR == if [
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    push rbx\n' (writeout)
    '    push rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy IDENT_CLASS == if [
    parseflags
    CF_CLASS
    put disc
    ret
  ] copy IDENT_PROC == if [
    IDENT_PROC (identstackpush)
    '    ; - proc' (writeout)
    parseflags
    CF_PROC_NAME
    put disc
    ret
  ] copy IDENT_ENUM == if [
    '    ; - enum\n' (writeout)
    parseflags
    CF_ENUM_START
    put disc
    ret
  ] copy OP_ARGC == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ARGV == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_ENVP == if [
    '    mov rax, [args_ptr]\n' (writeout)
    '    mov rax, [rax]\n' (writeout)
    '    add rax, 2\n' (writeout)
    '    shl rax, 3\n' (writeout)
    '    mov rbx, [args_ptr]\n' (writeout)
    '    add rbx, rax\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_QUIT == if [
    '    mov rax, 60\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    jmp quit\n' (writeout)
    ret
  ] copy OP_RET == if [
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    sub rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    jmp qword [rax]\n' (writeout)
    ret
  ] copy OP_DISC == if [
    '    pop rax\n' (writeout)
    ret
  ] copy OP_CONST == if [
    parseflags
    CF_CONST_NAME
    put disc
    ret
  ] copy OP_READC == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov bl, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_READ == if [
    '    pop rax\n' (writeout)
    '    xor rbx, rbx\n' (writeout)
    '    mov rbx, [rax]\n' (writeout)
    '    push rbx\n' (writeout)
    ret
  ] copy OP_PUTC == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov byte [rax], bl\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_PUT == if [
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    mov qword [rax], rbx\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_NQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovne rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_EQ == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rax\n' (writeout)
    '    pop rbx\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmove rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_GT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovg rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_LT == if [
    '    mov rcx, 0\n' (writeout)
    '    mov rdx, 1\n' (writeout)
    '    pop rbx\n' (writeout)
    '    pop rax\n' (writeout)
    '    cmp rax, rbx\n' (writeout)
    '    cmovl rcx, rdx\n' (writeout)
    '    push rcx\n' (writeout)
    ret
  ] copy OP_IF == if [
    '    pop rbx\n' (writeout)
    '    test rbx, rbx\n' (writeout)
    '    jz addr_' (writeout)
    parseaddr read 1 + (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    '    pop rax\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS1 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS2 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS3 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS4 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS5 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_SYS6 == if [
    '    pop rax\n' (writeout)
    '    pop rdi\n' (writeout)
    '    pop rsi\n' (writeout)
    '    pop rdx\n' (writeout)
    '    pop r10\n' (writeout)
    '    pop r8\n' (writeout)
    '    pop r9\n' (writeout)
    '    syscall\n' (writeout)
    '    push rax\n' (writeout)
    ret
  ] copy OP_DUMP == if [
    '    pop rax\n' (writeout)
    '    call print\n' (writeout)
    ret
  ] copy IDENT_INC == if [
    parseflags
    CF_INC
    put disc
    ret
  ] copy IDENT_END == if [
    (identstackpop)
    (endopasm)
    ret
  ] copy IDENT_DO == if [
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_LVAR == if [
    parseflags
    CF_LVAR_NAME
    put disc
    ret
  ] copy IDENT_GVAR == if [
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  '; unimp ' (writeout)
  (getopname) copy (str.len) swap (writeout)
  ' ' (writeout)
  cmdbuffer copy (str.len) swap (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  {""}
  cmdbuffer readc 34 == cmdbuffer (str.last) 34 != &&
  cmdbuffer """ (str.eq) ||
  {'  '}
  cmdbuffer readc 39 == cmdbuffer (str.last) 39 != && ||
  cmdbuffer "'" (str.eq) ||
  {[]}
  cmdbuffer readc 91 == cmdbuffer (str.last) 93 != && ||
  {{}}
  cmdbuffer readc 123 == cmdbuffer (str.last) 125 != && ||
  !

  ret
end

proc checkblockcmd 0 1
  {""}
  blockbuffer readc 34 == blockbuffer (str.last) 34 != &&
  blockbuffer """ (str.eq) ||
  {''}
  blockbuffer readc 39 == blockbuffer (str.last) 39 != && ||
  blockbuffer "'" (str.eq) ||
  {[]}
  blockbuffer readc 91 == blockbuffer (str.last) 93 != && ||
  {{}}
  blockbuffer readc 123 == blockbuffer (str.last) 125 != && ||
  !

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc blockbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32

  ret
end

proc parseblock 0 0
  cmdbuffer
  blockbuffer
  do
    covr readc
    copy 9 {tab} ==
    covr 10 {lf} == ||
    covr 13 {cr} == ||
    covr 32 {spc} == ||
    if (checkbufferblock)

    blockbuffer readc

    copy 34 ==
    swap 39 == ||
    covr 92 == &&
    if [
      disc
      swap 1 +
      swap

      covr readc (getescape)
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc

  blockbuffer
  32
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  ret
end

proc parsestringblock 0 0 

  { add code }
  '    push str_' (writeout)
  (getstringidx) (str.int) copy (str.len) swap (writeout)
  (writeoutln)

  { put the header }
  'str_'
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (str.int)
  copy (str.len) swap
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  ': db '
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer 1 +

  { put the first char }
  copy readc
  (str.int)
  copy (str.len) swap
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    ', '
    stringbuffer stringbufferlen read +
    swap (str.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (str.int)
    copy (str.len) swap
    stringbuffer stringbufferlen read +
    swap (str.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  disc
  '\n'
  stringbuffer stringbufferlen read +
  swap (str.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer (str.clear) disc
  ret
end

proc parsecmd 0 0
  cmdbuffer readc 123 == cmdbuffer (str.last) 125 == && if [

    cmdbuffer (str.clear) disc
    ret
  ]
  cmdbuffer readc 34 == cmdbuffer (str.last) 34 == && if [
    (writeaddr)

    cmdbuffer (inner)
    (parsestringblock)
    disc ret
  ] cmdbuffer readc 39 == cmdbuffer (str.last) 39 == && if [
    {string}
    (writeaddr)

    cmdbuffer (inner) disc
    '    push ' (writeout)
    cmdbuffer 1 + (str.len) (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    
    (parsestringblock)
    ret
  ]
  cmdbuffer readc 91 == cmdbuffer (str.last) 93 == && if [
    (writeaddr)
    cmdbuffer (inner)
    cmdbuffer swap (str.copy) disc disc
    cmdbuffer copy (str.len) 1 - + 0 putc disc
    (parseblock)
    cmdbuffer (str.clear) disc
    ret
  ]
  cmdbuffer readc 40 == cmdbuffer (str.last) 41 == && if [
    (writeaddr)
    '    mov rax, [ret_stack_rsp]\n' (writeout)
    '    add rax, 8\n' (writeout)
    '    mov qword [ret_stack_rsp], rax\n' (writeout)
    '    mov qword [rax], addr_' (writeout)
    parseaddr read (str.int) copy (str.len) swap (writeout)
    (writeoutln)
    '    jmp addr_' (writeout)
    cmdbuffer (inner) disc
    procTab
    cmdbuffer 1 + (tab.in) 0 == if (noproc)
    cmdbuffer 1 + (tab.get) (str.int)
    copy (str.len) swap
    (writeout)
    disc
    cmdbuffer (str.clear) disc
    (writeoutln)
    ret
  ]
  cmdbuffer readc 0 != if [
    parseflags read
    cmdbuffer (getnameop)
    covr CF_NONE == if (getcmdasm)
    covr CF_PROC_OUT == if (addproc)
    covr CF_PROC_IN == if (addproc)
    covr CF_PROC_NAME == if (addproc)
    covr CF_CONST_VALUE == if (addconst)
    covr CF_CONST_NAME == if (addconst)
    covr CF_INC == if (addinc)
    covr CF_VAR == if (addvar)
    covr CF_LVAR_NAME == if (addlvar)
    covr CF_LVAR_VALUE == if (addlvar)
    covr CF_GVAR_NAME == if (addgvar)
    covr CF_GVAR_VALUE == if (addgvar)
    covr CF_ENUM_CONTENT == if (addenum)
    covr CF_ENUM_START == if (addenumstart)
    covr CF_CLASS == if (setclassname)
    disc disc
  ]
  cmdbuffer (str.clear) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc cmdbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  READSIZE readbuffer
  inputfd read (read) disc
  inputfd read 74 sys1 disc
  do
    readbuffer
    cmdbuffer
    do
      covr readc

      copy 9 {tab} ==
      covr 10 {lf} == ||
      covr 13 {cr} == ||
      covr 32 {spc} == ||
      if (checkbuffer)

      cmdbuffer readc

      copy 34 ==
      swap 39 == ||
      covr 92 == &&
      if [
        disc
        swap 1 +
        swap

        covr readc (getescape)
      ]

      covr
      swap
      putc disc

      swap
      1 +
      swap
      copy readc 0 != if [
        1 +
      ]

      covr readc 0 !=
    end
    disc
    disc

    readbuffer (str.clear)

    cmdbuffer (str.copy) disc disc

    READSIZE cmdbuffer (str.len) -

    readbuffer cmdbuffer (str.len) +

    inputfd read (read) copy
    readbuffer + cmdbuffer (str.len) + 1 + copy readc 0 != if (str.clear) disc
    inputfd read 74 sys1 disc

    cmdbuffer (str.clear) disc
  end

  ret
end

{
args: int
result:

prints a help string
}
proc help 1 0
  copy 100 == if [
    "slim compiler v" (str.print) (version) (str.println)
    (exit)
  ]
  "INVALID HELP ID"
  covr 1 == if [
    disc
    "Help"
  ] covr 2 == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr 3 == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (str.println)
  "slim compiler v" (str.print) (version) (str.print) " usage:" (str.println)
  (str.cr)
  "slim [-h]\ [-a]\ [-s]\ [-i include]\ [-o output]\ file" (str.println)
  (str.cr)
  "-v            shows the version and exits." (str.println)
  "-h, --help    shows this help message." (str.println)
  "-i, --include includes a library." (str.println)
  "-s, --silent  disables output text." (str.println)
  "-a, --asm     keeps the assembly code." (str.println)
  "-o, --output  selects the output file." (str.println)
  disc
  (exit)

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  cmdlineflags
  cmdlineflags read 1 ||
  put
  disc
  ret
end

proc setasm 0 0
  cmdlineflags
  cmdlineflags read 2 ||
  put
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [3 (help)]

    outputbuffer
    covr (os.args)
    (str.copy)

    disc
    disc
    ret
end

proc openinput 1 0
  inputfd read
  copy != 0 if [(close) 0]
  disc

  cmdlineflags read ! if [
    0 1 (log.level)
    "SLM" covr (log.msg)
    (log.log)
  ]

  {open input}
  0 swap 0 swap
  0 100 -
  (open)
  inputfd swap put disc

  ret
end

proc parseinc 0 0
  includebuffer read NULL == if ret
  includebuffer
  includetmpbuffer
  do
    covr readc

    copy 44 ==
    if [
      includetmpbuffer (openinput)
      (parsefile)
      includetmpbuffer (str.clear) disc
      disc disc
      includetmpbuffer 0
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc
  includetmpbuffer (openinput)
  (parsefile)
  includetmpbuffer (str.clear) disc

  ret
end

proc setinclude 1 1
    copy argc 1 - > if [3 (help)]

    includebuffer
    covr (os.args)
    (str.copy)

    disc
    disc
    ret
end

proc setinput 1 0
  inputbuffer
  readc 0 != if [2 (help)]

  { set input to argument if its not a flag }
  inputbuffer
  covr (os.args)
  (str.copy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (str.eq)
  if [disc 1 (help) 0 ret]
  copy "-v" (str.eq)
  if [disc 100 (help) 0 ret]
  copy "-i" (str.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--include" (str.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--help" (str.eq)
  if [disc 1 (help) 0 ret]
  copy "-o" (str.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (str.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (str.eq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (str.eq)
  if [disc (setsilent) 0 ret]
  copy "-a" (str.eq)
  if [disc (setasm) 0 ret]
  copy "--asm" (str.eq)
  if [disc (setasm) 0 ret]
  disc
  1 ret
end

proc nasm 0 0
  cmdtmpbuffer
  "/usr/bin/fasm" put 8 +
  "-m" put 8 +
  "524288" put 8 + 
  "temp.nasm" put 8 +
  "temp.tmp" put 8 +

  NULL put
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc ld 0 0
  162 sys0 disc

  cmdtmpbuffer
  "/usr/bin/mv" put 8 +
  "temp.tmp" put 8 +
  outputbuffer put 8 +
  NULL put
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  cmdtmpbuffer
  "/usr/bin/rm" put 8 +
  cmdlineflags read 2 && 0 == if [
    "temp.nasm" put 8 +
  ]
  NULL put 8 +
  disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc initobjs 0 0
  gvarTab  20 300000 (tab.new) disc
  lvarTab  20 100000 (tab.new) disc
  constTab 20 300000 (tab.new) disc
  procTab  20 300000 (tab.new) disc
  identstack 8 4096  (arr.new) disc
  
  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [2 (help)]

  (initobjs)

  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (os.args)

    (applyarg) if [copy (setinput)]

    copy argc 1 - <
  end
  disc

  outputbuffer
  readc 0 ==
  if [outputbuffer "output" (str.copy) disc disc]

  inputbuffer
  readc 0 ==
  if [2 (help)]

  {open output}
  511 65 "temp.nasm"
  0 100 -
  (open)
  outputfd swap put disc

  {parse input}
  (asmheader)

  (parseinc)

  inputbuffer
  (openinput)

  (parsefile)

  (asmfooter)

  {close output}
  outputfd read (close)

  {close input}
  inputfd read (close)

  (nasm)
  (ld)

  0 quit

  disc ret
end
