{
The Slim Compiler, written in Slim

Preston Precourt (prestosilver) 2022

TODO: Const copy
TODO: Const size gvar
TODO: Track stack blocks    
TODO: Fix inc
TODO: Macros
TODO: Local variables
TODO: Imp first class funcs
TODO: Clean magic nums
}

inc lib/stdlib.slm
inc lib/tables.slm
inc lib/arrays.slm
inc lib/log.slm
inc lib/os.slm

proc version 0 1
  "0.3.2" ret
end

enum
0   OP_BAD
    OP_NOP
    OP_PUSH
    OP_SUB
    OP_MUL
    OP_DIV
    OP_PLUS
    OP_SWAP
    OP_DUMP
    OP_COPY
    OP_COVR
    OP_READ
    OP_READC
    OP_PUTC
    OP_PUT
    OP_DISC
    OP_ARGV
    OP_ARGC
    OP_ENVP
    OP_PUSHP
    OP_CALLS
    OP_MULTI
    OP_CONST
    OP_RET
    OP_QUIT
    OP_LOCX
    OP_JUMPX
    OP_JUMP
    OP_IF
    OP_JNZ
    OP_GETP
    OP_CYCL
    OP_NQ
    OP_EQ
    OP_LT
    OP_GT
    OP_AND
    OP_XOR
    OP_OR
    OP_NOT
    OP_SYS0
    OP_SYS1
    OP_SYS2
    OP_SYS3
    OP_SYS4
    OP_SYS5
    OP_SYS6

    IDENT_INC 
    IDENT_GVAR
    IDENT_LVAR
    IDENT_CLASS
    IDENT_ENUM
    IDENT_PROP
    IDENT_PROC
    IDENT_DO
    IDENT_VAR
    IDENT_END
end

enum
0   CF_NONE

    CF_PROC_OUT
    CF_PROC_IN
    CF_PROC_NAME

    CF_CONST_VALUE
    CF_CONST_NAME

    CF_PROP_VALUE
    CF_PROP_NAME

    CF_INC

    CF_VAR

    CF_GVAR_VALUE
    CF_GVAR_NAME

    CF_LVAR_VALUE
    CF_LVAR_NAME

    CF_ENUM_CONTENT
    CF_ENUM_START

    CF_CLASS
end

enum
1   HELP_VERSION
    HELP_SHOW
    HELP_ARGS
    HELP_OUTPUT
end

const TAB_KEY_SIZE 20
gvar gvarTab 300000
gvar lvarTab 100000
gvar constTab 300000
gvar procTab 300000
gvar procstackTab 300000

const READSIZE 2047
gvar cmdbuffer 2048
gvar blockbuffer 2048
gvar readbuffer 2048

gvar stringbuffer 100000
gvar stringbufferlen 8
gvar inputfd 8
gvar outputfd 8

gvar cmdlineflags 8

gvar identstack 128

gvar classname 64
gvar outputbuffer 64
gvar inputbuffer 64
gvar cmdtmpbuffer 64
gvar tmpprocbuffer 64
gvar includebuffer 128
gvar includetmpbuffer 128

gvar parseflags 8

gvar parseaddr 8
gvar parsesubaddr 8
gvar parsestringidx 8
gvar parsememory 8

gvar parsestack 8
gvar parsestackblock 8

const LOCAL_CAP 1024
gvar parsememorylocal 8

gvar constname 64
gvar enumvalue 8
gvar propsize 8

gvar procname 64
gvar procstats 8

proc getescape 1 1
  copy 'e' == if [ disc 27 ret ]
  copy 'r' == if [ disc 13 ret ]
  copy 'n' == if [ disc 10 ret ]
  copy 't' == if [ disc 9  ret ]
  ret
end

proc getnameop 1 1
  OP_BAD
  covr "proc"  (cstr.eq) if [disc IDENT_PROC]
  covr "do"    (cstr.eq) if [disc IDENT_DO]
  covr "end"   (cstr.eq) if [disc IDENT_END]
  covr "inc"   (cstr.eq) if [disc IDENT_INC]
  covr "enum"  (cstr.eq) if [disc IDENT_ENUM]
  covr "var"   (cstr.eq) if [disc IDENT_VAR]
  covr "gvar"  (cstr.eq) if [disc IDENT_GVAR]
  {covr "lvar"  (cstr.eq) if [disc IDENT_LVAR]}
  covr "class" (cstr.eq) if [disc IDENT_CLASS]
  covr "prop"  (cstr.eq) if [disc IDENT_PROP]
  
  covr "nop"   (cstr.eq) if [disc OP_NOP]
  covr "-"     (cstr.eq) if [disc OP_SUB]
  covr "*"     (cstr.eq) if [disc OP_MUL]
  covr "/"     (cstr.eq) if [disc OP_DIV]
  covr "+"     (cstr.eq) if [disc OP_PLUS]
  covr "^"     (cstr.eq) if [disc OP_XOR]
  covr "."     (cstr.eq) if [disc OP_PLUS]
  covr "swap"  (cstr.eq) if [disc OP_SWAP]
  covr "dump"  (cstr.eq) if [disc OP_DUMP]
  covr "copy"  (cstr.eq) if [disc OP_COPY]
  covr "covr"  (cstr.eq) if [disc OP_COVR]
  covr "readc" (cstr.eq) if [disc OP_READC]
  covr "read"  (cstr.eq) if [disc OP_READ]
  covr "@"     (cstr.eq) if [disc OP_READ]
  covr "putc"  (cstr.eq) if [disc OP_PUTC]
  covr "put"   (cstr.eq) if [disc OP_PUT]
  covr "="     (cstr.eq) if [disc OP_PUT]
  covr "disc"  (cstr.eq) if [disc OP_DISC]
  covr "argv"  (cstr.eq) if [disc OP_ARGV]
  covr "argc"  (cstr.eq) if [disc OP_ARGC]
  covr "envp"  (cstr.eq) if [disc OP_ENVP]
  covr "()"    (cstr.eq) if [disc OP_CALLS]
  covr "const" (cstr.eq) if [disc OP_CONST]
  covr "ret"   (cstr.eq) if [disc OP_RET]
  covr "quit"  (cstr.eq) if [disc OP_QUIT]
  covr "if"    (cstr.eq) if [disc OP_IF]
  covr "cycl"  (cstr.eq) if [disc OP_CYCL]
  covr "!="    (cstr.eq) if [disc OP_NQ]
  covr "=="    (cstr.eq) if [disc OP_EQ]
  covr "<"     (cstr.eq) if [disc OP_LT]
  covr ">"     (cstr.eq) if [disc OP_GT]
  covr "&&"    (cstr.eq) if [disc OP_AND]
  covr "||"    (cstr.eq) if [disc OP_OR]
  covr "!"     (cstr.eq) if [disc OP_NOT]
  covr "sys0"  (cstr.eq) if [disc OP_SYS0]
  covr "sys1"  (cstr.eq) if [disc OP_SYS1]
  covr "sys2"  (cstr.eq) if [disc OP_SYS2]
  covr "sys3"  (cstr.eq) if [disc OP_SYS3]
  covr "sys4"  (cstr.eq) if [disc OP_SYS4]
  covr "sys5"  (cstr.eq) if [disc OP_SYS5]
  covr "sys6"  (cstr.eq) if [disc OP_SYS6]
  swap disc
  
  ret
end

proc getopname 1 1
  (cstr.int)
  {TODO: reimplement}

  ret
end

proc checkpopb 2 0
  parsestackblock read swap -
  parsestackblock swap put disc
  parsestackblock read
  0 < if [
    copy (cstr.println)
    procstackTab (tab.print)
    disc -1 quit
  ]
  disc
  ret
end

proc addstackb 1 0
  parsestackblock read swap +
  parsestackblock swap put disc

  ret
end


proc checkpop 2 0
  parsestack read swap -
  parsestack swap put disc
  parsestack read
  0 < if [
    copy (cstr.println)
    procstackTab (tab.print)
    disc -1 quit
  ]
  disc
  ret
end

proc addstack 1 0
  parsestack read swap +
  parsestack swap put disc

  ret
end

proc identstackpush 1 0
  identstack swap (arr.pushint)
  disc

  ret
end

proc identstackpop 0 1
  identstack (arr.popaddr) read swap disc

  ret
end

proc inner 1 1
  1 + copy
  copy (cstr.len) 1 - + 0 putc disc
  ret
end

proc getstringidx 0 1
  parsestringidx read
  copy 1 +
  parsestringidx swap put disc
  ret
end

proc getaddr 0 1
  parsesubaddr
  0 put disc

  parseaddr read
  copy 1 +
  parseaddr swap put disc
  ret
end

proc getsubaddr 0 1
  parsesubaddr read
  copy 1 +
  parsesubaddr swap put disc
  ret
end

proc exit 0 0
  {close output}
  outputfd read
  copy 0 != if [(os.close) 0]
  disc

  {close input}
  inputfd read
  copy 0 != if [(os.close) 0]
  disc

  -1 quit
  ret
end

proc noprocblock 0 0
  0 1 (log.level)
  "ERR" "Proc not found: " (log.msg)
  blockbuffer 1 + (log.cat)
  (log.log)
  (exit)

  ret
end


proc noproc 0 0
  0 1 (log.level)
  "ERR" "Proc not found: " (log.msg)
  cmdbuffer 1 + (log.cat)
  (log.log)
  (exit)
  
  ret
end

proc writeout 2 0
  outputfd read (os.write)
  ret
end

proc writeoutln 0 0
  `\n` (writeout)
  ret
end

proc setclassname 0 0
  cmdbuffer classname swap (cstr.copy) disc disc

  IDENT_CLASS (identstackpush)

  parseflags
  CF_NONE
  put disc

  propsize
  0
  put disc

  ret
end

proc getexpandedname 1 1
  tmpprocbuffer (cstr.clear) disc
  classname (cstr.len) 0 != if [
    tmpprocbuffer copy (cstr.len) +
    classname (cstr.copy) disc disc
    tmpprocbuffer copy (cstr.len) +
    "." (cstr.copy) disc disc
  ]
  tmpprocbuffer copy (cstr.len) +
  swap (cstr.copy) disc disc
  tmpprocbuffer

  ret
end

proc addproc 0 0
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  parseflags copy read
  copy CF_PROC_NAME == if [
    procTab
    cmdbuffer (getexpandedname) parseaddr read (tab.put) disc
    procname (cstr.clear) cmdbuffer (cstr.copy) disc disc
  ] copy CF_PROC_IN == if [
    procstats
    cmdbuffer (cstr.tonum) 8589934591 &&
    put disc

    parsestack
    cmdbuffer (cstr.tonum) 8589934591 &&
    put disc

  ] copy CF_PROC_OUT == if [
    procstats
    procstats read
    cmdbuffer (cstr.tonum) 8589934591 &&
    4294967296 * ||
    put disc
    procstackTab
    procname (getexpandedname) procstats read (tab.put) disc
    (writeoutln)
  ]
  1 -
  putc disc

  ret
end

proc addprop 0 0
  parseflags
  copy read 1 - copy
  CF_PROP_VALUE 1 - == if [      
    constTab constname (getexpandedname) propsize read (tab.put) disc

    propsize
    propsize read cmdbuffer (cstr.tonum) +
    put disc

    disc CF_NONE
  ] copy CF_PROP_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

proc addconst 0 0
  parseflags
  copy read 1 - copy
  CF_CONST_VALUE 1 - == if [
    constTab constname (getexpandedname) cmdbuffer (cstr.tonum) (tab.put) disc
    disc CF_NONE
  ] copy CF_CONST_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

proc addgvar 0 0
  parseflags
  copy read 1 -
  copy CF_GVAR_VALUE 1 - == if [
    gvarTab constname (getexpandedname) parsememory read (tab.put) disc
    cmdbuffer (cstr.tonum)
    parsememory read +
    parsememory swap put disc
    disc CF_NONE
  ] copy CF_GVAR_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

proc addlvar 0 0
  parseflags
  copy read 1 -
  copy CF_LVAR_VALUE 1 - == if [
    lvarTab constname parsememorylocal read (tab.put) disc
    cmdbuffer (cstr.tonum)
    parsememorylocal read +
    parsememorylocal swap put disc
    disc CF_NONE
  ] copy CF_LVAR_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.copy) disc disc
  ]
  put disc

  ret
end

proc addenumstart 0 0
  enumvalue
  cmdbuffer (cstr.tonum)
  put disc

  parseflags
  CF_ENUM_CONTENT
  put disc

  ret
end

proc addenum 0 0 
  cmdbuffer (cstr.isnum) if [
    enumvalue
    cmdbuffer (cstr.tonum)
    put disc

    ret
  ]

  cmdbuffer "end" (cstr.eq) if [
    parseflags
    CF_NONE
    put disc
    ret
  ]

  constTab cmdbuffer (getexpandedname) enumvalue read (tab.put) disc

  enumvalue read
  1 +
  enumvalue swap put disc

  ret
end

proc addinc 0 0 
  parseflags
  CF_NONE
  put disc

  ret
end

proc addvar 0 0
  1 (addstack)
  `    push mem+` (writeout)
  parsememory read (cstr.int) copy (cstr.len) swap (writeout)
  (writeoutln)

  cmdbuffer (cstr.tonum)
  parsememory read +
  parsememory swap put
  disc

  parseflags
  CF_NONE
  put disc

  ret
end

proc asmheader 0 0
    stringbufferlen 1 put disc
    `format ELF64 executable 3\n` (writeout)
    `segment readable executable\n` (writeout)
    `print:\n` (writeout)
    `    mov r10, rsp\n` (writeout)
    `    sub rsp, 8\n` (writeout)
    `    mov [rsp], al\n` (writeout)
    `    mov edi, 1\n` (writeout)
    `    mov rsi, rsp\n` (writeout)
    `    mov edx, 1\n` (writeout)
    `    mov eax, 1\n` (writeout)
    `    syscall\n` (writeout)
    `    mov rsp, r10\n` (writeout)
    `    ret\n` (writeout)
    ret
end

proc asmfooter 0 0
  `addr_` (writeout)
  (getaddr) (cstr.int) copy (cstr.len) swap (writeout)
  `:\n` (writeout)
  `    ret\n` (writeout)
  `entry start\n` (writeout)
  `start:\n` (writeout)
  `    mov qword [args_ptr], rsp\n` (writeout)
  `    mov qword [ret_stack_rsp], ret_stack\n` (writeout)
  `    mov rax, [ret_stack_rsp]\n` (writeout)
  `    mov qword [rax], quit\n` (writeout)
  `    jmp addr_` (writeout)
  procTab
  "main" (tab.in) ! if [
    "no main proc defined" (cstr.println)
    (exit)
  ]
  "main" (tab.get) 1 - (cstr.int) copy (cstr.len) swap (writeout)
  (writeoutln)
  `quit:\n` (writeout)
  `    mov rax, 60\n` (writeout)
  `    mov rdi, 0\n` (writeout)
  `    syscall\n` (writeout)
  `segment readable writeable\n` (writeout)
  stringbuffer 1 + stringbufferlen read 1 - swap (writeout)
  `args_ptr: rq 1\n` (writeout)
  `ret_stack_rsp: rq 1\n` (writeout)
  `ret_stack: rb 65536\n` (writeout)
  `mem: rb ` (writeout)
  parsememory read (cstr.int) copy (cstr.len) swap (writeout)
  (writeoutln)
  disc
  ret
end

proc endopasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpop)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    (identstackpop) (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  copy IDENT_CLASS == if [
    constTab
    "SIZE" (getexpandedname) propsize read (tab.put)
    disc
    classname (cstr.clear) disc
  ]
  copy IDENT_PROC == if [
    lvarTab 50 (mem.zero)
    lvarTab 20 100000 (tab.new) disc
  ]
  disc
  ret
end

proc endopblockasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpopb)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 - (cstr.int) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    (identstackpop) (cstr.int) copy (cstr.len) swap (writeout)
    `_` (writeout)
    (identstackpop) (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc writeaddr 0 0
  `addr_` (writeout)
  (getaddr) (cstr.int) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  {
  parsestack read (cstr.printint)
  cmdbuffer (cstr.println)
  }

  ret
end

proc writesubaddr 0 0
  `addr_` (writeout)
  parseaddr read 1 - (cstr.int) copy (cstr.len) swap (writeout)
  `_` (writeout)
  (getsubaddr) (cstr.int) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  ret
end

proc badblockop 0 0
  "BAD OPERATION: " (cstr.println)
  "`" (cstr.print) blockbuffer (cstr.print) "`" (cstr.println)
  (exit)

  ret
end


proc checkbadblock 1 1
  blockbuffer (cstr.len) 3 ==
  blockbuffer readc ''' == &&
  blockbuffer (cstr.last) ''' == && if [
    blockbuffer 1 + readc
    (cstr.int)

    blockbuffer (cstr.clear) swap (cstr.copy) disc disc

    disc OP_PUSH
    ret
  ]
  constTab blockbuffer (tab.in) if [
    blockbuffer (tab.get) swap disc
    (cstr.int)
    blockbuffer (cstr.clear) swap (cstr.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  lvarTab blockbuffer (tab.in) if [
    1 (addstackb)
    `    push lmem+` (writeout)
    lvarTab blockbuffer (tab.get) swap disc (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  gvarTab blockbuffer (tab.in) if [
    1 (addstackb)
    `    push mem+` (writeout)
    gvarTab blockbuffer (tab.get) swap disc (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badblockop)
  ret
end

proc badret 0 0
  procstackTab
  procname (getexpandedname) (tab.get)
  4294967296 / disc
  255 && (cstr.printint)
  disc

  procname (cstr.println)
  parsestack read (cstr.printint)
  "Error: proc dosent return correct ammount" (cstr.println)
  -1 quit

  ret
end

proc getblockasm 1 1
  blockbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writesubaddr)

  copy OP_BAD == if (checkbadblock)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    "push" 0 (checkpopb)
    1 (addstackb)
    `    mov qword rax, ` (writeout)
    blockbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push rax\n` (writeout)
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpopb)
    2 (addstackb)
    `    pop rax\n` (writeout)
    `    push rax\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpopb)
    2 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    sub rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    add rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    and rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    xor rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    or rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    xor rax, 1\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    imul rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "div" 2 (checkpopb)
    2 (addstackb)
    `    xor rdx, rdx\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    idiv rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rdx\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpopb)
    3 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_ARGC == if [
    "argc" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ARGV == if [
    "argv" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ENVP == if [
    "envp" 0 (checkpopb)
    1 (addstackb)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    add rax, 2\n` (writeout)
    `    shl rax, 3\n` (writeout)
    `    mov rbx, [args_ptr]\n` (writeout)
    `    add rbx, rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 1 (checkpopb)
    0 (addstackb)
    `    mov rax, 60\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpopb)
    0 (addstackb)
    procstackTab
    procname (getexpandedname) (tab.get)
    4294967296 / disc
    255 &&
    parsestackblock read != if (badret)
    disc
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    sub rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    jmp qword [rax]\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpopb)
    0 (addstackb)
    `    pop rax\n` (writeout)
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov bl, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpopb)
    1 (addstackb)
    `   pop rax\n` (writeout)
    `   xor rbx, rbx\n` (writeout)
    `   mov rbx, [rax]\n` (writeout)
    `   push rbx\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov byte [rax], bl\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpopb)
    1 (addstackb)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov qword [rax], rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovne rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmove rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpopb)
    1 (addstackb)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovl rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpopb)
    0 (addstackb)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 - (cstr.int) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read 1 + (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpopb)
    1 (addstackb)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpopb)
    0 (addstackb)
    `    pop rax\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpopb)
    0 (addstackb)
    (identstackpop)
    (endopblockasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpopb)
    0 (addstackb)
    parsesubaddr read 1 - (identstackpush)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpopb)
    0 (addstackb)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_LVAR == if [
    "lvar" 0 (checkpopb)
    0 (addstackb)
    parseflags
    CF_LVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpopb)
    0 (addstackb)
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  {TODO: log this}
  `; unimp ` (writeout)
  (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc parsestring 0 0

  { add code }
  1 (addstackb)
  `    push str_` (writeout)
  (getstringidx) (cstr.int) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (cstr.int)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  blockbuffer 1 +

  { put the first char }
  copy readc
  (cstr.int)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (cstr.int)
    copy (cstr.len) swap
    stringbuffer stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  `\n`
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  disc

  blockbuffer (cstr.clear) disc
  ret
end

proc parseblockcmd 0 0
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' == && if [
    {comment}

    nop

    blockbuffer (cstr.clear) disc
  ] blockbuffer readc '"' == blockbuffer (cstr.last) '"' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner)
    (parsestring)

    disc ret
  ] blockbuffer readc '`' == blockbuffer (cstr.last) '`' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner) disc
    1 (addstackb)
    `    push ` (writeout)
    blockbuffer 1 + (cstr.len) (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestring)
    ret
  ] blockbuffer readc '(' == blockbuffer (cstr.last) ')' == && if [
    {call}

    (writesubaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read 1 - (cstr.int) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    blockbuffer (inner) disc
    procTab
    blockbuffer 1 + (tab.in) ! if (noprocblock)
    blockbuffer 1 + (tab.get) (cstr.int)
    
    
    procstackTab
    blockbuffer 1 + (tab.get)
    255 && blockbuffer 1 + swap (checkpopb)
    blockbuffer 1 + (tab.get)
    4294967296 / disc
    255 && (addstackb)
    disc

    copy (cstr.len) swap
    (writeout)
    disc
    blockbuffer (cstr.clear) disc
    (writeoutln)
    ret
  ] blockbuffer readc 0 != if [
    parseflags read
    blockbuffer (getnameop)
    covr CF_NONE == if (getblockasm)
    covr CF_VAR == if (addvar)
    covr CF_LVAR_VALUE == if (addlvar)
    covr CF_LVAR_NAME == if (addlvar)
    disc disc
  ]
  blockbuffer (cstr.clear) disc

  ret
end

proc badop 0 0
  "BAD OPERATION: " (cstr.println)
  "`" (cstr.print) cmdbuffer (cstr.print) "`" (cstr.println)
  (exit)

  ret
end

proc checkbad 1 1
  cmdbuffer (cstr.len) 3 ==
  cmdbuffer readc ''' == &&
  cmdbuffer (cstr.last) ''' == && if [
    cmdbuffer 1 + readc
    (cstr.int)

    cmdbuffer (cstr.clear) swap (cstr.copy) disc disc

    disc OP_PUSH
    ret
  ]
  constTab cmdbuffer (tab.in) if [
    cmdbuffer (tab.get) swap disc
    (cstr.int)
    cmdbuffer (cstr.clear) swap (cstr.copy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  lvarTab cmdbuffer (tab.in) if [
    1 (addstack)
    `    push lmem+` (writeout)
    lvarTab cmdbuffer (tab.get) swap disc (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  gvarTab cmdbuffer (tab.in) if [
    1 (addstack)
    `    push mem+` (writeout)
    gvarTab cmdbuffer (tab.get) swap disc (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    
    disc OP_NOP
    ret
  ] disc
  (badop)
  ret
end

proc getcmdasm 1 1
  cmdbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if (checkbad)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    1 (addstack)
    `    mov qword rax, ` (writeout)
    cmdbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push rax\n` (writeout)
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpop)
    2 (addstack)
    `    pop rax\n` (writeout)
    `    push rax\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpop)
    2 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    sub rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    add rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    and rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    xor rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    or rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rax, 1\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    imul rax, rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "div" 2 (checkpop)
    2 (addstack)
    `    xor rdx, rdx\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    idiv rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rdx\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpop)
    3 (addstack)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    push rbx\n` (writeout)
    `    push rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy IDENT_CLASS == if [
    "class" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CLASS
    put disc
    ret
  ] copy IDENT_PROC == if [
    "proc" 0 (checkpop)
    0 (addstack)
    IDENT_PROC (identstackpush)
    `    ; - proc` (writeout)
    parseflags
    CF_PROC_NAME
    put disc
    ret
  ] copy IDENT_ENUM == if [
    "enum" 0 (checkpop)
    0 (addstack)
    `    ; - enum\n` (writeout)
    parseflags
    CF_ENUM_START
    put disc
    ret
  ] copy OP_ARGC == if [
    "argc" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ARGV == if [
    "argv" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_ENVP == if [
    "envp" 0 (checkpop)
    1 (addstack)
    `    mov rax, [args_ptr]\n` (writeout)
    `    mov rax, [rax]\n` (writeout)
    `    add rax, 2\n` (writeout)
    `    shl rax, 3\n` (writeout)
    `    mov rbx, [args_ptr]\n` (writeout)
    `    add rbx, rax\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 1 (checkpop)
    0 (addstack)
    `    mov rax, 60\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpop)
    0 (addstack)
    procstackTab
    procname (getexpandedname) (tab.get)
    4294967296 / disc
    255 &&
    parsestack read != if (badret)
    disc
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    sub rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    jmp qword [rax]\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpop)
    0 (addstack)
    `    pop rax\n` (writeout)
    ret
  ] copy IDENT_PROP == if [
    "prop" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_PROP_NAME
    put disc
    ret
  ] copy OP_CONST == if [
    "const" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CONST_NAME
    put disc
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov bl, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    xor rbx, rbx\n` (writeout)
    `    mov rbx, [rax]\n` (writeout)
    `    push rbx\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov byte [rax], bl\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpop)
    1 (addstack)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    mov qword [rax], rbx\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovne rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rax\n` (writeout)
    `    pop rbx\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmove rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpop)
    1 (addstack)
    `    mov rcx, 0\n` (writeout)
    `    mov rdx, 1\n` (writeout)
    `    pop rbx\n` (writeout)
    `    pop rax\n` (writeout)
    `    cmp rax, rbx\n` (writeout)
    `    cmovl rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpop)
    0 (addstack)
    `    pop rbx\n` (writeout)
    `    test rbx, rbx\n` (writeout)
    `    jz addr_` (writeout)
    parseaddr read 1 + (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpop)
    1 (addstack)
    `    pop rax\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push rax\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpop)
    0 (addstack)
    `    pop rax\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_INC == if [
    "inc" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_INC
    put disc
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpop)
    0 (addstack)
    (identstackpop)
    (endopasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpop)
    0 (addstack)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_LVAR == if [
    "lvar" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_LVAR_NAME
    put disc
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  {TODO: log this}
  `; unimp ` (writeout)
  (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' != &&
  cmdbuffer readc ''' == cmdbuffer (cstr.last) ''' != && ||
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' != && ||
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' != && ||
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' != && ||
  cmdbuffer "`" (cstr.eq) ||
  cmdbuffer """ (cstr.eq) ||
  cmdbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkblockcmd 0 1
  blockbuffer readc '"' == blockbuffer (cstr.last) '"' != &&
  blockbuffer readc ''' == blockbuffer (cstr.last) ''' != && ||
  blockbuffer readc '`' == blockbuffer (cstr.last) '`' != && ||
  blockbuffer readc '[' == blockbuffer (cstr.last) ']' != && ||
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' != && ||
  blockbuffer "`" (cstr.eq) ||
  blockbuffer """ (cstr.eq) ||
  blockbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc blockbuffer 0 ret]

  { if the command is not complete, append a space }
  disc ' '

  ret
end

proc parseblock 0 0
  parsestackblock
  parsestack read
  put disc

  cmdbuffer
  blockbuffer
  do
    covr readc
    copy 9 {tab} ==
    covr 10 {lf} == ||
    covr 13 {cr} == ||
    covr 32 {spc} == ||
    if (checkbufferblock)

    blockbuffer readc

    copy '"' ==
    swap '`' == ||
    covr '\' == &&
    if [
      disc
      swap 1 +
      swap

      covr readc (getescape)
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc

  blockbuffer
  ' '
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  {
  parsestackblock read parsestack read == !
  if [
    cmdbuffer (cstr.print)
    " Bad Block" (cstr.println)
    parsestackblock read (cstr.printint)
    parsestack read (cstr.printint)
    -1 quit
  ]
  }
  ret
end

proc parsestringblock 0 0 

  { add code }
  1 (addstack)
  `    push str_` (writeout)
  (getstringidx) (cstr.int) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (cstr.int)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer 1 +

  { put the first char }
  copy readc
  (cstr.int)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (cstr.int)
    copy (cstr.len) swap
    stringbuffer stringbufferlen read +
    swap (cstr.copy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  disc
  `\n`
  stringbuffer stringbufferlen read +
  swap (cstr.copy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer (cstr.clear) disc
  ret
end

proc parsecmd 0 0
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' == && if [

    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' == && if [
    (writeaddr)

    cmdbuffer (inner)
    (parsestringblock)
    disc ret
  ]
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' == && if [
    {string}
    (writeaddr)

    cmdbuffer (inner) disc
    1 (addstack)
    `    push ` (writeout)
    cmdbuffer 1 + (cstr.len) (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestringblock)
    ret
  ]
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' == && if [
    (writeaddr)
    cmdbuffer (inner)
    cmdbuffer swap (cstr.copy) disc disc
    cmdbuffer copy (cstr.len) 1 - + 0 putc disc
    (parseblock)
    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '(' == cmdbuffer (cstr.last) ')' == && if [
    (writeaddr)
    `    mov rax, [ret_stack_rsp]\n` (writeout)
    `    add rax, 8\n` (writeout)
    `    mov qword [ret_stack_rsp], rax\n` (writeout)
    `    mov qword [rax], addr_` (writeout)
    parseaddr read (cstr.int) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jmp addr_` (writeout)
    cmdbuffer (inner) disc
    procTab
    cmdbuffer 1 + (tab.in) ! if (noproc)
    cmdbuffer 1 + (tab.get) (cstr.int)
    
    procstackTab
    cmdbuffer 1 + (tab.get)
    255 && cmdbuffer 1 + swap (checkpop)
    cmdbuffer 1 + (tab.get)
    4294967296 / disc
    255 && (addstack)
    disc

    copy (cstr.len) swap
    (writeout)
    disc
    cmdbuffer (cstr.clear) disc
    (writeoutln)
    ret
  ]
  cmdbuffer readc 0 != if [
    parseflags read
    cmdbuffer (getnameop)
    covr CF_NONE == if (getcmdasm)
    covr CF_PROC_OUT == if (addproc)
    covr CF_PROC_IN == if (addproc)
    covr CF_PROC_NAME == if (addproc)
    covr CF_CONST_VALUE == if (addconst)
    covr CF_CONST_NAME == if (addconst)
    covr CF_PROP_VALUE == if (addprop)
    covr CF_PROP_NAME == if (addprop)
    covr CF_INC == if (addinc)
    covr CF_VAR == if (addvar)
    covr CF_LVAR_NAME == if (addlvar)
    covr CF_LVAR_VALUE == if (addlvar)
    covr CF_GVAR_NAME == if (addgvar)
    covr CF_GVAR_VALUE == if (addgvar)
    covr CF_ENUM_CONTENT == if (addenum)
    covr CF_ENUM_START == if (addenumstart)
    covr CF_CLASS == if (setclassname)
    disc disc
  ]
  cmdbuffer (cstr.clear) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc cmdbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  READSIZE readbuffer
  inputfd read (os.read) disc
  inputfd read 74 sys1 disc
  do
    readbuffer
    cmdbuffer
    do
      covr readc

      copy 9 {tab} ==
      covr 10 {lf} == ||
      covr 13 {cr} == ||
      covr 32 {spc} == ||
      if (checkbuffer)

      cmdbuffer readc

      copy '"' ==
      swap '`' == ||
      covr '\' == &&
      if [
        disc
        swap 1 +
        swap

        covr readc (getescape)
      ]

      covr
      swap
      putc disc

      swap
      1 +
      swap
      copy readc 0 != if [
        1 +
      ]

      covr readc 0 !=
    end
    disc
    disc

    readbuffer (cstr.clear)

    cmdbuffer (cstr.copy) disc disc

    READSIZE cmdbuffer (cstr.len) -

    readbuffer cmdbuffer (cstr.len) +

    inputfd read (os.read) copy
    readbuffer + cmdbuffer (cstr.len) + 1 + copy readc 0 != if (cstr.clear) disc
    inputfd read 74 sys1 disc

    cmdbuffer (cstr.clear) disc
  end

  ret
end

{
args: int
result:

prints a help string
}
proc help 1 0
  copy HELP_VERSION == if [
    "slim compiler v" (cstr.print) (version) (cstr.println)
    (exit)
  ]
  "Help"
  covr HELP_ARGS == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr HELP_OUTPUT == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (cstr.println)
  "slim compiler v" (cstr.print) (version) (cstr.print) " usage:" (cstr.println)
  (cstr.cr)
  "slim [-h]\ [-a]\ [-s]\ [-i include]\ [-o output]\ file" (cstr.println)
  (cstr.cr)
  "-v            shows the version and exits." (cstr.println)
  "-h, --help    shows this help message."     (cstr.println)
  "-i, --include includes a library."          (cstr.println)
  "-s, --silent  disables output text."        (cstr.println)
  "-a, --asm     keeps the assembly code."     (cstr.println)
  "-o, --output  selects the output file."     (cstr.println)
  disc
  (exit)

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  cmdlineflags
  cmdlineflags read 1 ||
  put
  disc
  ret
end

proc setasm 0 0
  cmdlineflags
  cmdlineflags read 2 ||
  put
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    outputbuffer
    covr (os.args)
    (cstr.copy)

    disc
    disc
    ret
end

proc openinput 1 0
  inputfd read
  copy != 0 if [(os.close) 0]
  disc

  cmdlineflags read ! if [
    0 1 (log.level)
    "SLM" covr (log.msg)
    (log.log)
  ]

  {open input}
  0 swap 0 swap
  -100
  (os.open)
  inputfd swap put disc

  ret
end

proc parseinc 0 0
  includebuffer read NULL == if ret
  includebuffer
  includetmpbuffer
  do
    covr readc

    copy ',' ==
    if [
      includetmpbuffer (openinput)
      (parsefile)
      includetmpbuffer (cstr.clear) disc
      disc disc
      includetmpbuffer 0
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc
  includetmpbuffer (openinput)
  (parsefile)
  includetmpbuffer (cstr.clear) disc

  ret
end

proc setinclude 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    includebuffer
    covr (os.args)
    (cstr.copy)

    disc
    disc
    ret
end

proc setinput 1 0
  inputbuffer
  readc 0 != if [HELP_ARGS (help)]

  { set input to argument if its not a flag }
  inputbuffer
  covr (os.args)
  (cstr.copy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "--help" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "-v" (cstr.eq)
  if [disc HELP_VERSION (help) 0 ret]
  copy "-i" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--include" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "-o" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "-a" (cstr.eq)
  if [disc (setasm) 0 ret]
  copy "--asm" (cstr.eq)
  if [disc (setasm) 0 ret]
  disc
  1 ret
end

proc nasm 0 0
  cmdtmpbuffer
  "/usr/bin/fasm" put 8 +
  "temp.fasm" put 8 +
  "tmp" put 8 +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc ld 0 0
  162 sys0 disc

  cmdtmpbuffer
  "/usr/bin/mv" put 8 +
  "tmp" put 8 +
  outputbuffer put 8 +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  cmdlineflags read 2 && 0 != if [
    ret
  ]

  cmdtmpbuffer
  "/usr/bin/rm" put 8 +
  "temp.fasm" put 8 +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc initobjs 0 0
  gvarTab      TAB_KEY_SIZE 300000 (tab.new) disc
  lvarTab      TAB_KEY_SIZE 100000 (tab.new) disc
  constTab     TAB_KEY_SIZE 300000 (tab.new) disc
  procTab      TAB_KEY_SIZE 300000 (tab.new) disc
  procstackTab TAB_KEY_SIZE 300000 (tab.new) disc

  identstack   8            4096   (arr.new) disc
  
  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [HELP_ARGS (help)]

  (initobjs)

  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (os.args)

    (applyarg) if [copy (setinput)]

    copy argc 1 - <
  end
  disc

  outputbuffer
  readc 0 ==
  if [outputbuffer "output" (cstr.copy) disc disc]

  inputbuffer
  readc 0 ==
  if [HELP_ARGS (help)]

  {open output}
  511 65 "temp.fasm"
  -100
  (os.open)
  outputfd swap put disc

  {parse input}
  (asmheader)

  (parseinc)

  inputbuffer
  (openinput)

  (parsefile)

  (asmfooter)

  {close output}
  outputfd read (os.close)

  {close input}
  inputfd read (os.close)

  (nasm)
  (ld)

  0 quit

  ret
end
