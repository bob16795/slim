{
args: pointer
result: 

prints a string
}
proc print 1 0 
  copy 
  read
  0 == if [disc ret]
  do
    { read the current char }
    copy 
    read
    dump
    
    { increase the address }
    1 +

    { read the next address }
    copy
    read
    
    { convert to a byte }
    255 &&
    0 !=
  end
  disc
  ret
end

{
args:
result:

prints a new line
}
proc endl 0 0
  { print new line }
  10
  dump
  ret
end

{
prints
}
proc println 1 0
  (print)
  (endl)
  ret
end

{
args: int
result: pointer

gets the nth arguent from the command line
}
proc args 1 1
  copy argc - 0 > if ["Bad arg" (println) disc quit]
  8 * 
  argv +

  read
  ret
end

{
args: pointer pointer
result: 

copy a string from a pointer to another
}
proc strcpy 2 2
  covr
  covr
  do
    covr
    covr
    read 255 &&

    putc
    disc

    copy read 255 && 0 ==
    if [disc disc ret]

    swap 1 +
    swap 1 +
    1
  end
  disc
  disc
  ret
end

{
args: pointer pointer
result: int

compares strings, returns 1 if they are not equal
}
proc streq 2 1
  1 -
  swap
  1 -
  do
    1 +
    swap
    1 +
    covr
    read 255 &&
    covr
    read 255 &&
    covr 0 ==
    covr 0 ==
    &&
    if [
      disc
      disc
      disc
      disc
      1
      ret
      ]
    covr 0 ==
    covr 0 ==
    !=
    if [
      disc
      disc
      disc
      disc
      0
      ret
    ]
    ==
  end
  disc
  disc
  0
  ret
end

{
args: pointer int int
result: int

opens a file
}
proc open 3 1
  2
  sys3
  
  copy 0 < if ["Error opening file" (println) disc quit]
  ret
end

{
args: int
result:

closes a file
}
proc close 1 0
  3
  sys1

  0 < if ["Error closing file" (println) quit]
  ret
end

{
args: int ptr
result: int

writes data to a file
}
proc write 3 0
  1
  sys3

  0 < if ["Error writing file" (println) quit]
  ret
end

{
args: int ptr
result: int

writes data to a file
}
proc read 3 1
  0
  sys3

  1 < 0 == {if ["Error reading file" (println) quit]}
  ret
end

{
args: int
result: ptr

converts a int to a string
}
proc intstr 1 1

  ret
end

proc strlen 1 1
  0
  do
    1 +
    covr
    covr +
    read 255 &&
    0 !=
  end

  swap disc
  ret
end
inc lib/stdlib.slm

{The Slim Compiler, written in Slim}

const OP_BAD   255
const OP_NOP   0
const OP_PUSH  1
const OP_SUB   2
const OP_MUL   3
const OP_PLUS  4
const OP_SWAP  5
const OP_DUMP  6
const OP_COPY  7 
const OP_COVR  8
const OP_GPTR  9 
const OP_READ  10
const OP_PUTC  11
const OP_DISC  12
const OP_ARGV  13
const OP_ARGC  14
const OP_PUSHP 15
const OP_CALLS 16
const OP_MULTI 17
const OP_CONST 18
const OP_CALL  19
const OP_PROC  20
const OP_RET   21
const OP_QUIT  22
const OP_LOCX  23
const OP_JUMPX 24
const OP_JUMP  25
const OP_IF    26
const OP_JNZ   27
const OP_GETP  28
const OP_CYCL  29
const OP_NQ    30
const OP_EQ    31
const OP_LT    32
const OP_GT    33
const OP_AND   34
const OP_SYS0  35
const OP_SYS1  36
const OP_SYS2  37
const OP_SYS3  38
const OP_SYS4  39
const OP_SYS5  40
const OP_SYS6  41

proc getnameop 1 1
  OP_BAD
  covr read 255 && 123 == if [disc OP_NOP]
  covr "nop"   (streq) if [disc OP_NOP]
  covr "-"     (streq) if [disc OP_SUB]  
  covr "*"     (streq) if [disc OP_MUL]  
  covr "+"     (streq) if [disc OP_PLUS]
  covr "swap"  (streq) if [disc OP_SWAP]
  covr "dump"  (streq) if [disc OP_DUMP] 
  covr "copy"  (streq) if [disc OP_COPY] 
  covr "covr"  (streq) if [disc OP_COVR] 
  covr "var"   (streq) if [disc OP_GPTR] 
  covr "read"  (streq) if [disc OP_READ] 
  covr "putc"  (streq) if [disc OP_PUTC] 
  covr "disc"  (streq) if [disc OP_DISC] 
  covr "argv"  (streq) if [disc OP_ARGV] 
  covr "argc"  (streq) if [disc OP_ARGC] 
  covr "()"    (streq) if [disc OP_CALLS] 
  covr "const" (streq) if [disc OP_CONST]
  covr "proc"  (streq) if [disc OP_PROC]
  covr "ret"   (streq) if [disc OP_RET] 
  covr "quit"  (streq) if [disc OP_QUIT]  
  covr "if"    (streq) if [disc OP_IF] 
  covr "cycl"  (streq) if [disc OP_CYCL] 
  covr "!="    (streq) if [disc OP_NQ] 
  covr "=="    (streq) if [disc OP_EQ]   
  covr "<"     (streq) if [disc OP_LT]   
  covr ">"     (streq) if [disc OP_GT]   
  covr "&&"    (streq) if [disc OP_AND]  
  covr "sys0"  (streq) if [disc OP_SYS0]
  covr "sys1"  (streq) if [disc OP_SYS1]  
  covr "sys2"  (streq) if [disc OP_SYS2]  
  covr "sys3"  (streq) if [disc OP_SYS3]  
  covr "sys4"  (streq) if [disc OP_SYS4]  
  covr "sys5"  (streq) if [disc OP_SYS5]  
  covr "sys6"  (streq) if [disc OP_SYS6]  
  swap disc

  ret
end

proc getopname 1 1
  "bad"
  covr OP_NOP   == if [disc "nop"]
  covr OP_PUSH  == if [disc "push"]
  covr OP_SUB   == if [disc "sub"]
  covr OP_MUL   == if [disc "mul"]
  covr OP_PLUS  == if [disc "plus"]
  covr OP_SWAP  == if [disc "swap"]
  covr OP_DUMP  == if [disc "dump"]
  covr OP_COPY  == if [disc "copy"]
  covr OP_COVR  == if [disc "covr"]
  covr OP_GPTR  == if [disc "gptr"]
  covr OP_READ  == if [disc "read"]
  covr OP_PUTC  == if [disc "putc"]
  covr OP_DISC  == if [disc "disc"]
  covr OP_ARGV  == if [disc "argv"]
  covr OP_ARGC  == if [disc "argc"]
  covr OP_PUSHP == if [disc "push"]
  covr OP_CALLS == if [disc "call"]
  covr OP_MULTI == if [disc "[]"]
  covr OP_CONST == if [disc "const"]
  covr OP_CALL  == if [disc "call"]
  covr OP_PROC  == if [disc "proc"]
  covr OP_RET   == if [disc "ret"]
  covr OP_QUIT  == if [disc "quit"]
  covr OP_LOCX  == if [disc "location"]
  covr OP_JUMPX == if [disc "jump"]
  covr OP_JUMP  == if [disc "jump"]
  covr OP_IF    == if [disc "if"]
  covr OP_JNZ   == if [disc "jnz"]
  covr OP_GETP  == if [disc "getp"]
  covr OP_CYCL  == if [disc "cycl"]
  covr OP_NQ    == if [disc "!="]
  covr OP_EQ    == if [disc "=="]
  covr OP_LT    == if [disc "<"]
  covr OP_GT    == if [disc ">"]
  covr OP_AND   == if [disc "&&"]
  covr OP_SYS0  == if [disc "sys0"]
  covr OP_SYS1  == if [disc "sys1"]
  covr OP_SYS2  == if [disc "sys2"]
  covr OP_SYS3  == if [disc "sys3"]
  covr OP_SYS4  == if [disc "sys4"]
  covr OP_SYS5  == if [disc "sys5"]
  covr OP_SYS6  == if [disc "sys6"]
  swap disc
  ret
end

proc getoutput 0 1
  var 128
  ret
end

proc getoutputfd 0 1
  var 8
  ret
end

proc getinputfd 0 1
  var 8
  ret
end

proc getinput 0 1
  var 128
  ret
end

proc getsilent 0 1
  var 8
  ret
end

proc getreadbuffer 0 1
  var 128
  ret
end

proc getcmdbuffer 0 1
  var 128
  ret
end

proc getcmdidx 0 1
  var 8
  ret
end

proc cmdflags 0 1
  var 8
  ret
end

proc writeout 1 0
  copy (strlen) swap (getoutputfd) read (write)

  ret
end

proc addproc 0 0
  " " (writeout)
  (getcmdbuffer) (writeout)
  (cmdflags) 1 == if [
    "\n" (writeout)
  ]
  (cmdflags)
  copy read 1 -
  putc disc

  ret
end

proc addconst 0 0
  (getcmdbuffer) (writeout)
  "\n" (writeout)
  "    push rax\n" (writeout)

  ret
end

proc getcmdasm 1 0
  copy OP_BAD == if [
    "BAD OPERATION: " (println)
    (getcmdbuffer) (println)
  
    {close output}
    (getoutputfd) read (close)
  
    {close input}
    (getinputfd) read (close)

    disc quit
  ]
  copy OP_NOP == if [
    nop
  ] copy OP_PUSH == if [
    "    mov qword rax " (writeout)
    (cmdflags)
    1
    putc disc
    disc ret
  ] copy OP_SUB == if [
    "    pop rbx\n" (writeout)
    "    pop rax\n" (writeout)
    "    sub rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_PLUS == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    add rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_MUL == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    imul rax, rbx\n" (writeout)
    "    push rax\n" (writeout)
    disc ret
  ] copy OP_COVR == if [
    "    pop rax\n" (writeout)
    "    pop rbx\n" (writeout)
    "    push rbx\n" (writeout)
    "    push rax\n" (writeout)
    "    push rbx\n" (writeout)
    disc ret
  ] copy OP_PROC == if [
    "    ; - proc" (writeout)
    (cmdflags)
    3
    putc disc
    disc ret
  ]
  "; unimp\n" (writeout)
  disc
  ret
end

proc clearbuf 1 1
  copy "" (streq) if [ret]
  copy
  do
    copy
    0
    putc
    disc

    1 +
    copy read
  end
  disc

  ret
end

proc parsecmd 0 0
  (getcmdbuffer) "" (streq) 0 == if [
    (cmdflags) read
    (getcmdbuffer) (getnameop)
    covr 0 == if (getcmdasm)
    covr 1 == if (addproc)
    covr 2 == if (addproc)
    covr 3 == if (addproc)
    covr 4 == if (addconst)
    disc
    disc
  ]
  (getcmdbuffer) (clearbuf) disc
  ret
end


proc last 1 1
  do
    1 +
    copy read 255 &&
    0 !=
  end
  1 -
  read 255 &&

  ret
end

proc checkcmd 0 1
  {""}
  (getcmdbuffer) read 255 && 34 == (getcmdbuffer) (last) 34 != && 
  {[]}
  (getcmdbuffer) read 255 && 91 == (getcmdbuffer) (last) 93 != && +
  {{}}
  (getcmdbuffer) read 255 && 123 == (getcmdbuffer) (last) 125 != && +
  0 ==
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 1
  127 (getreadbuffer)
  (getinputfd) read (read) disc
  (getreadbuffer)
  (getcmdbuffer)
  do
    do
      covr
      read 255 &&
      copy 9 {tab} ==
      covr 10 {newline} == +
      covr 13 {newline} == +
      covr 32 {space} == +
      0 !=
      if [
          { if the command is complete, get the buffer }
          (checkcmd) 0 == if [(parsecmd) disc disc (getcmdbuffer) 1 - 0]\
          
          { if the command is not complete, append a space }
          (checkcmd) 0 != if [disc 32]\

          { if there are 2 spaces, dont add a space }
          copy 32 ==
          (getcmdbuffer) (last) 32 ==
          && if [disc 1 - 0]\
      ]
      covr
      swap
      copy 0 != if [putc 0]
      disc
      disc

      swap 1 +
      swap 1 +

      covr read 255 && 0 !=
    end
    swap
    disc
    (getreadbuffer) (clearbuf)
    swap
    31 (getreadbuffer)
    (getinputfd) read (read)
  end
  disc
  disc
  0
  ret
end

{
args: int 
result: 

prints a help string
}
proc help 1 0
  "INVALID HELP ID"
  covr 1 == if [
    disc 
    "Help"
  ] covr 2 == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr 3 == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (println)
  "slim compiler usage:"                       (println)
  (endl)
  "slim [-h]\ [-s]\ [-o output]\ file"     (println)
  (endl)
  "-h, --help\t\tshows this help message." (println)
  "-s, --silent\tdisables output text."    (println)
  "-o, --output\tselects the output file." (println)
  (endl)
  disc
  quit

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  (getsilent)
  1
  putc
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [3 (help)]
    
    (getoutput)
    covr (args)
    (strcpy)

    disc
    disc
    ret
end

{
args: ptr int 
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (streq)
  if [disc 1 (help) 0 ret]
  copy "--help" (streq)
  if [disc 1 (help) 0 ret]
  copy "-o" (streq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (streq) 
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (streq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (streq)
  if [disc (setsilent) 0 ret]
  disc
  1 ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [2 (help)]
  
  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (args)

    (applyarg) if [
      (getinput)
      read 255 && 0 != if [2 (help)]\

      { set input to argument if its not a flag }
      (getinput)
      covr (args)
      (strcpy)

      { clean that }
      disc
      disc
    ]
    copy argc 1 - <
  end
  disc

  (getoutput) 
  read 255 && 0 ==
  if [(getoutput) "output" (strcpy)]

  (getinput)
  read 255 && 0 ==
  if [2 (help)]
  
  {open input}
  448 0 (getinput) (open)
  (getinputfd) swap putc disc
   
  {open output}
  448 66 "temp.asm" (open)
  (getoutputfd) swap putc disc
  
  {parse input}
  (parsefile) disc 

  {close output}
  (getoutputfd) read (close)
  
  {close input}
  (getinputfd) read (close)

  ret
end
